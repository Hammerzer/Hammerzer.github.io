<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSS 命名方案</title>
    <url>/2020/09/17/css-naming-scheme/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT-OUTLINE"></a>CONTENT-OUTLINE</h2><blockquote>
<p>css 作用域是全局的，项目越来越大，人越来越多，命名慢慢成为问题</p>
<p>以下是几种解决命名问题的方案</p>
<p>– BEM</p>
<p>– Scoped CSS</p>
<p>– CSS modules</p>
</blockquote>
<a id="more"></a>

<h2 id="一、BEM"><a href="#一、BEM" class="headerlink" title="一、BEM"></a>一、BEM</h2><p><code>BEM</code>代表块（Block），元素（Element），修饰符（Modifier）。</p>
<p><code>BEM</code>给我们的规定是块和元素之间用 — 连接，元素和修饰符之间用 _ 连接。例如：我们要设置表格某一行的背景颜色为红色，我们可以如下命名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;table-row_red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>规范化书写实例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;logo-img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;logo-words_big&quot;</span>&gt;</span>QQ·<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;logo-word_small&quot;</span>&gt;</span>PC版<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span>QQ官网首页<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span>申请QQ<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span>当前在线用户:2559393943<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;main-img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./img.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-words_small&quot;</span>&gt;</span>QQ PC版9.0.8<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main-words_big&quot;</span>&gt;</span>从新出发·趣无止境<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;mian-button_blue&quot;</span>&gt;</span>立即下载<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="二-Scoped-CSS"><a href="#二-Scoped-CSS" class="headerlink" title="二. Scoped CSS"></a>二. Scoped CSS</h2><blockquote>
<p><a href="https://vue-loader.vuejs.org/zh/guide/scoped-css.html">vue-loader的传送门</a></p>
</blockquote>
<p>目标：当前组件样式不会影响其它组件</p>
<p>给组件的 dom 节点添加惟一属性，并转换 style 标签中的 css 匹配该属性，使得 css 作用域有限</p>
<p><strong>实例</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.example</span> &#123;</span></span><br><span class="line">          color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>转换结果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.example</span><span class="selector-attr">[data-v-f3f3eg9]</span> &#123;</span></span><br><span class="line">          color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;example&quot;</span> <span class="attr">data-v-f3f3eg9</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三-CSS-modules"><a href="#三-CSS-modules" class="headerlink" title="三. CSS modules"></a>三. CSS modules</h2><blockquote>
<p><a href="https://vue-loader.vuejs.org/zh/guide/css-modules.html#%E7%94%A8%E6%B3%95">VUE-loader传送门- CSS Moudules</a></p>
</blockquote>
<p>将 <code>css</code> 的选择器转换成惟一的字符串，运用到 DOM。是在用算法命名，记录了人的命名到算法命名的 <code>map</code> 表</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">module</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.red</span> &#123;</span></span><br><span class="line">      color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;$style.red&quot;</span>&gt;</span></span><br><span class="line">    This should be red</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span>    </span><br></pre></td></tr></table></figure>

<p>转换结果：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">module</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">._1yZGjg0pYkMbaHPr4wT6P__1</span> &#123;</span></span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;_1yZGjg0pYkMbaHPr4wT6P__1&quot;</span>&gt;</span></span><br><span class="line">    This should be red</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><code>BEM</code> 让命名有规律、有含义，block 可视为模块，有一定作用域含义</li>
<li><code>scoped css</code> 限定 css 作用域，无关命名。无法适配多套主题</li>
<li><code>css modules</code> 使用算法命名，没有了命名冲突，也限定了 css 作用域。无法适配多套主题</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 选择器</title>
    <url>/2020/09/17/css-selectors/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT-OUTLINE"></a>CONTENT-OUTLINE</h2><blockquote>
<p>下面再次回顾一下CSS 选择器<code>(selectors)</code></p>
<p>–  共五大类：基本选择器、组合选择器、伪类选择器、伪对象选择器、属性选择器</p>
<p>–  选择器权重计算</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>参考相应的书籍整理，但自从发现<a href="http://www.ruanyifeng.com/blog/2009/03/css_selectors.html">阮一峰老师笔记</a>，整理的很不错！</p>
</blockquote>
<h2 id="五大类选择器概述"><a href="#五大类选择器概述" class="headerlink" title="五大类选择器概述"></a>五大类选择器概述</h2><h3 id="一、基本选择器"><a href="#一、基本选择器" class="headerlink" title="一、基本选择器"></a>一、基本选择器</h3><table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>1.</td>
<td>*****</td>
<td>通用元素选择器，匹配任何元素</td>
</tr>
<tr>
<td>2.</td>
<td><strong>E</strong></td>
<td>标签选择器，匹配所有使用E标签的元素</td>
</tr>
<tr>
<td>3.</td>
<td><strong>.info</strong></td>
<td>class选择器，匹配所有class属性中包含info的元素</td>
</tr>
<tr>
<td>4.</td>
<td><strong>#footer</strong></td>
<td>id选择器，匹配所有id属性等于footer的元素</td>
</tr>
</tbody></table>
<h3 id="二、组合选择器"><a href="#二、组合选择器" class="headerlink" title="二、组合选择器"></a>二、组合选择器</h3><table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>5.</td>
<td>E,F</td>
<td>多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔</td>
</tr>
<tr>
<td>6.</td>
<td>E F</td>
<td>后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔</td>
</tr>
<tr>
<td>7.</td>
<td>E &gt; F</td>
<td>子元素选择器，匹配所有E元素的子元素F</td>
</tr>
<tr>
<td>8.</td>
<td>E + F</td>
<td>毗邻元素选择器，匹配所有紧随E元素之后的同级元素F</td>
</tr>
</tbody></table>
<h3 id="三、CSS-2-1-属性选择器"><a href="#三、CSS-2-1-属性选择器" class="headerlink" title="三、CSS 2.1 属性选择器"></a>三、<em>CSS 2.1</em> 属性选择器</h3><table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>9.</td>
<td>E[att]</td>
<td>匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如”[cheacked]”。以下同。）</td>
</tr>
<tr>
<td>10.</td>
<td>E[att=val]</td>
<td>匹配所有att属性等于”val”的E元素</td>
</tr>
<tr>
<td>11.</td>
<td>E[att~=val]</td>
<td>匹配所有att属性具有多个空格分隔的值、其中一个值等于”val”的E元素</td>
</tr>
<tr>
<td>12.</td>
<td>E[att|=val]</td>
<td>匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性，比如”en”、”en-us”、”en-gb”等等</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[title]</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class=error]</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">td</span><span class="selector-attr">[headers~=col1]</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[lang|=en]</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">blockquote</span><span class="selector-attr">[class=quote]</span><span class="selector-attr">[cite]</span> &#123; <span class="attribute">color</span>:<span class="number">#f00</span>; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、CSS-2-1中的伪类"><a href="#四、CSS-2-1中的伪类" class="headerlink" title="四、CSS 2.1中的伪类"></a>四、<em>CSS 2.1</em>中的伪类</h3><table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>13.</td>
<td>E:first-child</td>
<td>匹配父元素的第一个子元素</td>
</tr>
<tr>
<td>14.</td>
<td>E:link</td>
<td>匹配所有未被点击的链接</td>
</tr>
<tr>
<td>15.</td>
<td>E:visited</td>
<td>匹配所有已被点击的链接</td>
</tr>
<tr>
<td>16.</td>
<td>E:active</td>
<td>匹配鼠标已经其上按下、还没有释放的E元素</td>
</tr>
<tr>
<td>17.</td>
<td>E:hover</td>
<td>匹配鼠标悬停其上的E元素</td>
</tr>
<tr>
<td>18.</td>
<td>E:focus</td>
<td>匹配获得当前焦点的E元素</td>
</tr>
<tr>
<td>19.</td>
<td>E:lang(c)</td>
<td>匹配lang属性等于c的E元素</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:first-child</span> &#123; <span class="attribute">font-style</span>:italic; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span><span class="selector-pseudo">:focus</span> &#123; <span class="attribute">color</span>:<span class="number">#000</span>; <span class="attribute">background</span>:<span class="number">#ffe</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=text]</span><span class="selector-pseudo">:focus</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">background</span>:<span class="number">#fff</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">q</span><span class="selector-pseudo">:lang(sv)</span> &#123; <span class="attribute">quotes</span>: <span class="string">&quot;\201D&quot;</span> <span class="string">&quot;\201D&quot;</span> <span class="string">&quot;\2019&quot;</span> <span class="string">&quot;\2019&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="五、-CSS-2-1中的伪元素"><a href="#五、-CSS-2-1中的伪元素" class="headerlink" title="五、 CSS 2.1中的伪元素"></a>五、 <em>CSS 2.1</em>中的伪元素</h3><table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>20.</td>
<td>E:first-line</td>
<td>匹配E元素的第一行</td>
</tr>
<tr>
<td>21.</td>
<td>E:first-letter</td>
<td>匹配E元素的第一个字母</td>
</tr>
<tr>
<td>22.</td>
<td>E:before</td>
<td>在E元素之前插入生成的内容</td>
</tr>
<tr>
<td>23.</td>
<td>E:after</td>
<td>在E元素之后插入生成的内容</td>
</tr>
</tbody></table>
<h3 id="六、CSS-3的同级元素通用选择器"><a href="#六、CSS-3的同级元素通用选择器" class="headerlink" title="六、CSS 3的同级元素通用选择器"></a>六、CSS 3的同级元素通用选择器</h3><table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>24.</td>
<td>E ~ F</td>
<td>匹配任何在E元素之后的同级F元素</td>
</tr>
</tbody></table>
<h3 id="七、CSS-3-属性选择器"><a href="#七、CSS-3-属性选择器" class="headerlink" title="七、CSS 3 属性选择器"></a>七、CSS 3 属性选择器</h3><table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>25.</td>
<td>E[att^=”val”]</td>
<td>属性att的值以”val”开头的元素</td>
</tr>
<tr>
<td>26.</td>
<td>E[att$=”val”]</td>
<td>属性att的值以”val”结尾的元素</td>
</tr>
<tr>
<td>27.</td>
<td>E[att*=”val”]</td>
<td>属性att的值包含”val”字符串的元素</td>
</tr>
</tbody></table>
<h3 id="八、CSS-3中与用户界面有关的伪类"><a href="#八、CSS-3中与用户界面有关的伪类" class="headerlink" title="八、CSS 3中与用户界面有关的伪类"></a>八、CSS 3中与用户界面有关的伪类</h3><table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>28.</td>
<td>E:enabled</td>
<td>匹配表单中激活的元素</td>
</tr>
<tr>
<td>29.</td>
<td>E:disabled</td>
<td>匹配表单中禁用的元素</td>
</tr>
<tr>
<td>30.</td>
<td>E:checked</td>
<td>匹配表单中被选中的radio（单选框）或checkbox（复选框）元素</td>
</tr>
<tr>
<td>31.</td>
<td>E::selection</td>
<td>匹配用户当前选中的元素</td>
</tr>
</tbody></table>
<h3 id="九、CSS-3中的结构性伪类"><a href="#九、CSS-3中的结构性伪类" class="headerlink" title="九、CSS 3中的结构性伪类"></a>九、CSS 3中的结构性伪类</h3><table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>32.</td>
<td>E:root</td>
<td>匹配文档的根元素，对于HTML文档，就是HTML元素</td>
</tr>
<tr>
<td>33.</td>
<td>E:nth-child(n)</td>
<td>匹配其父元素的第n个子元素，第一个编号为1</td>
</tr>
<tr>
<td>34.</td>
<td>E:nth-last-child(n)</td>
<td>匹配其父元素的倒数第n个子元素，第一个编号为1</td>
</tr>
<tr>
<td>35.</td>
<td>E:nth-of-type(n)</td>
<td>与:nth-child()作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr>
<td>36.</td>
<td>E:nth-last-of-type(n)</td>
<td>与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素</td>
</tr>
<tr>
<td>37.</td>
<td>E:last-child</td>
<td>匹配父元素的最后一个子元素，等同于:nth-last-child(1)</td>
</tr>
<tr>
<td>38.</td>
<td>E:first-of-type</td>
<td>匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)</td>
</tr>
<tr>
<td>39.</td>
<td>E:last-of-type</td>
<td>匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(1)</td>
</tr>
<tr>
<td>40.</td>
<td>E:only-child</td>
<td>匹配父元素下仅有的一个子元素，等同于:first-child:last-child或 :nth-child(1):nth-last-child(1)</td>
</tr>
<tr>
<td>41.</td>
<td>E:only-of-type</td>
<td>匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)</td>
</tr>
<tr>
<td>42.</td>
<td>E:empty</td>
<td>匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素</td>
</tr>
</tbody></table>
<h3 id="十、CSS-3的反选伪类"><a href="#十、CSS-3的反选伪类" class="headerlink" title="十、CSS 3的反选伪类"></a>十、CSS 3的反选伪类</h3><table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>43.</td>
<td>E:not(s)</td>
<td>匹配不符合当前选择器的任何元素</td>
</tr>
</tbody></table>
<h3 id="十一、CSS-3中的-target-伪类"><a href="#十一、CSS-3中的-target-伪类" class="headerlink" title="十一、CSS 3中的 :target 伪类"></a>十一、CSS 3中的 :target 伪类</h3><blockquote>
<p>目标伪类：它表示匹配 E 的所有元素，且匹配元素被相关URL指向。</p>
<p>该选择器为动态选择器，只有当存在URL指向该匹配元素时，样式效果才有效。</p>
</blockquote>
<table>
<thead>
<tr>
<th>序号</th>
<th>选择器</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>44.</td>
<td>E:target</td>
<td>匹配文档中特定”id”点击后的效果</td>
</tr>
</tbody></table>
<h2 id="选择器权重计算"><a href="#选择器权重计算" class="headerlink" title="选择器权重计算"></a>选择器权重计算</h2><h3 id="权重计算规则"><a href="#权重计算规则" class="headerlink" title="权重计算规则"></a>权重计算规则</h3><ol>
<li>内联样式，如: style=”…”，权值为1000。</li>
<li>ID选择器，如：#content，权值为0100。</li>
<li>类，伪类、属性选择器，如.content，权值为0010。</li>
<li>类型选择器、伪元素选择器，如div p，权值为0001。</li>
<li>通配符、子选择器、相邻选择器等。如* &gt; +，权值为0000。</li>
<li>继承的样式没有权值</li>
</ol>
<h3 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h3><p>1,0,0,0 &gt; 0,99,99,99。也就是说从左往右逐个等级比较，前一等级相等才往后比。</p>
<p>无论是行间、内部和外部样式，都是按照这个规则来进行比较。而不是直观的行间&gt;内部&gt;外部样式；ID&gt;class&gt;元素。之所以有这样的错觉，是因为确实行间为第一等的权重，所以它的权重是最高的。而内部样式可能一般写在了外部样式引用了之后，所以覆盖掉了之前的。</p>
<p>在权重相同的情况下，后面的样式会覆盖掉前面的样式。</p>
<p>通配符、子选择器、相邻选择器等的。虽然权值为0000，但是也比继承的样式优先，0 权值比无权值优先。</p>
<h3 id="important"><a href="#important" class="headerlink" title="!important"></a><code>!important</code></h3><p><code>!important</code> 的作用是提升优先级，换句话说。加了这句的样式的优先级是最高的（比内联样式的优先级还高)。</p>
<p><strong>在使用 !important 时需要注意：</strong></p>
<ol>
<li>Never 永远不要在全站范围的 css 上使用 !important</li>
<li>Only 只在需要覆盖全站或外部 css（例如引用的 ExtJs 或者YUI ）的特定页面中使用 !important</li>
<li>Never 永远不要在你的插件中使用 !important</li>
<li>Always 要优化考虑使用样式规则的优先级来解决问题而不是 !important</li>
</ol>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS响应式设计</title>
    <url>/2020/09/17/css-responsive-design/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>CSS响应式设计有关内容</p>
<p>– 媒体查询</p>
<p>– rem/em</p>
</blockquote>
<a id="more"></a>

<h2 id="一、媒体查询-Media-Queryies"><a href="#一、媒体查询-Media-Queryies" class="headerlink" title="一、媒体查询 Media Queryies"></a>一、媒体查询 <code>Media Queryies</code></h2><p><strong>Media Queries</strong>直译过来就是“<code>媒体查询</code>”，在我们平时的Web页面中<code>head</code>部分常看到这样的一段代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/reset.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/style.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;all&quot;</span> /&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;css/print.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;print&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>而这个“media”就是用来指定特定的媒体类型，在HTML4和CSS2中允许你使用“<a href="https://link.jianshu.com/?t=http://www.w3.org/TR/CSS2/media.html">media</a>”来指定特定的媒体类型，如屏幕（screen）和打印（print）的样式表，当然还有其他的，比如说“TV”,“handheld”等，其中“all”表示的是支持所有媒体介质。有关于更多的Media类型，可以点击<a href="http://www.w3.org/TR/CSS2/media.html">这里</a>。</p>
<p><strong>举个例子</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (max-width: 600px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;small.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的media语句表示的是：当页面宽度小于或等于600px,调用small.css样式表来渲染你的Web页面。</p>
</blockquote>
<ol>
<li><strong>screen</strong>：这个不用说大家都知道，指的是一种媒体类型；</li>
<li><strong>and</strong>：被称为关键词，与其相似的还有not,only，稍后会介绍；</li>
<li><strong>（max-width:600px）</strong>：这个就是媒体特性，说得通俗一点就是媒体条件。</li>
</ol>
<p><strong>上述的代码换成css的写法如下:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@media</span> <span class="function">screen <span class="title">and</span> <span class="params">(max-width: <span class="number">600</span>px)</span> </span>&#123; 选择器 &#123; 属性：属性值； &#125; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>常用的Media Query</strong>如下表所示：</p>
<blockquote>
<p>color<br>color-index<br>aspect-ratio<br>device-aspect-ratio<br>device-height<br>device-width<br>grid<br>height<br>monochrome<br>orientation : landscape | portrait<br>resolution<br>scan<br>width</p>
</blockquote>
<p><img data-src="media_query-1.png"></p>
<h3 id="Media-Queries的具体使用方式"><a href="#Media-Queries的具体使用方式" class="headerlink" title="Media Queries的具体使用方式"></a>Media Queries的具体使用方式</h3><h4 id="1-最大宽度Max-Width"><a href="#1-最大宽度Max-Width" class="headerlink" title="1. 最大宽度Max Width"></a>1. 最大宽度Max Width</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> </span><br><span class="line">media=<span class="string">&quot;screen and (max-width:600px)&quot;</span> </span><br><span class="line">href=<span class="string">&quot;small.css&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;text/css&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>上面表示的是：当屏幕小于或等于<code>600px</code>时，将采用<code>small.css</code>样式来渲染Web页面。</p>
<h4 id="2-最小宽度Min-Width"><a href="#2-最小宽度Min-Width" class="headerlink" title="2. 最小宽度Min Width"></a>2. 最小宽度Min Width</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> </span><br><span class="line">media=<span class="string">&quot;screen and (min-width:600px)&quot;</span> </span><br><span class="line">href=<span class="string">&quot;large.css&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;text/css&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>上面表示的是：当屏幕大于或等于600px时，将采用large.css样式来渲染Web页面。</p>
<h4 id="3-多个Media-Queries使用"><a href="#3-多个Media-Queries使用" class="headerlink" title="3. 多个Media Queries使用"></a>3. 多个Media Queries使用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> </span><br><span class="line">media=<span class="string">&quot;screen and (min-width:600px) and (max-width:900px)&quot;</span> </span><br><span class="line">href=<span class="string">&quot;style.css&quot;</span> <span class="built_in">type</span>=<span class="string">&quot;text/css&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>上面的表示的是当屏幕在600px-900px之间时采用style.css样式来渲染web页面。</p>
<h4 id="4-两种加载方式"><a href="#4-两种加载方式" class="headerlink" title="4. 两种加载方式"></a>4. 两种加载方式</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS media query on a link element --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(max-width: 800px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;example.css&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- CSS media query within a stylesheet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="keyword">@media</span> (<span class="attribute">max-width:</span> <span class="number">600px</span>) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.facet_sidebar</span> &#123;</span></span><br><span class="line">    display: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：所有的media query css都会加载，只有符合条的会被解析</strong></p>
<h4 id="5-标准语法"><a href="#5-标准语法" class="headerlink" title="5. 标准语法"></a>5. 标准语法</h4><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="symbol">media_query_list:</span> &lt;media_query&gt; [, &lt;media_query&gt; ]*</span><br><span class="line"><span class="symbol">media_query:</span> [[only <span class="params">| <span class="keyword">not</span>]? &lt;media_type&gt; [ <span class="keyword">and</span> &lt;expression&gt; ]*]</span></span><br><span class="line"><span class="params">  |</span> &lt;expression&gt; [ <span class="keyword">and</span> &lt;expression&gt; ]*</span><br><span class="line"><span class="symbol">expression:</span> ( &lt;media_feature&gt; [: &lt;value&gt;]? )</span><br><span class="line"><span class="symbol">media_type:</span> all <span class="params">| aural |</span> braille <span class="params">| handheld |</span> print <span class="params">|</span></span><br><span class="line"><span class="params">  projection |</span> screen <span class="params">| tty |</span> tv <span class="params">| embossed</span></span><br><span class="line"><span class="params">media_feature: width |</span> min-width <span class="params">| max-width</span></span><br><span class="line"><span class="params">  |</span> height <span class="params">| min-height |</span> max-height</span><br><span class="line">  <span class="params">| device-width |</span> min-device-width <span class="params">| max-device-width</span></span><br><span class="line"><span class="params">  |</span> device-height <span class="params">| min-device-height |</span> max-device-height</span><br><span class="line">  <span class="params">| aspect-ratio |</span> min-aspect-ratio <span class="params">| max-aspect-ratio</span></span><br><span class="line"><span class="params">  |</span> device-aspect-ratio <span class="params">| min-device-aspect-ratio |</span> max-device-aspect-ratio</span><br><span class="line">  <span class="params">| color |</span> min-color <span class="params">| max-color</span></span><br><span class="line"><span class="params">  |</span> color-index <span class="params">| min-color-index |</span> max-color-index</span><br><span class="line">  <span class="params">| monochrome |</span> min-monochrome <span class="params">| max-monochrome</span></span><br><span class="line"><span class="params">  |</span> resolution <span class="params">| min-resolution |</span> max-resolution</span><br><span class="line">  <span class="params">| scan |</span> grid</span><br></pre></td></tr></table></figure>

<h4 id="6-逻辑操作符"><a href="#6-逻辑操作符" class="headerlink" title="6. 逻辑操作符"></a>6. 逻辑操作符</h4><ul>
<li>and 同编程语言里的and</li>
<li>not 同编程语言里的not</li>
</ul>
<p><strong>逗号</strong> ：    当逗号两边的条件有一个为真都为真， 同编程语言里的or</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="1-提供一组目前的适配移动端屏幕的Media-Queries"><a href="#1-提供一组目前的适配移动端屏幕的Media-Queries" class="headerlink" title="1. 提供一组目前的适配移动端屏幕的Media Queries"></a>1. 提供一组目前的适配移动端屏幕的Media Queries</h4><blockquote>
<p>根据不同的手机屏幕,设置基于html元素的字体大小,利用rem的方式实现移动端屏幕的适配</p>
<p>(注:这套适配方案是按照640的屏幕,获得的实际大小除以40,如获得的字体大小为40px,那么转换为rem就是1rem)</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">321px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">321px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">360px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">22.5px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">361px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">375px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">23.4px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">376px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">414px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">25.8px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">415px</span>) <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">479px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">27px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">480px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> <span class="keyword">only</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">32px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、响应式设计中的-em-rem"><a href="#二、响应式设计中的-em-rem" class="headerlink" title="二、响应式设计中的 em/rem"></a>二、响应式设计中的 <code>em/rem</code></h2><p><code>rem</code>是指：<strong>根元素</strong>（root element，html）的字体大小，</p>
<p><code>em</code>是指：<strong>父元素</strong>的字体大小。</p>
<blockquote>
<p><strong>注:</strong>    可以引入 CSS 预处理工具（Sass、LESS 、Stylus等）自动计算 rem 值。</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM&amp;BOM</title>
    <url>/2020/10/21/DOM&amp;BOM/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>–  DOM操作</p>
<p>–  BOM及BOM操作</p>
</blockquote>
<a id="more"></a>

<h2 id="一、JS中的DOM操作"><a href="#一、JS中的DOM操作" class="headerlink" title="一、JS中的DOM操作"></a>一、JS中的DOM操作</h2><blockquote>
<p>DOM（Document Object Model） 是 W3C（World Wide Web Consortium）标准。同时也 定义了访问诸如 XML 和 HTML 文档的标准：</p>
<p>DOM是一个使程序和脚本有能力动态地访问和更新文档的内容、结构以及样式的平台和语言中立的接口。</p>
<p>在HTML和JavaScript的学习中，DOM操作可谓时重中之重</p>
<p>原文传送门—<a href="https://www.cnblogs.com/zxt-17862802783/p/7498790.html">js的DOM操作</a></p>
</blockquote>
<h3 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h3><p>DOM节点分为三大类：<strong>元素节点、属性节点、文本节点</strong></p>
<p><img data-src="dom-1.png"></p>
<p>DOM树我们可以看到，<span style="color:red;">文本节点、属性节点属于元素节点的子节点</span>。</p>
<p>文本节点和属性节点就像是这颗DOM树的果子，而元素节点就是树枝，所以，在操作时，一定要要记顺枝摘果：得先取到元素节点！然后再操作子节点！！</p>
<p><span style="color:red;"> 要先取到元素节点！要先取到元素节点！要先取到元素节点！重要的事情说三遍！</span></p>
<p><strong>这里讲一下<code>nodeType</code>：</strong>（记住：元素就是标签）</p>
<ul>
<li><code>nodeType == 1</code> 表示的是元素节点（标签）</li>
<li><code>nodeType == 2</code> 表示是属性节点</li>
<li><code>nodeType == 3</code> 是文本节点</li>
</ul>
<h4 id="1、先找树枝——获取元素节点"><a href="#1、先找树枝——获取元素节点" class="headerlink" title="1、先找树枝——获取元素节点"></a>1、先找树枝——获取元素节点</h4><p>首先，可以用使用getElement系列方法，取到元素节点。</p>
<p><strong>下面列出一些常用的 DOM 对象方法:</strong></p>
<p><img data-src="dom-2.png"></p>
<p>使用实例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.div</span>&#123;</span></span><br><span class="line">                width: 100px;</span><br><span class="line">                height: 100px;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn1&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(btn1);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> is = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">                btn1.onclick =<span class="function"><span class="keyword">function</span>  (<span class="params"></span>)</span>&#123;</span></span><br><span class="line">                    </span><br><span class="line">                    is++;</span><br><span class="line">                    if(is%2!=0)&#123;</span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="javascript">                        div[<span class="number">0</span>].style = <span class="string">&quot;background-color:red;color:yellow;&quot;</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//                        div[0].innerText = &quot;hehe&quot;;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        div[0].innerHTML = &quot;<span class="tag">&lt;<span class="name">h2</span>&gt;</span>hehe<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>&quot;;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">                    &#125;<span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="javascript">                        div[<span class="number">0</span>].style = <span class="string">&quot;background-color:blue;color:white;&quot;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                        div[0].innerHTML = &quot;<span class="tag">&lt;<span class="name">h2</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>&quot;;</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span> = <span class="string">&quot;btn1&quot;</span> <span class="attr">class</span> = <span class="string">&quot;btn&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;but()&quot;</span>&gt;</span>这是一个按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div&quot;</span>&gt;</span>hahaha<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="dom-3.png"></p>
<p>**getElementById:**通过id取到唯一节点。如果id重名，只能取到第一个。</p>
<p><strong>getElementsByName()</strong> ：通过name属性</p>
<p><strong>getElementsByTagName()</strong> ：通过标签名；</p>
<p><strong>getElementsByClassName()</strong> ：通过class名；</p>
<p><span style="color:#0e918c;font-weight:bold;">注意：</span></p>
<ul>
<li>获取元素节点时，一定要注意：<strong>获取节点的语句，必须在DOM渲染完成后执行</strong>。<br>可以有两种方式实现：①将JS代码写在body之后；②将代码写到window.onload函数之中；</li>
<li>后面三个getElements，取到的是<strong>数组格式</strong>。不能直接添加各种属性，而应该取出数组的每一个单独操作。</li>
</ul>
<h4 id="2、找到树枝摘果子——查看设置属性节点"><a href="#2、找到树枝摘果子——查看设置属性节点" class="headerlink" title="2、找到树枝摘果子——查看设置属性节点"></a>2、找到树枝摘果子——查看设置属性节点</h4><p><strong>查看和设置属性节点，必须先取到元素节点，才能使用</strong></p>
<p>   1、查看属性节点：<code>getAttribute</code>(“属性名”)；<br>   2、设置属性节点：<code>setAttribute</code>(“属性名”,”新属性值”);</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn1 = <span class="built_in">document</span>.getElementById(<span class="string">&quot;btn1&quot;</span>);            </span><br><span class="line"><span class="keyword">var</span> classes = btn1.getAttribute(<span class="string">&quot;class“）；</span></span><br><span class="line">btn1.setAttribute(&quot;class&quot;,&quot;btn1&quot;);</span><br><span class="line"><span class="built_in">console</span>.log(classes);</span><br></pre></td></tr></table></figure>

<p><span style="color:#0e918c;font-weight:bold;">注意：</span></p>
<p>1、使用<code>setAttribute()</code>设置<code>class</code>和<code>style</code>属性，但是存在兼容性问题，不提倡</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.setAttribute(<span class="string">&quot;class&quot;</span>,<span class="string">&quot;cls1&quot;</span>); <span class="comment">// IE可能不兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IE可兼容</span></span><br><span class="line">div.style.color=<span class="string">&quot;&quot;</span></span><br><span class="line">div.onclick=<span class="string">&quot;&quot;</span></span><br><span class="line">div.src=<span class="string">&quot;&quot;</span></span><br><span class="line">div.className=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>2、使用<code>.className</code>直接设置<code>class</code>类，注意是<code>className</code>而不是<code>.class</code>。见上：</p>
<p>3、使用.style设置单个属性，注意属性名要用驼峰命名法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.style.backgroundColor = <span class="string">&quot;red&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>4、使用.style或.style.cssText设置多个样式属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.style = <span class="string">&quot;background-color:red;    color:yellow;&quot;</span></span><br><span class="line">div.style = <span class="string">&quot;background-color:red;    color:yellow&quot;</span> √</span><br></pre></td></tr></table></figure>

<h4 id="3、查看设置文本节点"><a href="#3、查看设置文本节点" class="headerlink" title="3、查看设置文本节点"></a>3、查看设置文本节点</h4><p><code>.innerText</code>：取到或设置节点里面的文字内容;</p>
<p><code>.innerHTML</code>：取到或设置节点里面的HTML代码；</p>
<p><code>.tagName</code>：取到当前结点的标签名。标签名全部大写  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">div[<span class="number">0</span>].style = <span class="string">&quot;background-color:red;color:yellow;&quot;</span></span><br><span class="line"><span class="comment">//  div[0].innerText = &quot;hehe&quot;;</span></span><br><span class="line">div[<span class="number">0</span>].innerHTML = <span class="string">&quot;&lt;h2&gt;hehe&lt;/h2&gt;&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="根据层次查看节点"><a href="#根据层次查看节点" class="headerlink" title="根据层次查看节点"></a>根据层次查看节点</h3><p><img data-src="dom-4.png"></p>
<h4 id="1、根据层次查看节点"><a href="#1、根据层次查看节点" class="headerlink" title="1、根据层次查看节点"></a>1、根据层次查看节点</h4><p><code>.childNodes</code>：获取元素的所有子节点，包括回车和文本节点；</p>
<p><code>.children</code>：获取当前元素的所有元素节点（只获取标签）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4444<span class="tag">&lt;/<span class="name">li</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>  (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">&quot;ul&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> li = ul.childNodes;</span><br><span class="line">    <span class="keyword">var</span> lis = ul.children;</span><br><span class="line">    <span class="built_in">console</span>.log(li);</span><br><span class="line">    <span class="comment">// 输出结果：(9)[text,li,test,li,text,li,text,li,text]</span></span><br><span class="line">    <span class="built_in">console</span>.log(lis)</span><br><span class="line">    <span class="comment">// 输出结果：(4)[li,li,li,li]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于为什么<code>.childNodes</code>获取的是9个子节点？</p>
<p><span style="color:red;">待解决</span></p>
<p><code>.firstChild</code>：获取元素的第一个子节点。包括回车等文本节点</p>
<p><code>.firstElementChild</code>：获取元素的第一个子元素节点，不包括回车等文本节点</p>
<br>

<p><code>.lastchild</code>：获取元素的最后一个子节点，包括回车等文本节点</p>
<p><code>.lastElementChild</code>：获取元素的最后一个子节点，不包括回车等文本节点</p>
<br>

<p><code>.parentNode</code>：获取当前节点的父节点</p>
<br>

<p><code>.previousSibling</code>：获取当前节点的前一个兄弟节点，包括回车等文本节点</p>
<p><code>.previousElementSibling</code>：获取当前节点的前一个兄弟元素节点，不包括回车等文本节点。</p>
<br>

<p><code>.nextSibling</code>：获取当前节点的后一个兄弟节点；包括回车等文本节点</p>
<p><code>.nextElementSibling</code>：获取当前节点的后一个兄弟元素节点，不包括回车等文本节点</p>
<br>

<p><code>.getAttribute</code>：获得当前属性的元素节点</p>
<h4 id="2、修改节点"><a href="#2、修改节点" class="headerlink" title="2、修改节点"></a>2、修改节点</h4><p> 创建并新增节点</p>
<p>1、<code>document.creatElement</code>(“标签名”)：创建节点。需要配合setAttribute设置各种新的属性</p>
<p>2、<code>父节点.appendChild(新节点)</code>：末尾追加方式插入节点</p>
<p>3、<code>父节点.insertBefore(新节点，目标节点)</code>：在目标节点前插入新节点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;addImg()&quot;</span>&gt;</span>点击添加图片<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">addImg</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="javascript">       img.setAttribute(<span class="string">&quot;src&quot;</span>,<span class="string">&quot;../../img/557833.jpg&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// document.body.appendChild(img);</span></span></span><br><span class="line"><span class="javascript">       img.style.height = <span class="string">&quot;100px&quot;</span>;</span></span><br><span class="line"><span class="javascript">       img.style.width = <span class="string">&quot;100px&quot;</span>;</span></span><br><span class="line">                </span><br><span class="line"><span class="javascript">       <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">&quot;ul&quot;</span>);</span></span><br><span class="line"><span class="javascript">       <span class="built_in">document</span>.body.insertBefore(img,ul);</span></span><br><span class="line">     &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  4、<code>cloneNode(true/false)</code>：克隆节点</p>
<ul>
<li>传参true：表示克隆当前节点，以及当前节点的子节点；</li>
<li>传参false：表示只克隆当前节点，不克隆当前节点的子节点；</li>
</ul>
<h4 id="3、删除节点"><a href="#3、删除节点" class="headerlink" title="3、删除节点"></a>3、删除节点</h4><p>格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父节点.removeChild(子节点);</span><br></pre></td></tr></table></figure>

<p>解释：<strong>用父节点删除子节点</strong>。必须要指定是删除哪个子节点。</p>
<p>如果我想删除自己这个节点，可以这么做：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node1.parentNode.removeChild(node1);</span><br></pre></td></tr></table></figure>

<h4 id="4、删除节点的属性"><a href="#4、删除节点的属性" class="headerlink" title="4、删除节点的属性"></a>4、删除节点的属性</h4><p>格式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">元素节点.removeAttribute(属性名);</span><br></pre></td></tr></table></figure>

<p>举例：（删除节点的属性）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myNode.removeAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">myNode.removeAttribute(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="表格元素"><a href="#表格元素" class="headerlink" title="表格元素"></a>表格元素</h3><p>【表格对象】</p>
<p>  1、<code>rows属性</code>：返回表格中的所有行，是一个数组格式；</p>
<p>  2、<code>insertRow(index)</code>：在指定位置插入一行，index从0开始；</p>
<p>  3、<code>deleteRow(index)</code>：删除指定的一行，index从0开始；</p>
<p>【行对象】</p>
<p>  1、<code>cells属性</code>：返回这一行中的所有单元格，是一个数组格式；</p>
<p>  2、<code>rowIndex属性</code>：返回这一行，是表格中的第几行，从0开始；</p>
<p>  3、<code>insertCell(index)</code>：在这一行的指定位置，插入一个单元格，index从领开始；</p>
<p>  4、<code>deleteCell(index)</code>：删除这一行的指定单元格，index从0开始</p>
<p>【单元格对象】</p>
<p>  1、<code>cellIndex属性</code>：返回这个单元格是这一行的第几个单元格</p>
<p>  2、<code>innerText</code>  <code>inner HTML</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">            table&#123;</span><br><span class="line">                width: 400px;</span><br><span class="line">                border-collapse: collapse;</span><br><span class="line">            &#125;</span><br><span class="line">            td,th&#123;</span><br><span class="line">                border: solid 1px black;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-tag">tr</span><span class="selector-pseudo">:last-of-type</span>&#123;</span></span><br><span class="line">                color: red;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-tag">tr</span><span class="selector-pseudo">:frst-of-type</span>&#123;</span></span><br><span class="line"><span class="css">                <span class="selector-tag">background-color</span>: <span class="selector-id">#565656</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">&quot;table&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>书名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>价格<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>幸福从天而降<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>18.5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>活在当下<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>45.5元<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>人性的弱点<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>65.5元<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>60个瞬间<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>88.0元<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>合计<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>100元<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;addRow()&quot;</span>&gt;</span>增加一行<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;delRow()&quot;</span>&gt;</span>删除最后一行<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;copyRow()&quot;</span>&gt;</span>复制最后一行<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;changeStyle()&quot;</span>&gt;</span>修改标题样式<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;getSum()&quot;</span>&gt;</span>求和<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> table = <span class="built_in">document</span>.getElementById(<span class="string">&quot;table&quot;</span>);</span></span><br><span class="line">            </span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">addRow</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> index = table.rows.length<span class="number">-1</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> newRow = table.insertRow(index);</span></span><br><span class="line">                </span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> name = prompt(<span class="string">&quot;请输入书名&quot;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> cell0 = newRow.insertCell(<span class="number">0</span>);</span></span><br><span class="line">                cell0.innerText = name;</span><br><span class="line">                </span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> money = <span class="built_in">parseFloat</span>(prompt(<span class="string">&quot;价格&quot;</span>));</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> cell1 = newRow.insertCell(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">                cell1.innerText = money.toFixed(<span class="number">1</span>)+<span class="string">&quot;元&quot;</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">delRow</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">                if (table.rows.length&gt;2) &#123;</span><br><span class="line">                    table.deleteRow(table.rows.length-2);</span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;没有了&quot;</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">copyRow</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> cloneRow = table.rows[table.rows.length<span class="number">-2</span>];</span></span><br><span class="line">                </span><br><span class="line">                if (table.rows.length&gt;2) &#123;</span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> newRow = table.insertRow(table.rows.length<span class="number">-1</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> cell0 = newRow.insertCell(<span class="number">0</span>);</span></span><br><span class="line">                    cell0.innerText = cloneRow.cells[0].innerText;</span><br><span class="line">                    </span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> cell1 = newRow.insertCell(<span class="number">1</span>);</span></span><br><span class="line">                    cell1.innerText = cloneRow.cells[1].innerText;</span><br><span class="line">                    </span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;没有可复制的行了！！&quot;</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">changeStyle</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> color = prompt(<span class="string">&quot;请输入十六进制颜色值&quot;</span>);</span></span><br><span class="line"><span class="javascript">                table.rows[<span class="number">0</span>].style = <span class="string">&quot;background-color:&quot;</span>+color;</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">getSum</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> rows = table.rows;</span></span><br><span class="line">                if (rows.length&lt;=2) &#123;</span><br><span class="line"><span class="javascript">                    alert(<span class="string">&quot;没有可以计算的和&quot;</span>);</span></span><br><span class="line"><span class="javascript">                    rows[rows.length<span class="number">-1</span>].cells[<span class="number">1</span>].innerText = <span class="string">&quot;0元&quot;</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> sum = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i&lt;rows.length<span class="number">-1</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">var</span> cells = rows[i].cells;</span></span><br><span class="line"><span class="javascript">                        sum += <span class="built_in">parseFloat</span>(cells[cells.length<span class="number">-1</span>].innerText);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line"><span class="javascript">                    rows[rows.length<span class="number">-1</span>].cells[<span class="number">1</span>].innerText = sum + <span class="string">&quot;元&quot;</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>  (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">                getSum();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="二、BOM及BOM操作"><a href="#二、BOM及BOM操作" class="headerlink" title="二、BOM及BOM操作"></a>二、BOM及BOM操作</h2><p>​    <a href="https://www.cnblogs.com/haojf/p/10287312.html">JS获取各种屏幕的宽度和高度</a></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">网页可见区域宽： <span class="selector-tag">document</span><span class="selector-class">.body</span><span class="selector-class">.clientWidth</span></span><br><span class="line">网页可见区域高： <span class="selector-tag">document</span><span class="selector-class">.body</span><span class="selector-class">.clientHeight</span></span><br><span class="line">网页可见区域宽： <span class="selector-tag">document</span><span class="selector-class">.body</span><span class="selector-class">.offsetWidth</span> (包括边线的宽)</span><br><span class="line">网页可见区域高： <span class="selector-tag">document</span><span class="selector-class">.body</span><span class="selector-class">.offsetHeight</span> (包括边线的高)</span><br><span class="line">网页正文全文宽： <span class="selector-tag">document</span><span class="selector-class">.body</span><span class="selector-class">.scrollWidth</span></span><br><span class="line">网页正文全文高： <span class="selector-tag">document</span><span class="selector-class">.body</span><span class="selector-class">.scrollHeight</span></span><br><span class="line">网页被卷去的高： <span class="selector-tag">document</span><span class="selector-class">.body</span><span class="selector-class">.scrollTop</span></span><br><span class="line">网页被卷去的左： <span class="selector-tag">document</span><span class="selector-class">.body</span><span class="selector-class">.scrollLeft</span></span><br><span class="line">网页正文部分上： <span class="selector-tag">window</span><span class="selector-class">.screenTop</span></span><br><span class="line">网页正文部分左： <span class="selector-tag">window</span><span class="selector-class">.screenLeft</span></span><br><span class="line">屏幕分辨率的高： <span class="selector-tag">window</span><span class="selector-class">.screen</span><span class="selector-class">.height</span></span><br><span class="line">屏幕分辨率的宽： <span class="selector-tag">window</span><span class="selector-class">.screen</span><span class="selector-class">.width</span></span><br><span class="line">屏幕可用工作区高度： <span class="selector-tag">window</span><span class="selector-class">.screen</span><span class="selector-class">.availHeight</span></span><br><span class="line">屏幕可用工作区宽度： <span class="selector-tag">window</span><span class="selector-class">.screen</span><span class="selector-class">.availWidth</span></span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6新特性及前沿二</title>
    <url>/2020/10/27/new-features-and-frontiers-of-ES6-sec/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>继上文仅仅是ES6的学习笔记，最后还是参考<a href="https://es6.ruanyifeng.com/#docs/set-map">ES6文档</a>的好</p>
<p>–  Symbol</p>
<p>–  Set 和 Map</p>
<p>–  Proxy</p>
<p>–  Reflect</p>
<p>–  Promise</p>
<p>–  Iterator 和 for…of 循环</p>
<p>–  Generator 语法和异步应用</p>
<p>–  async</p>
<p>–  class</p>
<p><strong>以上均来自于阮一峰先生的资料</strong></p>
<p>–  Web Worker</p>
</blockquote>
<a id="more"></a>

<h2 id="一、Web-Worker"><a href="#一、Web-Worker" class="headerlink" title="一、Web Worker"></a>一、Web Worker</h2><blockquote>
<p>可参考  <a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html">Web Worker 使用教程</a></p>
</blockquote>
<p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>
<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Git Problems</title>
    <url>/2020/09/08/git-problems/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTlINE"><a href="#CONTENT-OUTlINE" class="headerlink" title="CONTENT OUTlINE"></a>CONTENT OUTlINE</h2><blockquote>
<p>收集汇总自己遇到的Git问题，并附上值得推荐的<code>Git</code>教程</p>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a></p>
<p><a href="https://www.jianshu.com/p/e57a4a2cf077">Git使用教程（简书）</a></p>
<p><a href="https://learngitbranching.js.org/?locale=zh_CN">Git 互动练习教程</a></p>
<p>以及两个来自CSDN的  <a href="https://blog.csdn.net/weixin_42152081/article/details/80558282">Git教程(完整)</a> 和 <a href="https://blog.csdn.net/u011535541/article/details/83379151">Git傻瓜教程</a></p>
<p>来自<code>Gitee</code>的<a href="https://gitee.com/help/articles/4110#article-header1">官方教程</a>很厉害，哈哈哈！还有这个<a href="https://oschina.gitee.io/learn-git-branching/?utm_source==gitee-help-widget">互动练习教程</a></p>
</blockquote>
<a id="more"></a>

<h2 id="1、-使用git将本地项目上传至git仓库"><a href="#1、-使用git将本地项目上传至git仓库" class="headerlink" title="1、 使用git将本地项目上传至git仓库"></a>1、 使用git将本地项目上传至git仓库</h2><blockquote>
<p><strong>介绍</strong>:  一般来说开发过程中都是先在git创建远程仓库，然后fetch到本地仓库，再进行commit push等操作，但是有时候也需要将本地已经开发的项目上传至一个空的远程仓库中，期间也是遇到不少问题，特此总结一下</p>
</blockquote>
<h3 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h3><p>初始化仓库</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git init</span></span><br></pre></td></tr></table></figure>

<p>将文件提交至本地仓库</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">&quot;注释&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="关联线上仓库"><a href="#关联线上仓库" class="headerlink" title="关联线上仓库"></a>关联线上仓库</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;线上仓库url&gt;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 线上仓库url 为如下链接</span><br><span class="line"><span class="regexp">//</span> https:<span class="regexp">//gi</span>thub.com<span class="regexp">/wenhaofan/</span>xxx.git</span><br></pre></td></tr></table></figure>

<h3 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> git pull </span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p><strong>常见错误及解决方案</strong></p>
<p>现在已经创建好了本地仓库，并关联上了远程仓库，如果我们直接使用git push -u origin master将本地内容推送至线上那么可能会出现出现以下错误</p>
<h4 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">failed <span class="built_in">to</span> push some refs <span class="built_in">to</span> <span class="string">&#x27;https://github.com/xxx/xxx.git&#x27;</span></span><br><span class="line">hint: Updates were rejected because <span class="keyword">the</span> remote <span class="keyword">contains</span> work that you dogit</span><br><span class="line">hint: <span class="keyword">not</span> have locally. This is usually caused <span class="keyword">by</span> another repository pushing</span><br><span class="line">hint: <span class="built_in">to</span> <span class="keyword">the</span> same ref. You may want <span class="built_in">to</span> <span class="keyword">first</span> integrate <span class="keyword">the</span> remote changes</span><br><span class="line">hint: (e.g., <span class="string">&#x27;git pull ...&#x27;</span>) <span class="keyword">before</span> pushing again.</span><br><span class="line">hint: See <span class="keyword">the</span> <span class="string">&#x27;Note about fast-forwards&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;git push --help&#x27;</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>​    以上错误很明显的提示先执行 git pull 再push,需要先执行以下指令将远程仓库中master分支中的文件拉取到本地</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git pull origin <span class="literal">master</span></span><br></pre></td></tr></table></figure>

<p>​    如果没有抛异常 那么就可以愉快的再次执行 git push 了，如果抛了异常，那么可以接着往下看</p>
<h4 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"> * branch            <span class="keyword">master</span>     <span class="title">-&gt; FETCH_HEAD</span></span><br><span class="line">fatal: refusing to merge unrelated histories</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 出现这个问题是因为本地库和远程库没有进行关联远， 然后本地推送到远程库， 远端因为这个本地库跟自己没有关联， 所以告知无法合并，该情况有两种解决方法</p>
</blockquote>
<p><strong>第一种：</strong>    </p>
<p>​    先从远端库拉下来代码，然后将本地代码放入本地库中， 然后再执行push提交上去 </p>
<p><strong>第二种</strong>：</p>
<p>使用以下命令,把两段不相干的 分支进行强行合并</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git pull origin <span class="keyword">master</span> <span class="title">--allow-unrelated-histories</span></span><br></pre></td></tr></table></figure>

<p><strong>然后再进行提交</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">push</span> gitlab master:init</span><br></pre></td></tr></table></figure>

<h2 id="2-、git拉取远程分支并创建本地分支"><a href="#2-、git拉取远程分支并创建本地分支" class="headerlink" title="2.、git拉取远程分支并创建本地分支"></a>2.、git拉取远程分支并创建本地分支</h2><p><strong>查看远程分支</strong></p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git branch -r</span></span><br></pre></td></tr></table></figure>

<p><strong>拉取远程分支并创建本地分支</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b</span> 本地分支名  origin/远程分支名</span><br></pre></td></tr></table></figure>

<p>使用该方式会在本地新建分支x，并自动切换到该本地分支x。<br> 采用此种方法建立的本地分支会和远程分支建立映射关系。</p>
<p><strong>如果不想建立映射关系，可以：</strong></p>
<figure class="highlight gml"><table><tr><td class="code"><pre><span class="line">git fetch origin 远程分支名<span class="symbol">x</span>:本地分支名<span class="symbol">x</span></span><br></pre></td></tr></table></figure>

<p> 使用该方式会在本地新建分支x，但是不会自动切换到该本地分支x，需要手动checkout。</p>
<p> 使用该方式会在本地新建分支x，但是不会自动切换到该本地分支x，需要手动checkout。</p>
<p>本地分支和远程分支建立映射关系的作用见：<a href="https://blog.csdn.net/tterminator/article/details/78108550">此文章</a> </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">git checkout -b my-<span class="keyword">test</span>  //在当前分支下创建my-<span class="keyword">test</span>的本地分支分支</span><br><span class="line">git push origin my-<span class="keyword">test</span>  //将my-<span class="keyword">test</span>分支推送到远程</span><br><span class="line">git branch --<span class="keyword">set</span>-upstream-to=origin/my-<span class="keyword">test</span> //将本地分支my-<span class="keyword">test</span>关联到远程分支my-<span class="keyword">test</span>上</span><br><span class="line">git branch -a //查看远程分支</span><br></pre></td></tr></table></figure>

<h2 id="3、git基于某个分支创建分支并提交"><a href="#3、git基于某个分支创建分支并提交" class="headerlink" title="3、git基于某个分支创建分支并提交"></a>3、git基于某个分支创建分支并提交</h2><p><strong>拷贝源代码</strong></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@git地址 </span><br></pre></td></tr></table></figure>

<p><strong>根据已有分支创建新的分支</strong></p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b</span> yourbranchname origin/oldbranchname</span><br></pre></td></tr></table></figure>

<p><strong>推送到git</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin yourbranchname </span><br></pre></td></tr></table></figure>

<p><strong>合并</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge iss53</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>详见 <a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6">Git - 分支的创建与合并</a></p>
</blockquote>
<h2 id="4、git-删除分支"><a href="#4、git-删除分支" class="headerlink" title="4、git 删除分支"></a>4、git 删除分支</h2><p>在本地建立文件夹，将该分支clone下来</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">-b</span>   该分支名    地址</span><br></pre></td></tr></table></figure>

<p>查看分支，并创建分支</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">branch </span>-a   (查看远端分支)</span><br><span class="line">git checkout -<span class="keyword">b </span>别的分支</span><br></pre></td></tr></table></figure>

<p>删除本地分支，删除远程分支</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git branch -D 要删除的分支</span><br><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> --<span class="built_in">delete</span> 要删除的分支</span><br></pre></td></tr></table></figure>

<h3 id="ERROR"><a href="#ERROR" class="headerlink" title="ERROR"></a>ERROR</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">PS E:\Reference\h5-template-me&gt; git branch -D &#x27;life-and-mart&#x27;</span><br><span class="line"><span class="keyword">error: </span>Cannot delete branch &#x27;life-and-mart&#x27; checked out at &#x27;E:/Reference/h5-template-me&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决参考<a href="https://blog.csdn.net/benben_2015/article/details/79782202">这篇文章</a></p>
</blockquote>
<p><strong>错误原因</strong>：很有可能是你正处于该分支上，然后尝试删除该分支是不被允许的。和Windows系统下删除打开的文件道理一样。</p>
<p><strong>解决办法：是只要切换分支到其他任意分支上，然后进行删除即可。</strong></p>
<h2 id="5、撤销git-commit-m-39-39"><a href="#5、撤销git-commit-m-39-39" class="headerlink" title="5、撤销git commit -m &#39;&#39;"></a>5、撤销<code>git commit -m &#39;&#39;</code></h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>写完代码后，我们一般这样</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">git add . <span class="comment">//添加所有文件</span></span><br><span class="line">git commit -m <span class="string">&quot;本功能全部完成&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行完commit后，想撤回commit，怎么办？</p>
<p><strong><code>git reset --soft HEAD^</code></strong></p>
<p>这样就成功的撤销了你的commit</p>
<p><strong>注意，仅仅是撤回commit操作，您写的代码仍然保留</strong></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p><strong>如果commit注释写错了，只是想改一下注释，只需要：</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">commit</span> <span class="comment">--amend</span></span><br></pre></td></tr></table></figure>

<p>此时会进入默认<code>vim编辑器</code>，修改注释完毕后保存就好了</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p><code>HEAD^ </code>的意思是上一个版本，也可以写成<code>HEAD~1</code></p>
<p>如果你进行了2次commit，想都撤回，可以使<code>用HEAD~2</code></p>
<h3 id="git-reset参数："><a href="#git-reset参数：" class="headerlink" title="git reset参数："></a><code>git reset</code>参数：</h3><h4 id="mixed"><a href="#mixed" class="headerlink" title="--mixed"></a><code>--mixed</code></h4><p>意思是：不删除工作空间改动代码，撤销<code>commit</code>，并且撤销<code>git add .</code> 操作。效果同下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">git reset --mixed HEAD^</span><br><span class="line">git reset HEAD^ </span><br></pre></td></tr></table></figure>

<h4 id="soft"><a href="#soft" class="headerlink" title="--soft"></a><code>--soft</code></h4><p>不删除工作空间改动代码，撤销<code>commit</code>，不撤销<code>git add .</code> </p>
<h4 id="hard"><a href="#hard" class="headerlink" title="--hard"></a><code>--hard</code></h4><p>删除工作空间改动代码，撤销<code>commit</code>，撤销<code>git add .</code> </p>
<p>注意完成这个操作后，就恢复到了上一次的commit状态</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Tool &amp; Platform</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML Meta</title>
    <url>/2020/08/31/HTML-meta/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>&lt;meta&gt;</code> 标签是 HTML 语言头部的一个辅助性标签，我们可以定义页面编码语言、搜索引擎优化、自动刷新并指向新的页面、控制页面缓冲、响应式视窗等</p>
<a id="more"></a>

<blockquote>
<p> 转载自<a href="https://blog.csdn.net/zhangank/article/details/94014629">HTML meta 标签</a></p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">charset( H5 New)</td>
<td align="left">character_set</td>
<td align="left">定义文档的字符编码。</td>
</tr>
<tr>
<td align="left">content</td>
<td align="left">text</td>
<td align="left">定义与 http-equiv 或 name 属性相关的元信息。</td>
</tr>
<tr>
<td align="left">http-equiv</td>
<td align="left">content-type default-style refresh</td>
<td align="left">把 content 属性关联到 HTTP 头部。</td>
</tr>
<tr>
<td align="left">name</td>
<td align="left">application-name author description generator keywords</td>
<td align="left">把 content 属性关联到一个名称。</td>
</tr>
<tr>
<td align="left">scheme(H5 删除)</td>
<td align="left">format/URI</td>
<td align="left">HTML5不支持。 定义用于翻译 content 属性值的格式。</td>
</tr>
</tbody></table>
<p>整体来看，HTML5之前，<code>meta</code>标签只有两个主要属性，分别是 <code>name</code> 属性和 <code>http-equiv</code> 属性。 HTML5新添加”<code>charset</code>“.</p>
<h2 id="一、name"><a href="#一、name" class="headerlink" title="一、name"></a>一、name</h2><p><code>name</code>属性主要用于描述网页，对应属性是 <code>content</code> ，<strong>以便于搜索引擎机器人查找、分类</strong>（目前几乎所有的搜索引擎都使用网上机器人自动查找meta值来给网页分类）。</p>
<p><strong>语法</strong>：<code>&lt;meta name=&quot;参数&quot; content=&quot;参数值&quot; /&gt;</code></p>
<h3 id="1-Keywords（关键字）"><a href="#1-Keywords（关键字）" class="headerlink" title="1. Keywords（关键字）"></a>1. Keywords（关键字）</h3><p><strong>说明</strong>：为搜索引擎提供的关键字列表</p>
<p><strong>语法</strong>：<code>&lt;meta name=&quot;keywords&quot; content=&quot;程序员,程序猿,攻城狮&quot;/&gt;</code></p>
<h3 id="2-Description（简介）"><a href="#2-Description（简介）" class="headerlink" title="2. Description（简介）"></a>2. Description（简介）</h3><p><strong>说明</strong>：Description用来告诉搜索引擎你的网站主要内容。</p>
<p><strong>语法</strong>：<code>&lt;meta name=&quot;description&quot; content=&quot;meta标签是HTML中的一个重要标签，它位于HTML文档头部的&lt;HEAD&gt;标签和&lt;TITL&gt;标签之间。&quot;/&gt;</code></p>
<h3 id="3-robots（机器人向导）"><a href="#3-robots（机器人向导）" class="headerlink" title="3. robots（机器人向导）"></a>3. robots（机器人向导）</h3><p><strong>说明</strong>：robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。</p>
<p><strong>语法</strong>：<code>&lt;meta name=&quot;robots&quot; content=&quot;&quot;/&gt;</code></p>
<p><code>content</code>的参数值有<code>all</code>,<code>none</code>,<code>index</code>,<code>noindex</code>,<code>follow</code>,<code>nofollow</code>，默认值是<u>all</u>。</p>
<p><strong>参数说明</strong>：</p>
<ul>
<li>参数为 all ：文件将被检索，且页面上的链接可以被查询； </li>
<li>参数为 none ：文件将不被检索，且页面上的链接不可以被查询； </li>
<li>参数为 index ：文件将被检索；</li>
<li>参数为 follow ：页面上的链接可以被查询； </li>
<li>参数为 noindex ：文件将不被检索，但页面上的链接可以被查询； </li>
<li>参数为 nofollow ：文件将被检索，但页面上的链接不可以被查询；</li>
</ul>
<h3 id="4-author（作者）"><a href="#4-author（作者）" class="headerlink" title="4. author（作者）"></a>4. author（作者）</h3><p><strong>说明</strong>：标注网页的作者</p>
<p><strong>语法</strong>：<code>&lt;meta name=&quot;author&quot; content=&quot;TG,TG@qq.com&quot;/&gt;</code></p>
<h3 id="5-copyright（版权）"><a href="#5-copyright（版权）" class="headerlink" title="5. copyright（版权）"></a>5. copyright（版权）</h3><p><strong>说明</strong>：标注版权</p>
<p><strong>语法</strong>：<code>&lt;meta name=&quot;copyright&quot; content=&quot;本网站版权归TG所有&quot;/&gt;</code></p>
<h3 id="6-generator"><a href="#6-generator" class="headerlink" title="6. generator"></a>6. generator</h3><p><strong>说明</strong>：说明网站采用什么编辑器制作。</p>
<p><strong>语法</strong>：<code>&lt;meta name=&quot;generator&quot; content=&quot;你所用的编辑器&quot;/&gt;</code></p>
<h3 id="7-revisit-after（重访）"><a href="#7-revisit-after（重访）" class="headerlink" title="7. revisit-after（重访）"></a>7. revisit-after（重访）</h3><p><strong>说明</strong>：网站重访</p>
<p><strong>语法</strong>：<code>&lt;meta name=&quot;revisit-after&quot; content=&quot;7days&quot;/&gt;</code></p>
<h2 id="二、http-equiv"><a href="#二、http-equiv" class="headerlink" title="二、http-equiv"></a>二、http-equiv</h2><p><code>http-equiv</code>类似于HTTP的头部协议，它回应给浏览器一些有用的信息，以帮助正确和精确地显示网页内容。与之对应的属性值为<code>content</code>，content中的内容其实就是各个参数的变量值。</p>
<p><strong>语法</strong>：<code>&lt;meta http-equiv=&quot;参数&quot;  content=&quot;参数值&quot;/&gt;</code></p>
<p><strong>参数说明</strong>如下</p>
<h3 id="1-Expires（期限）"><a href="#1-Expires（期限）" class="headerlink" title="1. Expires（期限）"></a>1. Expires（期限）</h3><p><strong>说明</strong>：指定网页在缓存中的过期时间，一旦网页过期，必须到服务器上重新传输。</p>
<p><strong>语法</strong>：<code>&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 26 Feb 1997 08:21:57 GMT&quot;/&gt;</code></p>
<p><strong>注意</strong>：必须使用GMT的时间格式，或者直接设为0（数字表示多久后过期）</p>
<h3 id="2-Pragma（cache模式）"><a href="#2-Pragma（cache模式）" class="headerlink" title="2. Pragma（cache模式）"></a>2. Pragma（cache模式）</h3><p><strong>说明</strong>：禁止浏览器从本地计算机的缓存中访问页面内容。</p>
<p><strong>语法</strong>：<code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;/&gt;</code></p>
<p><strong>注意</strong>：网页不保存在缓存中，每次访问都刷新页面。这样设定，访问者将无法脱机浏览。</p>
<h3 id="3-Refresh（刷新）"><a href="#3-Refresh（刷新）" class="headerlink" title="3. Refresh（刷新）"></a>3. Refresh（刷新）</h3><p><strong>说明</strong>：自动刷新并指向新页面。</p>
<p><strong>语法</strong>：<code>&lt;meta http-equiv=&quot;refresh&quot;content=&quot;5; url=http://www.baidu.com/&quot;/&gt;</code></p>
<p>其中的5表示5秒后自动刷新并调整到URL新页面。</p>
<h3 id="4-Set-Cookie（cookie设定）"><a href="#4-Set-Cookie（cookie设定）" class="headerlink" title="4. Set-Cookie（cookie设定）"></a>4. Set-Cookie（cookie设定）</h3><p><strong>说明</strong>：浏览器访问某个页面时会将它存在缓存中，下次再次访问时就可从缓存中读取，以提高速度。当你希望访问者每次都刷新你广告的图标，或每次都刷新你的计数器，就要禁用缓存了。</p>
<p>如果网页过期，那么存盘的cookie将被删除。</p>
<p><strong>语法</strong>：</p>
<p><code>&lt;meta http-equiv=&quot;Set-Cookie&quot;  content=&quot;cookievalue=xxx; expires=Wednesday,21-Oct-98 16:14:21 GMT; path=/&quot;&gt;</code></p>
<p><strong>注意</strong>：必须使用GMT的时间格式</p>
<h3 id="5-Window-target（显示窗口的设定）"><a href="#5-Window-target（显示窗口的设定）" class="headerlink" title="5. Window-target（显示窗口的设定）"></a>5. Window-target（显示窗口的设定）</h3><p><strong>说明</strong>：强制页面在当前窗口以独立页面显示</p>
<p><strong>语法</strong>：<code>&lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_top&quot;/&gt;</code></p>
<p>可以用来防止别人在框架里调用你的页面。</p>
<h3 id="6-content-Type（显示字符集的设定）"><a href="#6-content-Type（显示字符集的设定）" class="headerlink" title="6.  content-Type（显示字符集的设定）"></a>6.  content-Type（显示字符集的设定）</h3><p><strong>说明</strong>：设定页面使用的字符集</p>
<p><code>&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt;</code></p>
<p><strong>其他参数值</strong>：</p>
<ul>
<li>meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文；</li>
<li>meta标签的charset的信息参数如BIG5时，代表说明网站是采用的编码是繁体中文； </li>
<li>meta标签的charset的信息参数如iso-2022-jp时，代表说明网站是采用的编码是日文；  </li>
<li>meta标签的charset的信息参数如ks_c_5601时，代表说明网站是采用的编码是韩文；  </li>
<li>meta标签的charset的信息参数如ISO-8859-1时，代表说明网站是采用的编码是英文；  </li>
<li>meta标签的charset的信息参数如UTF-8时，代表世界通用的语言编码；</li>
</ul>
<blockquote>
<p>在HTML5中，我们一般都是：<code>&lt;meta charset=&quot;utf-8&quot;/&gt;</code></p>
</blockquote>
<h3 id="7-content-Language（显示语言的设定）"><a href="#7-content-Language（显示语言的设定）" class="headerlink" title="7. content-Language（显示语言的设定）"></a>7. content-Language（显示语言的设定）</h3><p><strong>说明</strong>：显示语言</p>
<p><strong>语法</strong>：<code>&lt;meta http-equiv=&quot;Content-Language&quot; content=&quot;zh-cn&quot;/&gt;</code></p>
<h3 id="8-http-equiv-”imagetoolbar”"><a href="#8-http-equiv-”imagetoolbar”" class="headerlink" title="8. http-equiv=”imagetoolbar”"></a>8. http-equiv=”imagetoolbar”</h3><p><code>&lt;meta http-equiv=&quot;imagetoolbar&quot; content=&quot;false&quot;/&gt;</code></p>
<p>指定是否显示图片工具栏，当<code>为false</code>代表不显示，当为<code>true</code>代表显示。</p>
<h2 id="三、HTML-5新增"><a href="#三、HTML-5新增" class="headerlink" title="三、HTML 5新增"></a>三、HTML 5新增</h2><h3 id="1-name"><a href="#1-name" class="headerlink" title="1. name"></a>1. name</h3><h4 id="1-1-viewport"><a href="#1-1-viewport" class="headerlink" title="1.1 viewport"></a>1.1 viewport</h4><p><strong>说明</strong>：能优化移动浏览器的显示（屏幕的缩放）</p>
<p><strong>语法</strong>：</p>
<p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no&quot;/&gt;</code></p>
<p><strong>参数值</strong>：</p>
<p><code>width</code> viewport的宽度[device-width | pixel_value]width如果直接设置pixel_value数值，大部分的安卓手机不支持，但是ios支持；  </p>
<p><code>height</code> – viewport 的高度 （范围从 223 到 10,000 ）  </p>
<p><code>user-scalable</code> [yes | no]是否允许缩放  </p>
<p><code>initial-scale</code> [数值] 初始化比例（范围从 &gt; 0 到 10）  </p>
<p><code>minimum-scale</code> [数值] 允许缩放的最小比例  </p>
<p><code>maximum-scale</code> [数值] 允许缩放的最大比例  </p>
<h4 id="1-2-format-detection（忽略电话号码和邮箱）"><a href="#1-2-format-detection（忽略电话号码和邮箱）" class="headerlink" title="1.2 format-detection（忽略电话号码和邮箱）"></a>1.2 format-detection（忽略电话号码和邮箱）</h4><p><strong>说明</strong>：忽略电话号码和邮箱</p>
<p><strong>语法</strong>：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>忽略页面中的数字识别为电话号码</span><br><span class="line">&lt;meta name=<span class="string">&quot;format-detection&quot;</span>content=<span class="string">&quot;telephone=no&quot;</span>&gt;</span><br><span class="line"><span class="regexp">//</span>忽略页面中的邮箱格式识别为邮箱</span><br><span class="line">&lt;meta name=<span class="string">&quot;format-detection&quot;</span> content=<span class="string">&quot;email=no&quot;</span>/&gt;</span><br><span class="line"><span class="regexp">//</span> 也可以写成：</span><br><span class="line">&lt;meta name=<span class="string">&quot;format-detection&quot;</span> content=<span class="string">&quot;telphone=no, email=no&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-浏览器内核控制"><a href="#1-3-浏览器内核控制" class="headerlink" title="1.3 浏览器内核控制"></a>1.3 浏览器内核控制</h4><p>国内浏览器很多都是双内核（<code>webkit</code>和<code>Trident</code>），webkit内核高速浏览，IE内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染。（仅限360浏览器）</p>
<p><code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit|ie-comp|ie-stand&quot;&gt;</code></p>
<p>若页面需默认用极速核，增加标签：<code>&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;</code><br>若页面需默认用ie兼容内核，增加标签：<code>&lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt;</code><br>若页面需默认用ie标准内核，增加标签：<code>&lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt;</code></p>
<p>  <strong>各渲染内核的技术细节</strong></p>
<table>
<thead>
<tr>
<th align="left">内核</th>
<th>Webkit</th>
<th>IE兼容</th>
<th>IE标准</th>
</tr>
</thead>
<tbody><tr>
<td align="left">内核版本</td>
<td>Chrome 45</td>
<td>IE6/7</td>
<td>IE9/IE10/IE11(取决于用户的IE)</td>
</tr>
<tr>
<td align="left">HTML5支持</td>
<td>YES</td>
<td>NO</td>
<td>YES</td>
</tr>
<tr>
<td align="left">ActiveX控件支持</td>
<td>NO</td>
<td>YES</td>
<td>YES</td>
</tr>
</tbody></table>
<h4 id="1-4-WebApp全屏模式"><a href="#1-4-WebApp全屏模式" class="headerlink" title="1.4 WebApp全屏模式"></a>1.4 WebApp全屏模式</h4><p><code>&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&gt; &lt;!-- 启用 WebApp 全屏模式 --&gt;</code></p>
<h4 id="1-5-隐藏状态栏-设置状态栏颜色"><a href="#1-5-隐藏状态栏-设置状态栏颜色" class="headerlink" title="1.5 隐藏状态栏/设置状态栏颜色"></a>1.5 隐藏状态栏/设置状态栏颜色</h4><p>只有在开启WebApp全屏模式时才生效。content的值为<code>default</code> | <code>black</code> | <code>black-translucent</code> 。</p>
<p><code>&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot; /&gt;</code></p>
<h4 id="1-6-不同浏览器"><a href="#1-6-不同浏览器" class="headerlink" title="1.6 不同浏览器"></a>1.6 不同浏览器</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">`<span class="comment">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span> `</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;HandheldFriendly&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span>&gt;</span>  `</span><br><span class="line"></span><br><span class="line">`<span class="comment">&lt;!-- 微软的老式浏览器 --&gt;</span>  `</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;MobileOptimized&quot;</span> <span class="attr">content</span>=<span class="string">&quot;320&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">`<span class="comment">&lt;!-- uc强制竖屏 --&gt;</span>  `</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;screen-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">`<span class="comment">&lt;!-- QQ强制竖屏 --&gt;</span>  `</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-orientation&quot;</span> <span class="attr">content</span>=<span class="string">&quot;portrait&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">`<span class="comment">&lt;!-- UC强制全屏 --&gt;</span> `</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;full-screen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">`<span class="comment">&lt;!-- QQ强制全屏 --&gt;</span>  `</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-fullscreen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;true&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">`<span class="comment">&lt;!-- UC应用模式 --&gt;</span> `</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;browsermode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;application&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">`<span class="comment">&lt;!-- QQ应用模式 --&gt;</span> `</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;x5-page-mode&quot;</span> <span class="attr">content</span>=<span class="string">&quot;app&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">`<span class="comment">&lt;!-- windows phone 点击无高光 --&gt;</span> `</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;msapplication-tap-highlight&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-http-equiv"><a href="#2-http-equiv" class="headerlink" title="2. http-equiv"></a>2. http-equiv</h3><h4 id="2-1-优先使用-IE-最新版本和-Chrome"><a href="#2-1-优先使用-IE-最新版本和-Chrome" class="headerlink" title="2.1 优先使用 IE 最新版本和 Chrome"></a>2.1 优先使用 IE 最新版本和 Chrome</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">`<span class="comment">&lt;!-- 关于X-UA-Compatible --&gt;</span>  `</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=6&quot;</span> &gt;</span><span class="comment">&lt;!-- 使用IE6 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=7&quot;</span> &gt;</span><span class="comment">&lt;!-- 用于在IE8版本浏览器中使用IE7渲染来避免出错 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=8&quot;</span> &gt;</span><span class="comment">&lt;!-- 使用IE8 --&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-转码申明"><a href="#2-2-转码申明" class="headerlink" title="2.2 转码申明"></a>2.2 转码申明</h4><p>用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加如下<code>meta</code></p>
<p><code>&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot; /&gt;</code></p>
<h3 id="3-charset"><a href="#3-charset" class="headerlink" title="3. charset"></a>3. charset</h3><p><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code></p>
<ul>
<li><p>meta标签的charset的信息参数如<code>GB2312</code>时，代表说明网站是采用的编码是简体中文；</p>
</li>
<li><p>meta标签的charset的信息参数如<code>BIG5</code>时，代表说明网站是采用的编码是繁体中文； </p>
</li>
<li><p>meta标签的charset的信息参数如<code>iso-2022-jp</code>时，代表说明网站是采用的编码是日文；  </p>
</li>
<li><p>meta标签的charset的信息参数如<code>ks_c_5601</code>时，代表说明网站是采用的编码是韩文；  </p>
</li>
<li><p>meta标签的charset的信息参数如<code>ISO-8859-1</code>时，代表说明网站是采用的编码是英文；  </p>
</li>
<li><p>meta标签的charset的信息参数如<code>UTF-8</code>时，代表世界通用的语言编码</p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>The Second Birthday</title>
    <url>/2020/10/10/the-second-birthday/</url>
    <content><![CDATA[<hr>

<p><div id="clock-box" style="margin:10px auto;text-align:center;font-size:37px;font-weight:bold;"><br>    <span style="color:#FAE865">臭臭鑫</span>与<span style="color:#ffa5a5;font-size:39px;">@哈尼小宝贝</span>在一起的<br>    <div id="clock" style="margin:0 auto;font-size:40px;font-weight:bolder;color:#68b0ab;"></div id="clock"></div id="clock-box"></p>



<p><canvas id="mycanvas" width="1100" height="680"></canvas></p>
<div style="margin: 10px auto;text-align:center;">
    <span style="font-size:40px;margin-right:16px;color:#ffc93c;">生日快乐</span> <span style="font-size:34px;color:#ed6663">哈尼！</span>
</div>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>My Life</category>
      </categories>
      <tags>
        <tag>myLove</tag>
      </tags>
  </entry>
  <entry>
    <title>UI 框架</title>
    <url>/2020/11/06/UI-frames/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>关于<code>UI 框架</code>，最好的总结方式莫过于汇总遇到的问题！</p>
<p>–  ElementUI</p>
<p>–  bootstrap</p>
<p>–  echart</p>
<p>–  weui</p>
<p>–  extjs</p>
</blockquote>
<a id="more"></a>

<h2 id="一、ElementUI"><a href="#一、ElementUI" class="headerlink" title="一、ElementUI"></a>一、ElementUI</h2><h3 id="el-date-picker-日期选择控件的坑"><a href="#el-date-picker-日期选择控件的坑" class="headerlink" title="el-date-picker 日期选择控件的坑"></a><code>el-date-picker</code> <a href="https://element.eleme.cn/#/zh-CN/component/date-picker">日期选择控件</a>的坑</h3><h4 id="1、-picker-options-动态生成"><a href="#1、-picker-options-动态生成" class="headerlink" title="1、:picker-options 动态生成"></a>1、<code>:picker-options</code> 动态生成</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-date-picker</span><br><span class="line">    v-model&#x3D;&quot;value2&quot;</span><br><span class="line">    align&#x3D;&quot;right&quot;</span><br><span class="line">    type&#x3D;&quot;date&quot;</span><br><span class="line">    placeholder&#x3D;&quot;选择日期&quot;</span><br><span class="line">    :picker-options&#x3D;&quot;pickerOptions&quot;&gt;</span><br><span class="line">&lt;&#x2F;el-date-picker&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        pickerOptions: &#123;</span><br><span class="line">          disabledDate(time) &#123;</span><br><span class="line">            return time.getTime() &gt; Date.now();</span><br><span class="line">          &#125;,</span><br><span class="line">          shortcuts: [&#123;</span><br><span class="line">            text: &#39;今天&#39;,</span><br><span class="line">            onClick(picker) &#123;</span><br><span class="line">              picker.$emit(&#39;pick&#39;, new Date());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            text: &#39;昨天&#39;,</span><br><span class="line">            onClick(picker) &#123;</span><br><span class="line">              const date &#x3D; new Date();</span><br><span class="line">              date.setTime(date.getTime() - 3600 * 1000 * 24);</span><br><span class="line">              picker.$emit(&#39;pick&#39;, date);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, &#123;</span><br><span class="line">            text: &#39;一周前&#39;,</span><br><span class="line">            onClick(picker) &#123;</span><br><span class="line">              const date &#x3D; new Date();</span><br><span class="line">              date.setTime(date.getTime() - 3600 * 1000 * 24 * 7);</span><br><span class="line">              picker.$emit(&#39;pick&#39;, date);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;]</span><br><span class="line">        &#125;,</span><br><span class="line">        value2: &#39;&#39;,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>控件中的 <code>pickerOptions</code> 是写在 <code>data</code> 中的，其中的 <code>disabledDate()</code> 函数中不能根据动态数据改变</p>
<blockquote>
<p>如果在 <code>methods</code> 中定义方法，然后在 <code>disabledDate()</code> 中是引用不到的</p>
</blockquote>
<h5 id="解决办法（使用计算属性）"><a href="#解决办法（使用计算属性）" class="headerlink" title="解决办法（使用计算属性）"></a>解决办法（使用计算属性）</h5><blockquote>
<p>注意使用 <code>that</code> 保存 <code>this</code> 变量</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    <span class="comment">// date-picker-func</span></span><br><span class="line">    pickerOptions() &#123;</span><br><span class="line">      <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        disabledDate(time) &#123;</span><br><span class="line">          <span class="comment">// disableDateArray 为动态更新的不可选日期数组</span></span><br><span class="line">          <span class="keyword">return</span> that.disabledDateArray.includes(+(<span class="keyword">new</span> <span class="built_in">Date</span>(time))) </span><br><span class="line">            || (+<span class="keyword">new</span> <span class="built_in">Date</span>(time) &lt; +<span class="keyword">new</span> <span class="built_in">Date</span>() - <span class="number">3600</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">30</span>)</span><br><span class="line">            || (+<span class="keyword">new</span> <span class="built_in">Date</span>(time) &gt; +<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="number">3600</span> * <span class="number">1000</span> * <span class="number">24</span> * <span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在过程中还出现了一个小插曲：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 forEach() 中遍历时， return 是没有效果的！！！！</span></span><br><span class="line">that.disabledDateArray.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>(time).getTime() === <span class="keyword">new</span> <span class="built_in">Date</span>(item).getTime())</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(time).getTime() !== <span class="keyword">new</span> <span class="built_in">Date</span>(item).getTime();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>

<h3 id="el-table-表格控件的坑"><a href="#el-table-表格控件的坑" class="headerlink" title="el-table 表格控件的坑"></a><code>el-table</code> 表格控件的坑</h3><h4 id="1、elementui更改el-table表头背景颜色和字体颜色"><a href="#1、elementui更改el-table表头背景颜色和字体颜色" class="headerlink" title="1、elementui更改el-table表头背景颜色和字体颜色"></a><a href="https://blog.csdn.net/dg_zing/article/details/87194329">1、elementui更改el-table表头背景颜色和字体颜色</a></h4><p>下面先上自己已经可以正常使用的代码，值得注意的：</p>
<p><strong>表头背景颜色</strong>使用  <code>:header-cell-style=&quot;&#123;background:&#39;#F1F9FD&#39;&#125;&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table</span><br><span class="line">          class&#x3D;&quot;table&quot;</span><br><span class="line">          :data&#x3D;&quot;tableData&quot;</span><br><span class="line">          :border&#x3D;&quot;true&quot;</span><br><span class="line">          :stripe&#x3D;&quot;true&quot;</span><br><span class="line">          style&#x3D;&quot;width: 100%&quot;</span><br><span class="line">          tooltip-effect&#x3D;&quot;light&quot;</span><br><span class="line">          :header-cell-style&#x3D;&quot;&#123;background:&#39;#F1F9FD&#39;&#125;&quot;&gt;</span><br><span class="line">      &lt;el-table-column</span><br><span class="line">        type&#x3D;&quot;index&quot;</span><br><span class="line">        label&#x3D;&quot;序号&quot;</span><br><span class="line">        align&#x3D;&quot;center&quot;</span><br><span class="line">        width&#x3D;&quot;60&quot;&gt;</span><br><span class="line">      &lt;&#x2F;el-table-column&gt;</span><br><span class="line">      &lt;el-table-column</span><br><span class="line">        label&#x3D;&quot;商品名称&quot;&gt;</span><br><span class="line">        &lt;template slot-scope&#x3D;&quot;scoped&quot;&gt;</span><br><span class="line">          &lt;el-select</span><br><span class="line">            v-model&#x3D;&quot;scoped.row.goodsName&quot;</span><br><span class="line">            placeholder&#x3D;&quot;商品名称&quot;</span><br><span class="line">            @change&#x3D;&quot;vaildateName(scoped.$index)&quot;&gt;</span><br><span class="line">            &lt;el-option</span><br><span class="line">              v-for&#x3D;&quot;item in goodsNameList&quot;</span><br><span class="line">              :key&#x3D;&quot;item.id&quot;</span><br><span class="line">              :label&#x3D;&quot;item.name&quot;</span><br><span class="line">              :value&#x3D;&quot;item.name&quot;&gt;</span><br><span class="line">            &lt;&#x2F;el-option&gt;</span><br><span class="line">          &lt;&#x2F;el-select&gt;</span><br><span class="line">        &lt;&#x2F;template&gt;</span><br><span class="line">&lt;&#x2F;el-table&gt;</span><br></pre></td></tr></table></figure>

<p>另外，利用 <code>cell-class-name</code> 这个属性<strong>可以给特定单元格给予样式</strong>，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-table</span><br><span class="line">    class&#x3D;&quot;table &quot;</span><br><span class="line">    :data&#x3D;&quot;item&quot;</span><br><span class="line">    :border&#x3D;&quot;true&quot;</span><br><span class="line">    :stripe&#x3D;&quot;true&quot;</span><br><span class="line">    style&#x3D;&quot;width: 100%&quot;</span><br><span class="line">    tooltip-effect&#x3D;&quot;light&quot;</span><br><span class="line">    :header-cell-style&#x3D;&quot;&#123;background:&#39;#134693&#39;&#125;&quot;</span><br><span class="line">    :cell-class-name&#x3D;&quot;addCellClass&quot;&gt;</span><br><span class="line">...</span><br><span class="line">&lt;&#x2F;el-table&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">    addCellClass(row) &#123;</span><br><span class="line">      let classNames &#x3D; &#39;&#39;;</span><br><span class="line">      if (row.columnIndex &#x3D;&#x3D;&#x3D; 5) &#123;</span><br><span class="line">        classNames +&#x3D; &#39; green&#39;;</span><br><span class="line">      &#125;</span><br><span class="line">      return classNames;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<br>

<h3 id="el-upload-上传控件的坑"><a href="#el-upload-上传控件的坑" class="headerlink" title="el-upload 上传控件的坑"></a><code>el-upload</code> 上传控件的坑</h3><p>上传文件肯定是采用 <code>post</code> 请求，<strong>一种情况是写请求方法，另一种简单的情况是把请求地址写在组件的 <code>action</code> 属性上</strong>。先上可行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-upload</span><br><span class="line">    :action&#x3D;&quot;serverUrl + &#39;&#x2F;report&#x2F;import&#39;&quot;</span><br><span class="line">    :show-file-list&#x3D;&quot;false&quot;</span><br><span class="line">    :limit&#x3D;&quot;1&quot;</span><br><span class="line">    ref&#x3D;&quot;goodsUploader&quot;</span><br><span class="line">    accept&#x3D;&quot;.xlsx, .xls&quot;</span><br><span class="line">    :on-exceed&#x3D;&quot;handleExceed&quot;</span><br><span class="line">    :on-success&#x3D;&quot;onImportFileSuccess&quot;</span><br><span class="line">    :before-upload&#x3D;&quot;beforeUpload&quot;&gt;</span><br><span class="line">    &lt;el-button type&#x3D;&quot;primary&quot;&gt;导入检测结果&lt;&#x2F;el-button&gt;</span><br><span class="line">&lt;&#x2F;el-upload&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        &#x2F;&#x2F; 文件数量超出</span><br><span class="line">        handleExceed(files, fileList) &#123;</span><br><span class="line">            this.$message.warning(&#39;提示&#39;, &#123;</span><br><span class="line">                limitChose: this.fileLimit,</span><br><span class="line">                currentChose: files.length,</span><br><span class="line">                totalChose: files.length + fileList.length</span><br><span class="line">              &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 上传之前执行回调</span><br><span class="line">        beforeUpload() &#123;</span><br><span class="line">          if (this.tableData.length &gt; 0) &#123;</span><br><span class="line">            this.$message(&#39;导入文件之前请清空已有数据列表&#39;);</span><br><span class="line">            return false;</span><br><span class="line">          &#125; else if (this.checkPlace &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">            this.$message(&#39;导入文件之前请选择检测地点&#39;);</span><br><span class="line">            return false;</span><br><span class="line">          &#125; else if (this.checkDate &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">            this.$message(&#39;导入文件之前请选择检测时间&#39;);</span><br><span class="line">            return false;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 上传成功</span><br><span class="line">        onImportFileSuccess(res) &#123;</span><br><span class="line">          if (res.responseCode &#x3D;&#x3D;&#x3D; &#39;SUC&#39;) &#123;</span><br><span class="line">            this.$notify(&#123;</span><br><span class="line">              title: &#39;提示&#39;,</span><br><span class="line">              message: &#39;文件上传成功&#39;,</span><br><span class="line">              type: &#39;success&#39;</span><br><span class="line">            &#125;);</span><br><span class="line">            this.tableData &#x3D; cloneDeep(res.data);</span><br><span class="line">            this.tableCheckItemStatus &#x3D; [];</span><br><span class="line">            this.tableData.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">              this.tableCheckItemStatus.push(item.reference);</span><br><span class="line">            &#125;)</span><br><span class="line">            this.updateVerdictSum();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            this.$notify(&#123;</span><br><span class="line">              title: &#39;提示&#39;,</span><br><span class="line">              message: &#39;文件上传失败&#39;,</span><br><span class="line">              type: &#39;error&#39;</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          this.$refs.goodsUploader.clearFiles();</span><br><span class="line">          this.loading &#x3D; false;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>另一种<strong>自己写请求</strong>的方法如下：（但个人没有做验证，因为第一次验证不成功）</p>
<blockquote>
<p>下次参考链接：<a href="https://blog.csdn.net/qq_39759115/article/details/82287207">自定义上传的实现</a> 、<a href="https://www.jianshu.com/p/55c0bd5b5b3e">简述Http-request自定义上传</a></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">uploadSectionFile(params) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params);</span><br><span class="line">    <span class="keyword">const</span> file = params.file;</span><br><span class="line">    <span class="keyword">const</span> fileType = file.type;</span><br><span class="line">    <span class="keyword">const</span> isImage = fileType.indexOf(<span class="string">&quot;image&quot;</span>) !== <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">const</span> isLt2M = file.size / <span class="number">1024</span> / <span class="number">1024</span> &lt; <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 这里常规检验，看项目需求而定</span></span><br><span class="line">    <span class="keyword">if</span> (!isImage) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$message(<span class="string">&quot;只能上传Execl文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isLt2M) &#123;</span><br><span class="line">        <span class="built_in">this</span>.$message.error(<span class="string">&quot;只能上传图片大小小于2M&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据后台需求数据格式</span></span><br><span class="line">    <span class="keyword">const</span> form = <span class="keyword">new</span> FormData();</span><br><span class="line">    <span class="comment">// 文件对象</span></span><br><span class="line">    form.append(<span class="string">&quot;file&quot;</span>, file);</span><br><span class="line">    <span class="comment">// 本例子主要要在请求时添加特定属性，所以要用自己方法覆盖默认的action</span></span><br><span class="line">    form.append(<span class="string">&quot;clientType&quot;</span>, <span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line">    <span class="comment">// 项目封装的请求方法，下面做简单介绍</span></span><br><span class="line">    <span class="built_in">this</span>.$http.post.importGoodsFormExcel(form).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">    &#125;).catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// xxx</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// exportLoading () &#123;&#125;</span></span><br><span class="line">uploadSectionFile(obj) &#123;</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">    formData.append(<span class="string">&#x27;file&#x27;</span>, obj.file);</span><br><span class="line">    <span class="comment">// formData.append(&#x27;user&#x27;, this.$store.state.app.userInfo.personName);</span></span><br><span class="line">    <span class="built_in">this</span>._upload(formData);</span><br><span class="line">&#125;,</span><br><span class="line">_upload(formData)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$http.post.importGoodsFormExcel(formData).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$refs.uploader.clearFiles();</span><br><span class="line">        <span class="keyword">if</span> (res.responseCode === <span class="string">&#x27;SUC&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(res.data, <span class="string">&#x27;map&#x27;</span>) &amp;&amp; <span class="built_in">Object</span>.keys(res.data.map).length)&#123;</span><br><span class="line">                <span class="keyword">let</span> errorDomList = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                <span class="keyword">const</span> errorLength = <span class="built_in">Object</span>.keys(res.data.map).length;</span><br><span class="line">                <span class="keyword">const</span> lines = <span class="built_in">Object</span>.keys(res.data.map);</span><br><span class="line">                <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; errorLength; i+=<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">const</span> lineNumber = lines[i];</span><br><span class="line">                    <span class="keyword">const</span> describe = res.data.map[lineNumber];</span><br><span class="line">                    <span class="comment">/* <span class="doctag">TODO:</span>暂时不做顿号(、)或者逗号(,) */</span></span><br><span class="line">                    errorDomList = <span class="string">`<span class="subst">$&#123;errorDomList&#125;</span>&lt;div&gt;第<span class="subst">$&#123;lineNumber&#125;</span>行错误:<span class="subst">$&#123;describe&#125;</span><span class="subst">$&#123;i &lt; errorLength - <span class="number">1</span> ? <span class="string">&#x27;&#x27;</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>&lt;/div&gt;`</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* 导入完成 */</span></span><br><span class="line">              <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">              <span class="built_in">this</span>.$alert(<span class="string">`&lt;div style=&quot;padding-left:20px;max-height:300px;overflow:auto;&quot;&gt;</span></span><br><span class="line"><span class="string">                &lt;div&gt;共有<span class="subst">$&#123;errorLength&#125;</span>行错误，错误的行:&lt;/div&gt;</span></span><br><span class="line"><span class="string">                <span class="subst">$&#123;errorDomList&#125;</span></span></span><br><span class="line"><span class="string">                &lt;/div&gt;`</span>, <span class="string">&#x27;入库导入完成&#x27;</span>, &#123;</span><br><span class="line">                dangerouslyUseHTMLString: <span class="literal">true</span>,</span><br><span class="line">                showClose: <span class="literal">false</span>,</span><br><span class="line">                lockScroll: <span class="literal">false</span></span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="comment">// eslint-disable-next-line</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Object</span>.hasOwnProperty.call(res.data, <span class="string">&#x27;map&#x27;</span>) &amp;&amp; <span class="built_in">Object</span>.keys(res.data.map).length == <span class="number">0</span>)&#123;</span><br><span class="line">              <span class="built_in">this</span>.$notify.success(&#123;</span><br><span class="line">                title: <span class="string">&#x27;提示&#x27;</span>,</span><br><span class="line">                message: <span class="string">&#x27;导入成功&#x27;</span></span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="built_in">this</span>.buttonSearch();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">this</span>.$notify.warning(&#123;</span><br><span class="line">                title: <span class="string">&#x27;提示&#x27;</span>,</span><br><span class="line">                message: <span class="string">&#x27;导入失败&#x27;</span></span><br><span class="line">              &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.$notify(&#123;</span><br><span class="line">              title: <span class="string">&#x27;提示&#x27;</span>,</span><br><span class="line">              message: <span class="string">&#x27;导入失败&#x27;</span>,</span><br><span class="line">              type: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">          resolve(res);</span><br><span class="line">        &#125;).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.loading = <span class="literal">false</span>;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="element-ui的滚动条组件el-scrollbar（官方没有）"><a href="#element-ui的滚动条组件el-scrollbar（官方没有）" class="headerlink" title="element-ui的滚动条组件el-scrollbar（官方没有）"></a><a href="https://www.cnblogs.com/myfirstboke/p/10218138.html">element-ui的滚动条组件el-scrollbar（官方没有）</a></h3><h4 id><a href="#" class="headerlink" title></a></h4><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>VsCode 杂谈</title>
    <url>/2020/09/08/talk-about-VsCode/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>这篇文章汇总有关<code>VsCode</code>的冷知识，换句话说就是<code>IDE</code>的使用和一些自己遇到的问题</p>
<p>–  值得推荐的<code>Vscode</code>插件</p>
<p>–  使用<code>Vscode</code>中遇到的问题</p>
</blockquote>
<a id="more"></a>

<h2 id="一、值得推荐的Vscode插件"><a href="#一、值得推荐的Vscode插件" class="headerlink" title="一、值得推荐的Vscode插件"></a>一、值得推荐的<code>Vscode</code>插件</h2><p><code>2020/10/29</code> 终于找到了比较全的文章</p>
<p><a href="https://github.com/varHarrie/varharrie.github.io/issues/10">戳这儿</a></p>
<p>推荐一个上班摸鱼又炒鱿鱼小插件：<code>小霸王</code>  —— 绝对的炒鱿鱼小技巧</p>
<br>

<h2 id="二、使用Vscode中遇到的问题"><a href="#二、使用Vscode中遇到的问题" class="headerlink" title="二、使用Vscode中遇到的问题"></a>二、使用<code>Vscode</code>中遇到的问题</h2><h3 id="1、解决eslint空格报错等问题"><a href="#1、解决eslint空格报错等问题" class="headerlink" title="1、解决eslint空格报错等问题"></a>1、解决<code>eslint</code>空格报错等问题</h3><blockquote>
<p>参考<a href="https://www.cnblogs.com/fqh123/p/9967771.html">该博主</a></p>
</blockquote>
<p><code>eslint</code>检查代码风格是好的，不过 有些<code>换行报错</code> 、<code>空格报错</code>，还有在代码中有 console也是报错，这有些烦人—-&gt;</p>
<p>为了把这些烦人的报错给禁止掉</p>
<p>我们可以在<code>package.json</code>文件中 找到（或者在<code>.eslintrc.js</code>中找到<code>rules</code>）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;eslintConfig&quot;</span>: &#123;</span><br><span class="line">　　<span class="string">&quot;root&quot;</span>: true,</span><br><span class="line">　　<span class="string">&quot;env&quot;</span>: &#123;</span><br><span class="line">　　　　<span class="string">&quot;node&quot;</span>: true</span><br><span class="line">　　&#125;,</span><br><span class="line">　　<span class="string">&quot;extends&quot;</span>: [</span><br><span class="line">　　　　<span class="string">&quot;plugin:vue/essential&quot;</span>,</span><br><span class="line">　　　　<span class="string">&quot;eslint:recommended&quot;</span></span><br><span class="line">　　],</span><br><span class="line">　　<span class="string">&quot;rules&quot;</span>: &#123;</span><br><span class="line">　　　　<span class="string">&quot;no-console&quot;</span>:<span class="string">&quot;off&quot;</span>,<span class="regexp">//</span>在这禁止掉console报错检查</span><br><span class="line">　　　　<span class="string">&quot;no-irregular-whitespace&quot;</span>:<span class="string">&quot;off&quot;</span><span class="regexp">//</span>这禁止掉 空格报错检查</span><br><span class="line">　　&#125;,</span><br><span class="line">　　<span class="string">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">　　　　<span class="string">&quot;parser&quot;</span>: <span class="string">&quot;babel-eslint&quot;</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>在rules规则中 禁止掉这些规则</span><br></pre></td></tr></table></figure>

<p>下面罗列一些，一些规则的含义：</p>
<blockquote>
<p>“off” or 0 - 关闭(禁用)规则<br>“warn” or 1 - 将规则视为一个警告（并不会导致检查不通过）<br>“error” or 2 - 将规则视为一个错误 (退出码为1，检查不通过) </p>
</blockquote>
<h3 id="2、代码行数统计"><a href="#2、代码行数统计" class="headerlink" title="2、代码行数统计"></a>2、代码行数统计</h3><p>选择<strong>编辑</strong> -&gt; <strong>在文件中查找（正则）</strong>        <code>^b*[^:b#/]+.*$</code>     </p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Tool &amp; Platform</category>
      </categories>
      <tags>
        <tag>开发与调试</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Eslint</title>
    <url>/2020/11/23/Vue-Eslint/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><a id="more"></a><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>框架与工具</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-router的两种模式</title>
    <url>/2020/11/10/vue-router&#39;s-two-models/</url>
    <content><![CDATA[<h2 id="Vue-Router-的两种模式"><a href="#Vue-Router-的两种模式" class="headerlink" title="Vue-Router 的两种模式"></a><code>Vue-Router</code> 的两种模式</h2><blockquote>
<p>转载 原文<a href="https://www.jianshu.com/p/e92e706f3455">传送门</a></p>
<p>vue-router <a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html">官方文档</a></p>
</blockquote>
<p>为了构建 <strong>SPA（单页面应用）</strong>，需要引入前端路由系统，这就是 Vue-Router 存在的意义。</p>
<p>前端路由的核心，就在于 —— <strong>改变视图的同时不会向后端发出请求</strong>。</p>
<a id="more"></a>

<h3 id="Hash-模式（默认）"><a href="#Hash-模式（默认）" class="headerlink" title="Hash 模式（默认）"></a>Hash 模式（默认）</h3><p><strong>hash模式—— 即地址栏 URL 中的 # 符号</strong></p>
<p><span style="color:red;">hash模式的原理是 <code>onhashchange</code> 事件，可以通过 <code>window</code> 对象来监听该事件</span></p>
<p>这里的 hash 就是指 url 尾巴后的 # 号以及后面的字符。</p>
<p>这里的 <code>#</code> 和 <code>css</code> 里的 <code>#</code> 是一个意思。<code>hash</code> 也 称作 锚点，本身是用来做页面定位的，她可以使对应 <code>id</code> 的元素显示在可视区域内。</p>
<p>比如这个 URL：<code>http://www.abc.com/#/hello</code>，<code>hash</code> 的值为 <code>#/hello</code>。<strong>它的特点在于：<code>hash</code> 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</strong></p>
<blockquote>
<p>由于 hash 值变化不会导致浏览器向服务器发出请求，而且 hash 改变会触发 <code>hashchange</code> 事件，浏览器的进后退也能对其进行控制，所以人们在 html5 的 history 出现前，基本都是使用 hash 来实现前端路由的。</p>
</blockquote>
<h4 id="使用到的api"><a href="#使用到的api" class="headerlink" title="使用到的api"></a>使用到的api</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">window.location.hash = <span class="string">&#x27;qq&#x27;</span>  <span class="comment">// 设置 url 的 hash，会在当前url后加上 &#x27;#qq&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hash = window.location.hash <span class="comment">// &#x27;#qq&#x27; </span></span><br><span class="line"></span><br><span class="line">window.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, function()&#123; </span><br><span class="line">    <span class="comment">// 监听hash变化，点击浏览器的前进后退会触发</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="History-模式"><a href="#History-模式" class="headerlink" title="History 模式"></a>History 模式</h3><p><strong>利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。</strong></p>
<blockquote>
<p>已经有 hash 模式了，而且 hash 能兼容到IE8， history 只能兼容到 IE10，为什么还要搞个 history 呢？</p>
</blockquote>
<p>首先，hash 本来是拿来做页面定位的，如果拿来做路由的话，原来的锚点功能就不能用了。</p>
<p>其次，hash 的传参是基于 url 的，如果要传递复杂的数据，会有体积的限制，而 history 模式不仅可以在url里放参数，还可以将数据存放在一个特定的对象中。</p>
<h4 id="相关api"><a href="#相关api" class="headerlink" title="相关api"></a>相关api</h4><p><strong>window.history.pushState(state, title, url)</strong></p>
<ul>
<li><p>state：需要保存的数据，这个数据在触发<code>popstate</code>事件时，可以在event.state里获取</p>
</li>
<li><p>title：标题，基本没用，一般传 null</p>
</li>
<li><p>url：设定新的历史记录的 url。新的 url 与当前 url 的 origin 必须是一样的，否则会抛出错误。url可以是绝对路径，也可以是相对路径。</p>
</li>
</ul>
<blockquote>
<p>例如</p>
</blockquote>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"> 当前url是 https:<span class="comment">//www.baidu.com/a/</span></span><br><span class="line"></span><br><span class="line">执行history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&#x27;./qq/&#x27;</span>)，则变成 https:<span class="comment">//www.baidu.com/a/qq/</span></span><br><span class="line">执行history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, <span class="string">&#x27;/qq/&#x27;</span>)，则变成 https:<span class="comment">//www.baidu.com/qq/</span></span><br></pre></td></tr></table></figure>

<p><strong>window.history.replaceState(state, title, url)</strong></p>
<p>与 <code>pushState</code> 基本相同，但它是修改当前历史记录，而 <code>pushState</code> 是创建新的历史记录</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">window.addEventListener(<span class="string">&quot;popstate&quot;</span>, function()&#123;</span><br><span class="line">  <span class="comment">// 监听浏览器前进后退事件，pushState 与 replaceState 方法不会触发       </span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>window.history.back()            // 后退</strong></p>
<p><strong>window.history.forward()      // 前进</strong></p>
<p><strong>window.history.go(1)              // 前进一步，-2为后退两步，</strong></p>
<p><strong>window.history.length           // 可以查看当前历史堆栈中页面的数量</strong></p>
<h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p><code>history</code> 模式改变 url 的方式会导致浏览器向服务器发送请求，这不是我们想看到的</p>
<p><strong>我们需要在服务器端做处理：如果匹配不到任何静态资源，则应该始终返回同一个 html 页面</strong></p>
<p><strong>hash 模式下</strong>，仅 hash 符号之前的内容会被包含在请求中，如 <code>http://www.abc.com</code>，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误</p>
<p><strong>history 模式下</strong>，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <code>http://www.abc.com/book/id</code>。如果后端缺少对 /book/id 的路由处理，将返回 404 错误。</p>
<blockquote>
<p>vue-router官网里如此描述：<strong>“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</strong></p>
</blockquote>
<p>可以说，<code>hash 模式</code>和 <code>history 模式</code>都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>一般场景下，<code>hash</code> 和 <code>history</code> 都可以，除非你更在意颜值，<code>#</code> 符号夹杂在 <code>URL</code> 里看起来确实有些不太美观</p>
</li>
<li><p>对于一般的 <strong>Vue + Vue-Router + Webpack + XXX</strong> 形式的 Web 开发场景，用 <code>history</code> 模式即可，只需在后端（<code>Apache</code> 或 <code>Nginx</code>）进行简单的路由配置，同时搭配前端路由的 <code>404 页面</code>支持。</p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>框架与工具</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-socket-io API说明及使用</title>
    <url>/2020/09/05/Vue-socket-io-API-description-and-usage/</url>
    <content><![CDATA[<h2 id="问题缘起"><a href="#问题缘起" class="headerlink" title="问题缘起"></a>问题缘起</h2><blockquote>
<p>最近接手了一个小项目，数据通信选型使用<code>Socket</code>实现，因此，恶补<code>WebScoket</code>的概念和<code>vue-socket-io</code>的使用</p>
</blockquote>
<h2 id="一、WebSocket-基础"><a href="#一、WebSocket-基础" class="headerlink" title="一、WebSocket 基础"></a>一、<code>WebSocket</code> 基础</h2><blockquote>
<p>这一部分还是廖雪峰老师讲的好，附上<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">传送门</a></p>
<p>当然，我个人还是要记录一下，可能是<code>CTRL-C/V</code>，但权当再加深印象</p>
</blockquote>
<a id="more"></a>

<h3 id="1-HTTP-协议和-WebSocket-的区别？它能带来什么好处？"><a href="#1-HTTP-协议和-WebSocket-的区别？它能带来什么好处？" class="headerlink" title="1. HTTP 协议和 WebSocket 的区别？它能带来什么好处？"></a>1. HTTP 协议和 WebSocket 的区别？它能带来什么好处？</h3><p>答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。</p>
<p>这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用<a href="https://www.pubnub.com/blog/2014-12-01-http-long-polling/">“轮询”</a>：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。</p>
<p>轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。</p>
<p>WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。</p>
<p><strong>它的最大特点就是</strong>，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于<a href="https://en.wikipedia.org/wiki/Push_technology">服务器推送技术</a>的一种。</p>
<p><img data-src="bg202009051.png"></p>
<p><strong>其他特点包括：</strong></p>
<p>（1）建立在 TCP 协议之上，服务器端的实现比较容易。</p>
<p>（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</p>
<p>（3）数据格式比较轻量，性能开销小，通信高效。</p>
<p>（4）可以发送文本，也可以发送二进制数据。</p>
<p>（5）没有同源限制，客户端可以与任意服务器通信。</p>
<p>（6）协议标识符是<code>ws</code>（如果加密，则为<code>wss</code>），服务器网址就是 URL。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws:&#x2F;&#x2F;example.com:80&#x2F;some&#x2F;path</span><br></pre></td></tr></table></figure>

<p><img data-src="bg202009052.jpg"></p>
<h3 id="2-客户端的简单示例"><a href="#2-客户端的简单示例" class="headerlink" title="2. 客户端的简单示例"></a>2. 客户端的简单示例</h3><p>WebSocket 的用法相当简单。</p>
<p>下面是一个网页脚本的例子（点击<a href="http://jsbin.com/muqamiqimu/edit?js,console">这里</a>看运行结果），基本上一眼就能明白。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://echo.websocket.org&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection open ...&quot;</span>); </span><br><span class="line">  ws.send(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">&quot;Received Message: &quot;</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;;      </span><br></pre></td></tr></table></figure>

<h3 id="3-客户端的-API"><a href="#3-客户端的-API" class="headerlink" title="3. 客户端的 API"></a>3. 客户端的 API</h3><p>WebSocket 客户端的 API 如下。</p>
<h4 id="3-1-WebSocket-构造函数"><a href="#3-1-WebSocket-构造函数" class="headerlink" title="3.1 WebSocket 构造函数"></a>3.1 WebSocket 构造函数</h4><p>WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://localhost:8080&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>执行上面语句之后，客户端就会与服务器进行连接。</p>
<p>实例对象的所有属性和方法清单，参见<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSocket">这里</a>。</p>
<h4 id="3-2-webSocket-readyState"><a href="#3-2-webSocket-readyState" class="headerlink" title="3.2 webSocket.readyState"></a>3.2 webSocket.readyState</h4><p><code>readyState</code>属性返回实例对象的当前状态，共有四种。</p>
<blockquote>
<ul>
<li>CONNECTING：值为0，表示正在连接。</li>
<li>OPEN：值为1，表示连接成功，可以通信了。</li>
<li>CLOSING：值为2，表示连接正在关闭。</li>
<li>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</li>
</ul>
</blockquote>
<p>下面是一个示例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ws.readyState) &#123;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CONNECTING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.OPEN:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSING:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> WebSocket.CLOSED:</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// this never happens</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-webSocket-onopen"><a href="#3-3-webSocket-onopen" class="headerlink" title="3.3 webSocket.onopen"></a>3.3 webSocket.onopen</h4><p>实例对象的<code>onopen</code>属性，用于指定连接成功后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要指定多个回调函数，可以使用<code>addEventListener</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.addEventListener(<span class="string">&#x27;open&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-4-webSocket-onclose"><a href="#3-4-webSocket-onclose" class="headerlink" title="3.4 webSocket.onclose"></a>3.4 webSocket.onclose</h4><p>实例对象的<code>onclose</code>属性，用于指定连接关闭后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">&quot;close&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> code = event.code;</span><br><span class="line">  <span class="keyword">var</span> reason = event.reason;</span><br><span class="line">  <span class="keyword">var</span> wasClean = event.wasClean;</span><br><span class="line">  <span class="comment">// handle close event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-5-webSocket-onmessage"><a href="#3-5-webSocket-onmessage" class="headerlink" title="3.5 webSocket.onmessage"></a>3.5 webSocket.onmessage</h4><p>实例对象的<code>onmessage</code>属性，用于指定收到服务器数据后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.addEventListener(<span class="string">&quot;message&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.data;</span><br><span class="line">  <span class="comment">// 处理数据</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意，服务器数据可能是文本，也可能是二进制数据（<code>blob</code>对象或<code>Arraybuffer</code>对象）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> event.data === <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Received data string&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(event.data <span class="keyword">instanceof</span> <span class="built_in">ArrayBuffer</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> buffer = event.data;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Received arraybuffer&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了动态判断收到的数据类型，也可以使用<code>binaryType</code>属性，显式指定收到的二进制数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 收到的是 blob 数据</span></span><br><span class="line">ws.binaryType = <span class="string">&quot;blob&quot;</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到的是 ArrayBuffer 数据</span></span><br><span class="line">ws.binaryType = <span class="string">&quot;arraybuffer&quot;</span>;</span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-6-webSocket-send"><a href="#3-6-webSocket-send" class="headerlink" title="3.6 webSocket.send()"></a>3.6 webSocket.send()</h4><p>实例对象的<code>send()</code>方法用于向服务器发送数据。</p>
<p>发送文本的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.send(<span class="string">&#x27;your message&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>发送 Blob 对象的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> file = <span class="built_in">document</span></span><br><span class="line">  .querySelector(<span class="string">&#x27;input[type=&quot;file&quot;]&#x27;</span>)</span><br><span class="line">  .files[<span class="number">0</span>];</span><br><span class="line">ws.send(file);</span><br></pre></td></tr></table></figure>

<p>发送 ArrayBuffer 对象的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sending canvas ImageData as ArrayBuffer</span></span><br><span class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</span><br><span class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure>

<h4 id="3-7-webSocket-bufferedAmount"><a href="#3-7-webSocket-bufferedAmount" class="headerlink" title="3.7 webSocket.bufferedAmount"></a>3.7 webSocket.bufferedAmount</h4><p>实例对象的<code>bufferedAmount</code>属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10000000</span>);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (socket.bufferedAmount === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 发送完毕</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 发送还没结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-webSocket-onerror"><a href="#3-8-webSocket-onerror" class="headerlink" title="3.8 webSocket.onerror"></a>3.8 webSocket.onerror</h4><p>实例对象的<code>onerror</code>属性，用于指定报错时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">&quot;error&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error event</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-服务端的实现"><a href="#4-服务端的实现" class="headerlink" title="4. 服务端的实现"></a>4. 服务端的实现</h3><p>WebSocket 服务器的实现，可以查看维基百科的<a href="https://en.wikipedia.org/wiki/Comparison_of_WebSocket_implementations">列表</a>。</p>
<p>常用的 Node 实现有以下三种。</p>
<ul>
<li><a href="https://github.com/uWebSockets/uWebSockets">µWebSockets</a></li>
<li><a href="http://socket.io/">Socket.IO</a></li>
<li><a href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a></li>
</ul>
<h2 id="二、WebSocket实现之Socket-io"><a href="#二、WebSocket实现之Socket-io" class="headerlink" title="二、WebSocket实现之Socket.io"></a>二、WebSocket实现之<code>Socket.io</code></h2><blockquote>
<p><a href="https://socket.io/">Socket.io官网</a></p>
</blockquote>
<p>官网里的demo很多，看官网就好</p>
<h2 id="三、Vue-Socket-io-实现及使用"><a href="#三、Vue-Socket-io-实现及使用" class="headerlink" title="三、Vue-Socket-io 实现及使用"></a>三、<code>Vue-Socket-io</code> 实现及使用</h2><blockquote>
<p>推荐参考文档 <a href="https://www.npmjs.com/package//vue-socket.io#using-socketio-client-instance">vue-socket.io</a></p>
<p>参考自简书 <a href="https://www.jianshu.com/p/d509e8695850">候鸟与暖风</a></p>
<p>推荐和我一样的<a href="https://www.cnblogs.com/dreamsqin/p/12018866.html">踩坑博文</a></p>
</blockquote>
<h3 id="1-下载vue-socket-io依赖"><a href="#1-下载vue-socket-io依赖" class="headerlink" title="1. 下载vue-socket-io依赖"></a>1. 下载<code>vue-socket-io</code>依赖</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">npm install vue-<span class="built_in">socket</span>.io <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<h3 id="2-引入到vue-cli项目中"><a href="#2-引入到vue-cli项目中" class="headerlink" title="2. 引入到vue-cli项目中"></a>2. 引入到vue-cli项目中</h3><p>引入的方式有两种情形，一种<code>固定地址</code>，一种动态地址</p>
<h4 id="a-第一种情景"><a href="#a-第一种情景" class="headerlink" title="a.第一种情景"></a>a.第一种情景</h4><p><strong>webSocket连接的地址是固定的</strong></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在main.js中直接这样写</span></span><br><span class="line"><span class="keyword">import</span> VueSocketIO <span class="keyword">from</span> <span class="string">&#x27;vue-socket.io&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(<span class="keyword">new</span> VueSocketIO(&#123;</span><br><span class="line">  debug: <span class="keyword">true</span>,</span><br><span class="line">  connection: <span class="string">&#x27;ws://192.168.21.109:9099?storeId=1&#x27;</span>, </span><br><span class="line">  vuex: &#123;       <span class="comment">// 不需要用到vuex这个可以不加</span></span><br><span class="line">    store,</span><br><span class="line">    actionPrefix: <span class="string">&#x27;SOCKET_&#x27;</span>,</span><br><span class="line">    mutationPrefix: <span class="string">&#x27;SOCKET_&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>原博主还提到：连接方式很多直接在main.js中如下这样写：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">import VueSocketio from <span class="string">&#x27;vue-socket.io&#x27;</span>; </span><br><span class="line">Vue.use(VueSocketio, <span class="string">&#x27;http://socketserver.com:1923&#x27;</span>);      </span><br><span class="line"> <span class="regexp">//</span>*******这种方法我试了，我这边不行\**\*<span class="regexp">//</span>**</span><br></pre></td></tr></table></figure>

<h4 id="b-第二种情形"><a href="#b-第二种情形" class="headerlink" title="b.第二种情形"></a>b.第二种情形</h4><p><strong>webSocket连接的地址的是动态的，是后台通过接口传给我们的</strong></p>
<p><img data-src="bg202009053.png"></p>
<p><strong>这里要提示的一点就是，当连接的地址是动态的，代码的执行顺序就很重要了，即new VueSocket在main.js中的位置</strong></p>
<h3 id="3-在mounted中执行connect"><a href="#3-在mounted中执行connect" class="headerlink" title="3. 在mounted中执行connect"></a>3. 在mounted中执行connect</h3><h4 id="a-当socket地址是静态的写法"><a href="#a-当socket地址是静态的写法" class="headerlink" title="a.当socket地址是静态的写法"></a>a.当socket地址是静态的写法</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">mounted</span><span class="params">()</span></span>&#123;</span><br><span class="line"> this.<span class="variable">$socket</span>.emit(<span class="string">&#x27;connect&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="b-当socket地址是动态的"><a href="#b-当socket地址是动态的" class="headerlink" title="b.当socket地址是动态的"></a>b.当socket地址是动态的</h4><p>因为此时的socket连接地址是动态的，就会存在请求响应然后渲染的时间，这个时候就会出现socket还没渲染成功就执行了App.vue，这时候connect连接事件就不会触发，所以采用定时器的方法来执行connect</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line"> var timerOne = <span class="built_in">window</span>.<span class="built_in">setInterval</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.$socket) &#123;</span><br><span class="line">       <span class="built_in">this</span>.$socket.emit(<span class="string">&#x27;connect&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">       <span class="built_in">window</span>.<span class="built_in">clearInterval</span>(timerOne)</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;, <span class="number">500</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="4-推送消息给后台，连接socket"><a href="#4-推送消息给后台，连接socket" class="headerlink" title="4. 推送消息给后台，连接socket"></a>4. 推送消息给后台，连接socket</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    export <span class="keyword">default</span> &#123;</span><br><span class="line">        <span class="keyword">data</span>() &#123;</span><br><span class="line">            id: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            <span class="comment">//触发socket连接</span></span><br><span class="line">            <span class="keyword">this</span>.$socket.emit(<span class="string">&#x27;login&#x27;</span>, loginId);       </span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        sockets: &#123;</span><br><span class="line">            connect() &#123;</span><br><span class="line">                <span class="keyword">this</span>.id = <span class="keyword">this</span>.$socket.id;</span><br><span class="line">                <span class="comment">//监听connect事件</span></span><br><span class="line">                <span class="keyword">this</span>.$socket.emit(<span class="string">&#x27;login&#x27;</span>, loginId);      </span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">//监听message事件，方法是后台定义和提供的</span></span><br><span class="line">            message(<span class="keyword">data</span>) &#123;                                 </span><br><span class="line">                console.log(<span class="keyword">data</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">          methods: &#123;</span><br><span class="line">               <span class="comment">//添加按钮事件向服务端发送数据</span></span><br><span class="line">            clickButton: function(<span class="keyword">val</span>)&#123;                      </span><br><span class="line">                <span class="keyword">this</span>.$socket.emit(<span class="string">&#x27;emit_method&#x27;</span>, <span class="keyword">val</span>);</span><br><span class="line">           &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><img data-src="bg202009054.png"></p>
<h3 id="5-socket连接成功"><a href="#5-socket连接成功" class="headerlink" title="5. socket连接成功"></a>5. socket连接成功</h3><p>因为我们在 <code>new VueSocketIO</code>中开启了<code>debug: true</code>，就会在控制台中出现那些蓝色<code>debug信息</code>，来帮助我们调试socket</p>
<blockquote>
<p><strong>注意</strong>：如果蓝色的字中，没有包含我们在socket中定义的事件（connect、users、reconnect……），那就可能是我们在main,js中创建的new VueSocketIO渲染时间有问题,这个时候，connect事件也不会执行</p>
</blockquote>
<h3 id="6-后台定义的事件"><a href="#6-后台定义的事件" class="headerlink" title="6. 后台定义的事件"></a>6. 后台定义的事件</h3><blockquote>
<p>如图上所示user、transferMessage这些名词，都是后台自定义的，每个项目中可能都会有所不同，我们接受消息的事件就是靠后台来告诉我们的</p>
</blockquote>
<p><strong>vue-socket.io中自带的几个事件</strong> </p>
<blockquote>
<p>connect:查看socket是否渲染成功 </p>
<p>disconnect:检测socket断开连接 </p>
<p>reconnect:重新连接socket事件</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>框架与工具</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue常见打脸小问题</title>
    <url>/2020/09/09/vue-FAQ/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>这篇文章汇总使用<code>vue</code>的过程中遇到的小问题</p>
<p>–  获取地址参数</p>
<p>–  实现一段时间请求一次接口</p>
<p>–  Vue <code>v-loading</code> 加载</p>
<p>–  Vue 模拟事件</p>
<p>–  Vue 中使用定时器</p>
<p>–  Vue 中的修饰符</p>
<p>–  在 <code>vue</code> 中集成其他库</p>
<p>–  Vue 中导出文件：<code>get &amp; post</code></p>
</blockquote>
<a id="more"></a>

<h2 id="一、获取地址参数"><a href="#一、获取地址参数" class="headerlink" title="一、获取地址参数"></a>一、获取地址参数</h2><h3 id="1-1-使用路由获取页面参数"><a href="#1-1-使用路由获取页面参数" class="headerlink" title="1.1 使用路由获取页面参数"></a>1.1 使用路由获取页面参数</h3><p><strong>在路由中设置</strong><code>path</code>：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">path</span>: <span class="string">&#x27;/detail/:id/&#x27;</span>,</span><br><span class="line">    <span class="attribute">name</span>: <span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">    <span class="attribute">component</span>: detail,</span><br><span class="line">    <span class="attribute">meta</span>: &#123;</span><br><span class="line">        <span class="attribute">title</span>: <span class="string">&#x27;详情&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取参数</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span><span class="built_in"> id</span> = this.<span class="variable">$route</span>.params<span class="built_in">.id</span></span><br></pre></td></tr></table></figure>

<p><strong>备注:</strong> </p>
<p>1、参数名需要保持一致 </p>
<p>2、如果路由中没有传参（<a href="http://192.168.1.12:8080/#/detail%EF%BC%89%EF%BC%8C%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E9%A1%B5%E9%9D%A2%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%EF%BC%8C%E6%AD%A3%E5%B8%B8%E9%A1%B5%E9%9D%A2%E4%B8%BA">http://192.168.1.12:8080/#/detail），会报错，页面无法显示，正常页面为</a> <a href="http://192.168.1.12:8080/#/detail/234">http://192.168.1.12:8080/#/detail/234</a></p>
<p><strong>如果有的参数可传可不传</strong>    传参例如：<a href="http://192.168.1.12:8080/#/detail/?id=123">http://192.168.1.12:8080/#/detail/?id=123</a>    </p>
<p>获取的时候：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span><span class="built_in"> id</span> = this.<span class="variable">$route</span>.query<span class="built_in">.id</span></span><br></pre></td></tr></table></figure>

<p>这样即使取不到参数，页面也不会报错</p>
<h3 id="1-2-使用Js获取页面参数-–-Location-href"><a href="#1-2-使用Js获取页面参数-–-Location-href" class="headerlink" title="1.2 使用Js获取页面参数 – Location.href"></a>1.2 使用Js获取页面参数 – Location.href</h3><p>如果是在普通js文件中，想获取url后面的参数，可以新建一个工具类，utils.js：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* eslint-disable */</span></span><br><span class="line"><span class="selector-tag">export</span> <span class="selector-tag">default</span>&#123;</span><br><span class="line">    <span class="attribute">getUrlKey</span>: function (name) &#123;</span><br><span class="line">        return <span class="built_in">decodeURIComponent</span>((new RegExp(<span class="string">&#x27;[?|&amp;]&#x27;</span> + name + <span class="string">&#x27;=&#x27;</span> + <span class="string">&#x27;([^&amp;;]+?)(&amp;|#|;|$)&#x27;</span>).<span class="built_in">exec</span>(location.href) || [, <span class="string">&quot;&quot;</span>])[<span class="number">1</span>].<span class="built_in">replace</span>(/\+/g, <span class="string">&#x27;%20&#x27;</span>)) || null</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其他需要获取参数的js中引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;../../assets/scripts/utils&#x27;</span></span><br><span class="line"><span class="comment">// Vue.prototype.$utils = utils // main.js中全局引入</span></span><br><span class="line"><span class="keyword">let</span> id = utils.getUrlKey(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log()</span><br></pre></td></tr></table></figure>

<h2 id="二、实现一段时间请求一次接口（轮询）"><a href="#二、实现一段时间请求一次接口（轮询）" class="headerlink" title="二、实现一段时间请求一次接口（轮询）"></a>二、实现一段时间请求一次接口（轮询）</h2><p><strong>需要注意的一点是  <code>setTimeOut</code> 和 <code>setInterval</code> 的使用</strong></p>
<p><strong>一般都会使用setInterval，但要注意单纯使用它会导致页面卡死</strong></p>
<p>解决方法如下：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.<span class="built_in">setInterval</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(fun, <span class="number">0</span>)</span><br><span class="line">&#125;, <span class="number">30000</span>)</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：<code>setInterval</code>不会清除定时器队列，每重复执行1次都会导致定时器叠加，最终卡死你的网页。<br>但是<code>setTimeout</code>是自带清除定时器的</p>
<h4 id="下面是我使用的方法："><a href="#下面是我使用的方法：" class="headerlink" title="下面是我使用的方法："></a>下面是我使用的方法：</h4><p>在<code>mounted</code>中调用</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.$socket.emit(<span class="string">&#x27;connect&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">this</span>.$socket.emit(<span class="string">&#x27;LIST_EVENT&#x27;</span>, &#123;</span><br><span class="line">   type: <span class="number">1</span>,</span><br><span class="line">   storeId: <span class="keyword">this</span>.storeId,</span><br><span class="line">   <span class="keyword">data</span>: &#123;&#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.getListData();</span><br><span class="line">  <span class="keyword">this</span>.updatedData();</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p><code>updateData()</code>中定义了轮询</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="attribute">methods</span>: &#123;</span><br><span class="line"></span><br><span class="line">  updatedData() &#123;</span><br><span class="line">   setInterval(()=&gt;&#123;</span><br><span class="line">     setTimeout(this.getListData, 0)</span><br><span class="line">   &#125;, 180000);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  getListData() &#123;</span><br><span class="line">   this.$socket.emit(&#x27;LIST_EVENT&#x27;, &#123;</span><br><span class="line">     type: 3,</span><br><span class="line">     storeId: this.storeId,</span><br><span class="line">     data: &#123;&#125;</span><br><span class="line">   &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="三、Vue-v-loading-加载"><a href="#三、Vue-v-loading-加载" class="headerlink" title="三、Vue v-loading 加载"></a>三、Vue <code>v-loading</code> 加载</h2><p>使用<code>v-loading</code>在接口为请求到数据之前，显示加载中，直到请求到数据后消失。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局loading</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div v-loading=<span class="string">&quot;loading&quot;</span>&gt; &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<p>在data 中定义初始化， <code>loading: false</code>，同时在<code>mounted()</code>中将 <code>this.loading</code>设置为true,再去请求接口</p>
<p>在接口的回调函数中，将 <code>this.loading</code> 设为<code>false</code>，到达效果。</p>
<p>如果写在<code>template</code>下的顶层元素上的话，就不会触发全屏<code>loading</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部loading</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt; </span><br><span class="line">        &lt;section v-loading=<span class="string">&quot;loading&quot;</span>&gt;&lt;/section&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="四、Vue中的事件"><a href="#四、Vue中的事件" class="headerlink" title="四、Vue中的事件"></a>四、Vue中的事件</h2><h3 id="1、Vue-键盘事件"><a href="#1、Vue-键盘事件" class="headerlink" title="1、Vue 键盘事件"></a>1、Vue 键盘事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@keydown（键盘按下时触发）</span><br><span class="line">@keypress(键盘按住时触发)</span><br><span class="line">@keyup(键盘弹起)</span><br></pre></td></tr></table></figure>

<p>获取按键的键码 <code>e.keyCode</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@keyup<span class="number">.13</span>   按回车键</span><br><span class="line">@keyup.enter 回车</span><br><span class="line">@keyup.up   上键</span><br><span class="line">@keyup.down  下键</span><br><span class="line">@keyup.left   左键</span><br><span class="line">@keyup.right   右键</span><br><span class="line">@keyup.delete   删除键</span><br></pre></td></tr></table></figure>

<h4 id="input事件"><a href="#input事件" class="headerlink" title="@input事件"></a>@input事件</h4><p>input 事件 结合了 keyup事件 和 change事件, 会在 keyup 时判断值是否发生变化, 变化了则触发该事件</p>
<h3 id="2、模拟事件"><a href="#2、模拟事件" class="headerlink" title="2、模拟事件"></a>2、模拟事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟点击事件</span></span><br><span class="line"><span class="built_in">this</span>.$refs.refName.$el.click();</span><br><span class="line"><span class="comment">// 模拟失去焦点事件</span></span><br><span class="line"><span class="built_in">this</span>.$refs.refName.blur();</span><br></pre></td></tr></table></figure>

<h4 id="获取焦点"><a href="#获取焦点" class="headerlink" title="获取焦点"></a>获取焦点</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input v-model&#x3D;&quot;inputvalue&quot;  ref&#x3D;&quot;inputVal&quot;&#x2F;&gt;</span><br><span class="line">&lt;button @click&#x3D;&quot;addItem&quot;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script&gt;</span><br><span class="line"> var todolistApp &#x3D; new Vue(&#123;</span><br><span class="line">     el:&#39;#todolistHome&#39;,</span><br><span class="line">     data:&#123;</span><br><span class="line">         inputvalue:&quot;&quot;,</span><br><span class="line">         list:[],</span><br><span class="line">         picFocusStatus: true</span><br><span class="line">     &#125;,</span><br><span class="line">     methods:&#123;</span><br><span class="line">         addItem:function()&#123;</span><br><span class="line">             &#x2F;&#x2F;然后调用focus方法</span><br><span class="line">             this.$nextTick(() &#x3D;&gt;&#123;</span><br><span class="line">                 this.$refs.inputVal.focus()</span><br><span class="line">             &#125;)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;)</span><br><span class="line"> &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="五、-Vue中使用定时器"><a href="#五、-Vue中使用定时器" class="headerlink" title="五、 Vue中使用定时器"></a>五、 Vue中使用定时器</h2><p>Js中定时器有两种，一个是循环执行<strong>setInterval</strong>，另一个是定时执行<strong>setTimeout</strong></p>
<p><strong>要注意：在页面销毁的时候清除掉</strong></p>
<h3 id="1、循环执行（setInterval）"><a href="#1、循环执行（setInterval）" class="headerlink" title="1、循环执行（setInterval）"></a>1、循环执行（setInterval）</h3><p>顾名思义，循环执行就是设置一个时间间隔，每过一段时间都会执行一次这个方法,直到这个定时器被销毁掉</p>
<p>用法是<strong>setInterval</strong>（“方法名或方法”，“延时”）， 第一个参数为方法名或者方法，注意为方法名的时候不要加括号,第二个参数为时间间隔</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;h1&gt;hello world~&lt;/h1&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        timer: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        value: <span class="number">0</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        <span class="built_in">this</span>.value ++;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="built_in">this</span>.timer = <span class="built_in">setInterval</span>(<span class="built_in">this</span>.get, <span class="number">1000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line">      <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="2、定时执行（setTimeout）"><a href="#2、定时执行（setTimeout）" class="headerlink" title="2、定时执行（setTimeout）"></a>2、定时执行（setTimeout）</h3><p>定时执行<strong>setTimeout</strong>是设置一个时间，等待时间到达的时候只执行一次，但是执行完以后定时器还在，只是没有运行</p>
<p>用法是<strong>setTimeout</strong>(“方法名或方法”, “延时”); 第一个参数为方法名或者方法，注意为方法名的时候不要加括号,第二个参数为时间间隔</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;section&gt;</span><br><span class="line">    &lt;h1&gt;hello world~&lt;/h1&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        timer: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        value: <span class="number">0</span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        <span class="built_in">this</span>.value ++;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      <span class="built_in">this</span>.timer = <span class="built_in">setTimeout</span>(<span class="built_in">this</span>.get, <span class="number">1000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy() &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3、在-promise-中使用-setTimeout"><a href="#3、在-promise-中使用-setTimeout" class="headerlink" title="3、在 promise 中使用 setTimeout"></a>3、在 <code>promise</code> 中使用 <code>setTimeout</code></h3><p>先看下面两对代码的区别：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve(<span class="string">&#x27;hello&#x27;</span>), <span class="number">2000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 立马输出 hello</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// code2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, <span class="number">2000</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 2s后输出hello</span></span><br></pre></td></tr></table></figure>

<p>这个差异就是 <strong><code>func()</code> 和 <code>func</code> 的区别，<code>setTimeout</code> 的第一个参数是 <code>func</code>，如果用 <code>func()</code> 相当于其返回值为第一个参数</strong></p>
<p>这个地方应该是一个函数 <code>func</code> ，如果你传的是 <code>func()</code> ，代码解析器执行到此处的时候，就会立即执行这个函数，起不到延时的效果了</p>
<h4 id="常见的使用场景"><a href="#常见的使用场景" class="headerlink" title="常见的使用场景"></a>常见的使用场景</h4><p><strong>实现一个 sleep 函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1s 后执行的代码</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里写你的操作</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码延时</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">time</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, time))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">sleepAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> res = <span class="keyword">await</span> sleep(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleepAsync()</span><br></pre></td></tr></table></figure>

<h2 id="六、Vue-中的修饰符"><a href="#六、Vue-中的修饰符" class="headerlink" title="六、Vue 中的修饰符"></a>六、Vue 中的修饰符</h2><h3 id="native-修饰符"><a href="#native-修饰符" class="headerlink" title=".native 修饰符"></a><code>.native</code> 修饰符</h3><p>在某个组件的根元素上监听一个原生事件。可以使用 <code>v-on</code> 的修饰符 <code>.native</code> </p>
<p><strong>通俗点讲</strong>：就是在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加’. native’事件是无法触发的。</p>
<p>可以理解为该修饰符的作用就是把一个vue组件转化为一个普通的HTML标签，并且该修饰符对普通HTML标签是没有任何作用的。</p>
<h3 id="stop-修饰符"><a href="#stop-修饰符" class="headerlink" title=".stop 修饰符"></a><code>.stop</code> 修饰符</h3><p>可以用来<strong>阻止冒泡事件的发生</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="v-model的修饰符"><a href="#v-model的修饰符" class="headerlink" title="v-model的修饰符"></a><code>v-model</code>的修饰符</h3><h4 id="1、-lazy-修饰符"><a href="#1、-lazy-修饰符" class="headerlink" title="1、.lazy 修饰符"></a>1、<code>.lazy </code>修饰符</h4><p>v-model 指令默认会在 input 事件中加载输入框中的数据（中文输入法中输入拼音的过程除外）。我们可以使用 <code>.lazy</code> 懒加载修饰符，让其只在 change 事件中再加载输入框中的数据。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// html：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;content&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入&quot;</span> <span class="attr">value</span>=<span class="string">&quot;初始值&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>输入框：&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js</span></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>效果：<img data-src="xiushifu-lazy.webp"></p>
<p>使用 <code>.lazy</code> 懒加载修饰符之后，只有在输入框失去焦点或者按回车键时才会更新 content 值</p>
<h4 id="2、-number-修饰符"><a href="#2、-number-修饰符" class="headerlink" title="2、.number 修饰符"></a>2、<code>.number</code> 修饰符</h4><p>输入框输入的内容，即使是数字，默认也是 string 类型</p>
<p>在此，我们可以使用 <code>.number</code> 修饰符让其转换为 number 类型——</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// html：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;content&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>输入值：&#123;&#123;content&#125;&#125;，输入类型：&#123;&#123;typeof content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js：</span></span><br><span class="line"><span class="keyword">var</span> app2 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app2&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        content: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>问题</strong>：表单验证正则匹配数字，但输入汉字仍然通过</p>
<p><strong>原因</strong>：<code>.numbe</code>r会将input里的值用<code>parseFloat()</code>转化，这样用正则匹配数字后，输入的即使是：<code>123四五六</code>；也不会报错，因为<code>123四五六</code>被转换成了<code>123</code></p>
</blockquote>
<h4 id="3、-trim-修饰符"><a href="#3、-trim-修饰符" class="headerlink" title="3、.trim 修饰符"></a>3、<code>.trim</code> 修饰符</h4><p>使用 ·.trim` 修饰符可以自动过滤掉输入框的首尾空格。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// html：</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;content&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入&quot;</span> <span class="attr">value</span>=<span class="string">&quot;初始值&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>输入框：&#123;&#123;content&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js：</span></span><br><span class="line"><span class="keyword">var</span> app3 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#app3&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        content: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="七、在-vue-中集成其他库"><a href="#七、在-vue-中集成其他库" class="headerlink" title="七、在 vue 中集成其他库"></a>七、在 <code>vue</code> 中集成其他库</h2><h3 id="1、引入-font-awesome"><a href="#1、引入-font-awesome" class="headerlink" title="1、引入 font-awesome"></a>1、引入 font-awesome</h3><h4 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">npm install font-awesome --save</span><br></pre></td></tr></table></figure>

<p> 在入口 <code>js</code> 引入</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">import  <span class="string">&#x27;font-awesome/css/font-awesome.min.css&#x27;</span> </span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-camera-retro&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="字体文件引入"><a href="#字体文件引入" class="headerlink" title="字体文件引入"></a>字体文件引入</h4><p>从官网下载了相应的字体文件，并放置在项目目录里</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="attribute">font-family</span>: <span class="string">&#x27;FontAwesome&#x27;</span>;</span><br><span class="line"> <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;./fonts/fontawesome-webfont.eot?v=4.2.0&#x27;</span>);</span><br><span class="line"> <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;./fonts/fontawesome-webfont.eot?#iefix&amp;v=4.2.0&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>), <span class="built_in">url</span>(<span class="string">&#x27;./fonts/fontawesome-webfont.woff?v=4.2.0&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>), <span class="built_in">url</span>(<span class="string">&#x27;./fonts/fontawesome-webfont.ttf?v=4.2.0&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>), <span class="built_in">url</span>(<span class="string">&#x27;./fonts/fontawesome-webfont.svg?v=4.2.0#fontawesomeregular&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="attribute">font-weight</span>: normal;</span><br><span class="line"> <span class="attribute">font-style</span>: normal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fa</span> &#123;</span><br><span class="line">     <span class="attribute">display</span>: inline-block;</span><br><span class="line">     <span class="attribute">font</span>: normal normal normal <span class="number">14px</span>/<span class="number">1</span> FontAwesome;</span><br><span class="line">     <span class="attribute">font-size</span>: inherit;</span><br><span class="line">     <span class="attribute">text-rendering</span>: auto;</span><br><span class="line">     <span class="attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">     <span class="attribute">-moz-osx-font-smoothing</span>: grayscale</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另外，发现了一种解决 <code>&lt;i class=&quot;fa fa-xxx&quot;&gt;&lt;/i&gt;</code> 不能正确显示相应图标的解决方法</strong></p>
<p>如下例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.fa-user</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">     <span class="attribute">content</span>: <span class="string">&quot;\f007&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fa-edit</span><span class="selector-pseudo">:before</span>,<span class="selector-class">.fa-pencil-square-o</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;\f044&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.fa-sign-out</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">     <span class="attribute">content</span>: <span class="string">&quot;\f08b&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="font-awesome.png"></p>
<h3 id="2、引入-Lodash"><a href="#2、引入-Lodash" class="headerlink" title="2、引入 Lodash"></a>2、引入 Lodash</h3><blockquote>
<p>参考 <a href="https://www.jianshu.com/p/907e8a0ee5d7">简书</a></p>
</blockquote>
<p><strong>安装</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">npm i lodash -S</span><br></pre></td></tr></table></figure>

<p><strong>引入及使用——方法一</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> lodash <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面中</span></span><br><span class="line"><span class="keyword">import</span> &#123; cloneDeep &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>引入及使用——方法二</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line">Vue.prototype._ = _</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="built_in">this</span>._.debounce(<span class="built_in">this</span>.handleClick,<span class="number">1000</span>,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p><strong>引入及使用——方法三</strong></p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line">let <span class="literal">_</span> = require(<span class="string">&#x27;lodash&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="literal">_</span>.debounce(<span class="built_in">this</span>.handleClick,<span class="number">1000</span>,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3、引入-Axios"><a href="#3、引入-Axios" class="headerlink" title="3、引入 Axios"></a>3、引入 Axios</h3><p><strong>安装</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> axios <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p><strong>引入</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在使用时引入axios，下面再 http.js 中引入</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以全局注册依赖</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> ‘axios’</span><br><span class="line">Vue.prototype.$axios = axios</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局注册，使用方法为: this.$axios</span></span><br></pre></td></tr></table></figure>



<br>

<h2 id="八、Vue-中导出文件-get-amp-post"><a href="#八、Vue-中导出文件-get-amp-post" class="headerlink" title="八、Vue 中导出文件 get&amp;post"></a>八、Vue 中导出文件 <code>get&amp;post</code></h2><p>导出文件最简单的方式就是 get 请求，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">toDownload() &#123;</span><br><span class="line">    <span class="built_in">window</span>.open(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.serverUrl&#125;</span>/report/downloadReportTemplate`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>post</code> 请求的如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">exportReport(index) &#123;</span><br><span class="line">    <span class="built_in">this</span>.$http.post.exportReportPost(<span class="built_in">this</span>.tableData[index].id, &#123;</span><br><span class="line">        responseType: <span class="string">&#x27;blob&#x27;</span></span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(&#x27;响应状态&#x27;, res);</span></span><br><span class="line">        <span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([res], &#123;<span class="attr">type</span>: <span class="string">&quot;application/force-download&quot;</span>&#125;)</span><br><span class="line">        <span class="comment">// console.log(blob);</span></span><br><span class="line">        <span class="keyword">let</span> fileReader = <span class="keyword">new</span> FileReader();</span><br><span class="line">        fileReader.readAsDataURL(blob);</span><br><span class="line">        fileReader.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">            a.download = <span class="string">`检测明细.xlsx`</span>;</span><br><span class="line">            a.href = e.target.result;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(a);</span><br><span class="line">            a.click();</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>框架与工具</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>在Vue-Swiper里踩过的坑</title>
    <url>/2020/09/05/about-Swiper/</url>
    <content><![CDATA[<h2 id="问题缘起"><a href="#问题缘起" class="headerlink" title="问题缘起"></a>问题缘起</h2><blockquote>
<p>在<code>vue</code>中使用<code>vue-awesome-swiper</code>的时候，踩坑无数，快爬不起来要哭了</p>
<p>算是小问题却搞一下午，心态都崩了呀！</p>
</blockquote>
<a id="more"></a>

<h2 id="一、关于Swiper"><a href="#一、关于Swiper" class="headerlink" title="一、关于Swiper"></a>一、关于Swiper</h2><blockquote>
<p><a href="https://www.swiper.com.cn/">Swiper官网</a></p>
</blockquote>
<blockquote>
<p><strong>Swiper常用于移动端网站的内容触摸滑动</strong></p>
<p><strong>Swiper</strong>是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。</p>
<p><strong>Swiper</strong>能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。</p>
<p><strong>Swiper</strong>开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！</p>
</blockquote>
<h2 id="二、Vue-awesome-swiper"><a href="#二、Vue-awesome-swiper" class="headerlink" title="二、Vue-awesome-swiper"></a>二、Vue-awesome-swiper</h2><blockquote>
<p><a href="https://github.com/surmon-china/vue-awesome-swiper">github传送门/走好</a></p>
</blockquote>
<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install </span><span class="keyword">swiper </span>vue-awesome-<span class="keyword">swiper </span>--save</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">yarn <span class="keyword">add </span><span class="keyword">swiper </span>vue-awesome-<span class="keyword">swiper</span></span><br></pre></td></tr></table></figure>

<h3 id="Global-Registration"><a href="#Global-Registration" class="headerlink" title="Global Registration"></a>Global Registration</h3><figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueAwesomeSwiper <span class="keyword">from</span> <span class="string">&#x27;vue-awesome-swiper&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// import style</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;swiper/css/swiper.css&#x27;</span></span><br><span class="line"><span class="comment">// If you use Swiper 6.0.0 or higher</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;swiper/swiper-bundle.css&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueAwesomeSwiper, <span class="comment">/* &#123; default options with global component &#125; */</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Local-Registration"><a href="#Local-Registration" class="headerlink" title="Local Registration"></a>Local Registration</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Swiper, SwiperSlide, directive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-awesome-swiper&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;swiper/css/swiper.css&#x27;</span></span><br><span class="line"><span class="comment">// If you use Swiper 6.0.0 or higher</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;swiper/swiper-bundle.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Swiper,</span><br><span class="line">    SwiperSlide</span><br><span class="line">  &#125;,</span><br><span class="line">  directives: &#123;</span><br><span class="line">    swiper: directive</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;path/to/swiper.css&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/swiper.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/dist/vue-awesome-swiper.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  Vue.use(<span class="built_in">window</span>.VueAwesomeSwiper)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Difference-with-usage"><a href="#Difference-with-usage" class="headerlink" title="Difference with usage"></a>Difference with usage</h3><p><strong>Directive and the only difference in the use of the Component:</strong></p>
<ul>
<li><code>component</code> find Swiper instance by <a href="https://vuejs.org/v2/guide/components-edge-cases.html#Accessing-Child-Component-Instances-amp-Child-Elements"><code>ref attribute</code></a>.</li>
<li><code>directive</code> find Swiper instance by <a href="https://vuejs.org/v2/guide/custom-directive.html#Dynamic-Directive-Arguments"><code>directive arg</code></a>.</li>
</ul>
<p>Other configurations, events are the same.</p>
<p>The effect of the two ways and the difference in the applicable environment <a href="https://github.com/surmon-china/surmon-china.github.io/blob/source/projects/vue-awesome-swiper/nuxt/">is here</a>.</p>
<h3 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">ref</span>=<span class="string">&quot;mySwiper&quot;</span> <span class="attr">:options</span>=<span class="string">&quot;swiperOptions&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>Slide 1<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>Slide 2<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>Slide 3<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>Slide 4<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span>&gt;</span>Slide 5<span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;swiper-pagination&quot;</span> <span class="attr">slot</span>=<span class="string">&quot;pagination&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;carrousel&#x27;</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        swiperOptions: &#123;</span><br><span class="line">          pagination: &#123;</span><br><span class="line"><span class="javascript">            el: <span class="string">&#x27;.swiper-pagination&#x27;</span></span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="javascript">          <span class="comment">// Some Swiper option/callback...</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      swiper() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.$refs.mySwiper.$swiper</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;Current Swiper instance object&#x27;</span>, <span class="built_in">this</span>.swiper)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.swiper.slideTo(<span class="number">3</span>, <span class="number">1000</span>, <span class="literal">false</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Directive"><a href="#Directive" class="headerlink" title="Directive"></a>Directive</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-swiper:mySwiper</span>=<span class="string">&quot;swiperOption&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;swiper-wrapper&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;swiper-slide&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;banner&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;banner in banners&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;banner&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;swiper-pagination&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    data () &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        banners: [ <span class="string">&#x27;/1.jpg&#x27;</span>, <span class="string">&#x27;/2.jpg&#x27;</span>, <span class="string">&#x27;/3.jpg&#x27;</span> ],</span></span><br><span class="line">        swiperOption: &#123;</span><br><span class="line">          pagination: &#123;</span><br><span class="line"><span class="javascript">            el: <span class="string">&#x27;.swiper-pagination&#x27;</span></span></span><br><span class="line">          &#125;,</span><br><span class="line"><span class="javascript">          <span class="comment">// ...</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;Current Swiper instance object&#x27;</span>, <span class="built_in">this</span>.mySwiper)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.mySwiper.slideTo(<span class="number">3</span>, <span class="number">1000</span>, <span class="literal">false</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Swiper-component-API"><a href="#Swiper-component-API" class="headerlink" title="Swiper component API"></a>Swiper component API</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">&lt;!-- All events/props support camelCase or kebab-<span class="keyword">case</span>. --&gt;</span><br><span class="line">&lt;swiper</span><br><span class="line">  :options=<span class="string">&quot;swiperOptionsObject&quot;</span></span><br><span class="line">  :auto-update=<span class="string">&quot;true&quot;</span></span><br><span class="line">  :auto-destroy=<span class="string">&quot;true&quot;</span></span><br><span class="line">  :<span class="keyword">delete</span>-instance-on-destroy=<span class="string">&quot;true&quot;</span></span><br><span class="line">  :cleanup-styles-on-destroy=<span class="string">&quot;true&quot;</span></span><br><span class="line">  <span class="meta">@ready</span>=<span class="string">&quot;handleSwiperReadied&quot;</span></span><br><span class="line">  <span class="meta">@click</span>-slide=<span class="string">&quot;handleClickSlide&quot;</span></span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- vue-awesome-swiper converts all Swiper events into component/directive events, e.g.: --&gt;</span><br><span class="line">&lt;swiper</span><br><span class="line">  <span class="meta">@slide</span>-change-transition-start=<span class="string">&quot;onSwiperSlideChangeTransitionStart&quot;</span></span><br><span class="line">  <span class="meta">@slideChangeTransitionStart</span>=<span class="string">&quot;onSwiperSlideChangeTransitionStart&quot;</span></span><br><span class="line">  <span class="meta">@slideChangeTransitionEnd</span>=<span class="string">&quot;...&quot;</span></span><br><span class="line">  <span class="meta">@transitionStart</span>=<span class="string">&quot;...&quot;</span></span><br><span class="line">  ...</span><br><span class="line">/&gt;</span><br><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">  <span class="comment">// Auto update swiper when vue component `updated`</span></span><br><span class="line">  autoUpdate?: <span class="built_in">boolean</span> <span class="comment">// default: true</span></span><br><span class="line">  <span class="comment">// Auto destroy swiper when vue component &#x27;beforeDestroy&#x27;</span></span><br><span class="line">  autoDestroy?: <span class="built_in">boolean</span> <span class="comment">// default: true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// swiper.destroy&#x27;s params</span></span><br><span class="line">  <span class="comment">// swiper.destroy(deleteInstanceOnDestroy, cleanupStylesOnDestroy)</span></span><br><span class="line">  deleteInstanceOnDestroy?: <span class="built_in">boolean</span> <span class="comment">// default: true</span></span><br><span class="line">  cleanupStylesOnDestroy?: <span class="built_in">boolean</span> <span class="comment">// default: true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `@ready` event will emit when the Swiper instance mounted</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleSwiperReadied</span>(<span class="params">swiper: Swiper</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Swiper was munted!&#x27;</span>, swiper)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `@click-slide` event has special treatment for Swiper&#x27;s loop mode, which is still available in loop mode</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClickSlide</span>(<span class="params">index: <span class="built_in">number</span>, reallyIndex: <span class="built_in">number</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Click slide!&#x27;</span>, index, reallyIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swiper-directive-API"><a href="#Swiper-directive-API" class="headerlink" title="Swiper directive API"></a>Swiper directive API</h3><p>Based on the exact same as the component API.</p>
<p>In the <code>directive</code> mode, the Swiper instance will be mounted in the parent’s component context use the default name<code>$swiper</code>. In order to implement multiple swipers in a context, the <code>directive</code> has an additional name called <code>instanceName</code> API, through this API, you can easily control the name of each swiper mount context.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;div v-swiper=<span class="string">&quot;swiperOptionsObject&quot;</span> /&gt;</span><br><span class="line">&lt;div v-swiper:secondSwiper=<span class="string">&quot;swiperOptionsObject&quot;</span> /&gt;</span><br><span class="line">&lt;div v-swiper:[dynamicSwiperName]=<span class="string">&quot;swiperOptionsObject&quot;</span> /&gt;</span><br><span class="line">&lt;div v-swiper=<span class="string">&quot;swiperOptionsObject&quot;</span> instance-name=<span class="string">&quot;fourthSwiper&quot;</span> /&gt;</span><br><span class="line">export dafault &#123;</span><br><span class="line">  <span class="keyword">data</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      dynamicSwiperName: <span class="string">&#x27;thirdSwiper&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;Swiper instances:&#x27;</span>, <span class="keyword">this</span>.$swiper, <span class="keyword">this</span>.secondSwiper, <span class="keyword">this</span>.thirdSwiper, <span class="keyword">this</span>.fourthSwiper)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Swiper-API"><a href="#Swiper-API" class="headerlink" title="Swiper API"></a>Swiper API</h3><p>Swiper’s API and configuration can be used.</p>
<ul>
<li><a href="https://swiperjs.com/api/#events">EN Swiper events</a></li>
<li><a href="https://swiperjs.com/api/">EN Swiper documentation</a></li>
<li><a href="https://www.swiper.com.cn/api/index.html">ZH Swiper documentation</a></li>
</ul>
<h3 id="三、巨坑盘点（让我想报复SOCIAL）"><a href="#三、巨坑盘点（让我想报复SOCIAL）" class="headerlink" title="三、巨坑盘点（让我想报复SOCIAL）"></a>三、巨坑盘点（让我想报复<code>SOCIAL</code>）</h3><h4 id="1-Swiper滚动失效"><a href="#1-Swiper滚动失效" class="headerlink" title="1. Swiper滚动失效"></a>1. Swiper滚动失效</h4><p>对于这个问题，我的理解是：<code>swiper</code>使用版本为 <code>swiper@6.2.0</code>，应该是<code>vue-awesome-swiper</code>和高版本<code>swiper</code>兼容性很差很差</p>
<p><strong>解决方案：</strong></p>
<p>① 卸载已安装的<code>swiper</code>：<code>npm uninstall swiper  --save</code></p>
<p>② 安装低版本<code>swiper</code>，版本号可以去<a href="https://www.npmjs.com/package/swiper/v/6.2.0">npmjs</a>搜</p>
<p>③注意到<code>swiper6</code>的样式文件不同，需要按需引入，引入方式同上面的官方引入</p>
<h4 id="2-vue-awesome-swiper使用自动轮播和循环轮播不生效（loop和autoplay）"><a href="#2-vue-awesome-swiper使用自动轮播和循环轮播不生效（loop和autoplay）" class="headerlink" title="2. vue-awesome-swiper使用自动轮播和循环轮播不生效（loop和autoplay）"></a>2. vue-awesome-swiper使用自动轮播和循环轮播不生效（loop和autoplay）</h4><p><strong>方法一：</strong></p>
<p>在项目中使用vue-awesome-swiper如果loop和autoplay总是出现各种问题,第一次加载的时候,轮播是不动的,需要重新加载一下swiper才会轮播</p>
<p>解决方案:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//轮播设置</span></span><br><span class="line"><span class="attr">swiperOption:</span> &#123;</span><br><span class="line">　　<span class="attr">direction:</span> <span class="string">&#x27;vertical&#x27;</span>,</span><br><span class="line">　　<span class="attr">observer:</span><span class="literal">true</span>,<span class="comment">//修改swiper自己或子元素时，自动初始化swiper </span></span><br><span class="line">　　<span class="attr">observeParents:</span><span class="literal">true</span>,<span class="comment">//修改swiper的父元素时，自动初始化swiper </span></span><br><span class="line">　　<span class="attr">loop:</span><span class="literal">true</span>,</span><br><span class="line">　　<span class="attr">autoplay:</span> &#123;</span><br><span class="line">　　　　<span class="attr">delay:</span> <span class="number">2000</span>,</span><br><span class="line">　　<span class="attr">disableOnInteraction:</span> <span class="literal">false</span></span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要添加上两个属性,这样达到一个初始化swiper的目的</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">observer:</span><span class="literal">true</span>,<span class="comment">//修改swiper自己或子元素时，自动初始化swiper </span></span><br><span class="line"><span class="attr">observeParents:</span><span class="literal">true</span>,<span class="comment">//修改swiper的父元素时，自动初始化swiper </span></span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>：</p>
<p>如果说轮播数据来自于异步请求，再循环展示，有可能出现轮播失效的问题。</p>
<p><strong>原因是</strong>循环还没有完的时候swiper组件运行冲突出错导致的，在swiper组件上对数据价格v-if就可以解决。代码如下： </p>
<p><img data-src="bg202009055.png"></p>
<p><img data-src="bg202009056.png"></p>
<h4 id="3-swiper手动滑动之后自动轮播失效的解决方法"><a href="#3-swiper手动滑动之后自动轮播失效的解决方法" class="headerlink" title="3. swiper手动滑动之后自动轮播失效的解决方法"></a>3. swiper手动滑动之后自动轮播失效的解决方法</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="javascript"><span class="keyword">var</span> mySwiper = <span class="keyword">new</span> Swiper(<span class="string">&#x27;.swiper-container&#x27;</span>,&#123;</span></span><br><span class="line">  autoplay: &#123;</span><br><span class="line"><span class="javascript">    disableOnInteraction: <span class="literal">false</span>,</span></span><br><span class="line">    delay:2000,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用户操作swiper之后，是否禁止autoplay。默认为true：停止。</p>
<p>如果设置为false，用户操作swiper之后自动切换不会停止，每次都会重新启动autoplay。</p>
<p>操作包括触碰，拖动，点击pagination等。</p>
<p><strong>若不生效</strong>，问题应该依然和<code>swiper版本</code>有关。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>框架与工具</tag>
        <tag>Vue</tag>
        <tag>Vue Problems</tag>
      </tags>
  </entry>
  <entry>
    <title>重拾Vue相应式原理</title>
    <url>/2020/08/25/Retrieve-the-Vue-response-principle/</url>
    <content><![CDATA[<h2 id="问题缘起"><a href="#问题缘起" class="headerlink" title="问题缘起"></a>问题缘起</h2><p>今天接手了一个Bug，大概描述一下：</p>
<blockquote>
<p>存在一个列表和一个分页器，用的是Element-UI。</p>
<p>使用中，每次修改每页显示数据总数、换页等操作都会使用ajax异步请求新的数据。</p>
<p>问题：每次操作后，列表的渲染数据均是上一次操作的正确预期效果</p>
</blockquote>
<a id="more"></a>

<p>主要代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">        <span class="attr">v-int-pager</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">size-change</span>=<span class="string">&quot;onPagerSizeChange&quot;</span></span></span><br><span class="line"><span class="tag">        @<span class="attr">current-change</span>=<span class="string">&quot;onPagerCurrentChange&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:current-page</span>=<span class="string">&quot;pager.currentPage&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:page-sizes</span>=<span class="string">&quot;pager.chose&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:page-size</span>=<span class="string">&quot;pager.size&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">layout</span>=<span class="string">&quot;total, sizes, prev, pager, next, jumper&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">:total</span>=<span class="string">&quot;pager.total&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- /分页器 --&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 列表渲染数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-table</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">:data</span>=<span class="string">&quot;tableData&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">:border</span>=<span class="string">&quot;true&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">:stripe</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">onPagerSizeChange(size) &#123;</span><br><span class="line">   <span class="keyword">this</span>.pager.size = size;</span><br><span class="line">   <span class="keyword">this</span>.pager.currentPage = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">this</span>._getGoodsList();</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">// 切换页面</span></span><br><span class="line">onPagerCurrentChange(currentPage) &#123;</span><br><span class="line">   <span class="keyword">this</span>.pager.currentPage = currentPage;</span><br><span class="line">   <span class="keyword">this</span>._getGoodsList();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>其中，<code>this._getGoodsList()</code>为获取相应数据的异步请求，经验证后台数据均获取正确</p>
<p>所以，结论只有一个，就是异步获取数据之后，Vue 未更新 <code>Virtual DOM</code> </p>
<p>最后，发现需要渲染的数据没有加入到 <code>vm.data()</code>中，修改后问题解决。</p>
<blockquote>
<h5 id="也因此，在这里在此回顾Vue响应式原理"><a href="#也因此，在这里在此回顾Vue响应式原理" class="headerlink" title="也因此，在这里在此回顾Vue响应式原理"></a>也因此，在这里在此回顾<code>Vue</code>响应式原理</h5></blockquote>
<h2 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h2><blockquote>
<p><a href="https://cn.vuejs.org/v2/guide/reactivity.html">官方文档</a></p>
</blockquote>
<p>Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，<strong>视图会进行更新</strong>。</p>
<h3 id="如何追踪变化"><a href="#如何追踪变化" class="headerlink" title="如何追踪变化"></a>如何追踪变化</h3><p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 <code>data</code> 选项，Vue 将遍历此对象所有的 property，并使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty</code></a> 把这些 property 全部转为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters">getter/setter</a>。<code>Object.defineProperty</code> 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<p>这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。这里需要注意的是不同浏览器在控制台打印数据对象时对 getter/setter 的格式化并不同，所以建议安装 <a href="https://github.com/vuejs/vue-devtools">vue-devtools</a> 来获取对检查数据更加友好的用户界面。</p>
<p>每个组件实例都对应一个 <strong>watcher</strong> 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p>
<p><img data-src="rendering-way.png"></p>
<h3 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a><a name="content">检测变化的注意事项</a></h3><p>由于 JavaScript 的限制，Vue <strong>不能检测</strong>数组和对象的变化。尽管如此我们还是有一些办法来回避这些限制并保证它们的响应性。</p>
<h4 id="对于对象"><a href="#对于对象" class="headerlink" title="对于对象"></a>对于对象</h4><p>Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。例如：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  dat<span class="variable">a:</span>&#123;</span><br><span class="line">    <span class="variable">a:1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// `<span class="keyword">vm</span>.<span class="keyword">a</span>` 是响应式的</span><br><span class="line"></span><br><span class="line"><span class="keyword">vm</span>.<span class="keyword">b</span> = <span class="number">2</span></span><br><span class="line">// `<span class="keyword">vm</span>.<span class="keyword">b</span>` 是非响应式的</span><br></pre></td></tr></table></figure>

<p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 <code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式 property。例如，对于：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Vue.<span class="builtin-name">set</span>(vm.someObject, <span class="string">&#x27;b&#x27;</span>, 2)</span><br></pre></td></tr></table></figure>

<p>您还可以使用 <code>vm.$set</code> 实例方法，这也是全局 <code>Vue.set</code> 方法的别名：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$<span class="keyword">set</span>(<span class="keyword">this</span>.someObject,<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>有时你可能需要为已有对象赋值多个新 property，比如使用 <code>Object.assign()</code> 或 <code>_.extend()</code>。但是，这样添加到对象上的新 property 不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的 property 一起创建一个新的对象。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">代替</span> <span class="string">`Object.assign(this.someObject,</span> &#123; <span class="attr">a:</span> <span class="number">1</span>, <span class="attr">b:</span> <span class="number">2</span> &#125;<span class="string">)`</span></span><br><span class="line"><span class="string">this.someObject</span> <span class="string">=</span> <span class="string">Object.assign(&#123;&#125;,</span> <span class="string">this.someObject,</span> &#123; <span class="attr">a:</span> <span class="number">1</span>, <span class="attr">b:</span> <span class="number">2</span> &#125;<span class="string">)</span></span><br></pre></td></tr></table></figure>

<h4 id="对于数组"><a href="#对于数组" class="headerlink" title="对于数组"></a>对于数组</h4><p>Vue 不能检测以下数组的变动：</p>
<ol>
<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></li>
</ol>
<p>举个例子：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  dat<span class="variable">a:</span> &#123;</span><br><span class="line">    item<span class="variable">s:</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">vm</span>.<span class="built_in">items</span>[<span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span> // 不是响应性的</span><br><span class="line"><span class="keyword">vm</span>.<span class="built_in">items</span>.length = <span class="number">2</span> // 不是响应性的</span><br></pre></td></tr></table></figure>

<p>为了解决第一类问题，以下两种方式都可以实现和 <code>vm.items[indexOfItem] = newValue</code> 相同的效果，同时也将在响应式系统内触发状态更新：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.<span class="keyword">set</span>(vm.items, indexOfItem, <span class="keyword">new</span><span class="type">Value</span>)</span><br><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(indexOfItem, <span class="number">1</span>, <span class="keyword">new</span><span class="type">Value</span>)</span><br></pre></td></tr></table></figure>

<p>你也可以使用 <a href="https://cn.vuejs.org/v2/api/#vm-set"><code>vm.$set</code></a> 实例方法，该方法是全局方法 <code>Vue.set</code> 的一个别名：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">vm.<span class="constructor">$set(<span class="params">vm</span>.<span class="params">items</span>, <span class="params">indexOfItem</span>, <span class="params">newValue</span>)</span></span><br></pre></td></tr></table></figure>

<p>为了解决第二类问题，你可以使用 <code>splice</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">vm</span><span class="selector-class">.items</span><span class="selector-class">.splice</span>(<span class="selector-tag">newLength</span>)</span><br></pre></td></tr></table></figure>

<h3 id="声明响应式-property"><a href="#声明响应式-property" class="headerlink" title="声明响应式 property"></a>声明响应式 property</h3><p>由于 Vue 不允许动态添加根级响应式 property，所以你必须在初始化实例前声明所有根级响应式 property，哪怕只是一个空值：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> vm = <span class="literal">new</span> Vue(&#123;</span><br><span class="line">  <span class="built_in">data</span>: &#123;</span><br><span class="line">    <span class="comment">// 声明 message 为一个空值字符串</span></span><br><span class="line">    message: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 之后设置 `message`</span></span><br><span class="line">vm.message = <span class="string">&#x27;Hello!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果你未在 <code>data</code> 选项中声明 <code>message</code>，Vue 将警告你渲染函数正在试图访问不存在的 property。</p>
<p>这样的限制在背后是有其技术原因的，它消除了在依赖项跟踪系统中的一类边界情况，也使 Vue 实例能更好地配合类型检查系统工作。但与此同时在代码可维护性方面也有一点重要的考虑：<code>data</code>对象就像组件状态的结构 (schema)。提前声明所有的响应式 property，可以让组件代码在未来修改或给其他开发人员阅读时更易于理解。</p>
<h3 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h3><p>可能你还没有注意到，Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p>
<p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code>，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。例如：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;example&quot;</span>&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br><span class="line">var <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="keyword">e</span><span class="variable">l:</span> <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  dat<span class="variable">a:</span> &#123;</span><br><span class="line">    message: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">vm</span>.message = <span class="string">&#x27;new message&#x27;</span> // 更改数据</span><br><span class="line"><span class="keyword">vm</span>.$<span class="keyword">el</span>.textContent === <span class="string">&#x27;new message&#x27;</span> // false</span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> <span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="keyword">vm</span>.$<span class="keyword">el</span>.textContent === <span class="string">&#x27;new message&#x27;</span> // true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局 <code>Vue</code>，并且回调函数中的 <code>this</code> 将自动绑定到当前的 Vue 实例上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;example&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#x27;</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;未更新&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;未更新&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el.textContent) <span class="comment">// =&gt; &#x27;已更新&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因为 <code>$nextTick()</code> 返回一个 <code>Promise</code> 对象，所以你可以使用新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">ES2017 async/await</a> 语法完成相同的事情：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">methods</span>: &#123;</span><br><span class="line">  <span class="attribute">updateMessage</span>: async function () &#123;</span><br><span class="line">    this.message = <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">    console.<span class="built_in">log</span>(this.$el.textContent) // =&gt; <span class="string">&#x27;未更新&#x27;</span></span><br><span class="line">    await this.$<span class="built_in">nextTick</span>()</span><br><span class="line">    console.<span class="built_in">log</span>(this.$el.textContent) // =&gt; <span class="string">&#x27;已更新&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Vue-给对象添加属性"><a href="#Vue-给对象添加属性" class="headerlink" title="Vue 给对象添加属性"></a><a name="solution"><code>Vue</code> 给对象添加属性</a></h3><p>在开发过程中，我们时常会遇到这样一种情况：当 <code>vue</code> 的 <code>data</code> 里边声明或者已经赋值过的对象或者数组（数组里边的值是对象）时，向对象中添加新的属性，<strong>如果更新此属性的值，是不会更新视图的。</strong></p>
<p><span style="color:red;">根据官方文档定义：<strong>如果在实例创建之后添加新的属性到实例上，它不会触发视图更新</strong>。</span></p>
<p>受现代 JavaScript 的限制 (以及废弃 Object.observe)，Vue 不能检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 <code>getter/setter</code> 转化过程，所以属性<strong>必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的。</strong></p>
<p>看以下实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">    &lt;p @click&#x3D;&quot;addd(obj)&quot;&gt;&#123;&#123;obj.d&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p @click&#x3D;&quot;adde(obj)&quot;&gt; &#123;&#123;obj.e&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">      data()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                obj:&#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      mounted() &#123;</span><br><span class="line">        this.obj &#x3D; &#123;d: 0&#125;;</span><br><span class="line">        this.obj.e &#x3D; 0;</span><br><span class="line">        console.log(&#39;after--&#39;, this.obj);</span><br><span class="line">      &#125;,</span><br><span class="line">     methods: &#123;</span><br><span class="line">        addd(item) &#123;</span><br><span class="line">            item.d &#x3D; item.d + 1;</span><br><span class="line">            console.log(&#39;item--&#39;,item);</span><br><span class="line">        &#125;,</span><br><span class="line">        adde(item) &#123;</span><br><span class="line">            item.e &#x3D; item.e + 1;</span><br><span class="line">            console.log(&#39;item--&#39;,item);</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &lt;&#x2F;scirpt&gt;  </span><br></pre></td></tr></table></figure>

<p>可以看出<code>d属性</code>是有<strong>get 和 set方法</strong>的，而新增的e属性是没有的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击触发3次addd，点击触发3次adde,页面效果及控制台信息如下</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此时触发1次addd,页面效果如下：</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>由此可以看出，更新新增属性e，是不会更新视图，但是会改变其值，当更新原有属性d时会更新视图，同时将新增的属性e的值也更新到视图里边</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><code>官方定义</code> 中的解决方法在上文中已经给出   —-&gt; <a href="#content">检测变化的注意事项</a></p>
<p>有时你想向已有对象上添加一些属性，例如使用 <code>Object.assign()</code> 或 <code>_.extend()</code> 方法来添加属性。</p>
<p>但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代替 `Object.assign(this.obj, &#123; a: 1, e: 2 &#125;)`</span></span><br><span class="line"><span class="built_in">this</span>.obj= <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.obj, &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">e</span>: <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>上述实例解决如下：<strong>在 <code>mounted()</code> 中动态添加全局对象属性</strong></p>
<p><img data-src="problem-3.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击触发3次addd，点击触发3次adde,页面效果及控制台信息如下：</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="Problems-To-Collect"><a href="#Problems-To-Collect" class="headerlink" title="Problems To Collect"></a>Problems To Collect</h2><h3 id="1、Vue异步获取数据后初始化数据不能及时更新"><a href="#1、Vue异步获取数据后初始化数据不能及时更新" class="headerlink" title="1、Vue异步获取数据后初始化数据不能及时更新"></a>1、Vue异步获取数据后初始化数据不能及时更新</h3><ul>
<li>钩子函数尽量使用mounted来完成初始化函数，根据vue的生命周期尽量不要用mounted之前的</li>
<li>对于可能要改变的值，最好直接写到data{}中</li>
<li>如果还不能实时更新，通过vue的官方<code>$set</code>方法可以实现手动设置</li>
<li>一些特殊set方法，比如其他js框架的set方法，会和vue的方法冲突造成数据不能同步</li>
</ul>
<h3 id="2、Vue-Watch的两个Demo"><a href="#2、Vue-Watch的两个Demo" class="headerlink" title="2、Vue Watch的两个Demo"></a>2、Vue Watch的两个Demo</h3><blockquote>
<p>参考</p>
</blockquote>
<p><strong>Demo1</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    &#123;&#123;value&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;index&#x27;</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        demo: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        value: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      demo(val) &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.value = <span class="built_in">this</span>.demo;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Demo2</strong></p>
<p>下面这个例子中，如果<code>watch</code>监测的是一个对象的话，直接使用<code>watch</code>是不行的，此时我们可以借助于<code>computed</code>计算属性来完成。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;demo.name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">    &#123;&#123;value&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&#x27;index&#x27;</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        demo: &#123;</span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        value: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      newName() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.demo.name;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">      newName(val) &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.value = val;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Demo3</strong></p>
<p>数组的变化，不需要深度watch</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;childrens.name&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue( &#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      childrens: &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">&#x27;小强&#x27;</span>,</span></span><br><span class="line">        age: 20,</span><br><span class="line"><span class="javascript">        sex: <span class="string">&#x27;男&#x27;</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      tdArray:[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>],</span></span><br><span class="line"><span class="javascript">      lastName:<span class="string">&quot;张三&quot;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    watch:&#123;</span><br><span class="line">      childrens:&#123;</span><br><span class="line"><span class="javascript">        handler:<span class="function"><span class="keyword">function</span>(<span class="params">val,oldval</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(val.name)</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        deep:<span class="literal">true</span><span class="comment">//对象内部的属性监听，也叫深度监听</span></span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="string">&#x27;childrens.name&#x27;</span>:<span class="function"><span class="keyword">function</span>(<span class="params">val,oldval</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(val+<span class="string">&quot;aaa&quot;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;,<span class="comment">//键路径必须加上引号</span></span></span><br><span class="line"><span class="javascript">      lastName:<span class="function"><span class="keyword">function</span>(<span class="params">val,oldval</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.lastName)</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="javascript">    &#125;,<span class="comment">//以V-model绑定数据时使用的数据变化监测</span></span></span><br><span class="line">  &#125; );</span><br><span class="line"><span class="javascript">  vm.$watch(<span class="string">&quot;lastName&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">val,oldval</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(val)</span></span><br><span class="line"><span class="javascript">  &#125;)<span class="comment">//主动调用$watch方法来进行数据监测</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、Vue-el-input-的事件中未及时触发数据动态渲染"><a href="#3、Vue-el-input-的事件中未及时触发数据动态渲染" class="headerlink" title="3、Vue el-input 的事件中未及时触发数据动态渲染"></a>3、Vue <code>el-input</code> 的事件中未及时触发数据动态渲染</h3><blockquote>
<p>BUG—-2020/11/4</p>
<p>问题是这样的：这个使用的 <code>element-ui</code> 输入框，要求其输入必须为浮点数字（数字和点），而非除数字以外的字符。</p>
<p>Bug出现在其可以用中文输入法输入字符并停留，未及时触发相应的 <code>@input</code> 事件和 <code>@keyup</code>事件 </p>
</blockquote>
<p><img data-src="problem-1.png"></p>
<p><strong>处理过程中，尝试了所有可能的方法，比如</strong></p>
<p><strong>①使用 <code>this.$set()</code> 方法，<a href="#solution">参考此处</a></strong></p>
<p><strong>②使用 <code>vm.$forceUpdate()</code>**，<a href="https://cn.vuejs.org/v2/api/#vm-forceUpdate">官方文档</a>用处不大，顾名思义主要目的就是</strong>强制更新渲染DOM**，然并卵……</p>
<p><strong>③</strong>最后实在不行，想着在 <code>update</code> 之前就把多余字符串过滤了。于是<strong>添加 <code>beforeUpdate()</code> 方法，进行补充过滤</strong></p>
<p><img data-src="problem-2.png"></p>
<blockquote>
<p>（……是时候看看 <code>Vue</code> 源码了<del>~</del>）</p>
<p>BUG—-2020/11/5</p>
<p>问题同样应该还是数据不及时更新的问题，这次的解决方案仅仅是：</p>
</blockquote>
<p><strong>①为一个组件的事件 <code>@select</code> 添加 <code>.native</code> ，解决了数据未同步的问题</strong></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>框架与工具</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>被手摸手用Vue撸后台</title>
    <url>/2020/10/28/Be-Led-to-Write-VUE-Background/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>一起学习用 <code>Vue</code> 写后台吧！</p>
<p>这儿参考大佬的文章来做练习，并记录一些遇到的问题和新知识</p>
<p><a href="https://juejin.im/post/6844903476661583880#heading-0">原文传送门</a></p>
</blockquote>
<a id="more"></a>

<h2 id="系列一：基础篇"><a href="#系列一：基础篇" class="headerlink" title="系列一：基础篇"></a>系列一：基础篇</h2><blockquote>
<p>大佬的完整项目 <a href="https://github.com/PanJiaChen/vue-element-admin">github地址</a></p>
</blockquote>
<p>一、</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>框架与工具</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 动画</title>
    <url>/2020/08/31/css-animation/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>下面汇总并总结了有关与CSS动画的知识点，再次熟悉一遍！</p>
<p><code>CSS Transform</code>/<code>CSS Transition</code>/<code>CSS Animation</code>/<code>CSS Gradient</code></p>
</blockquote>
<a id="more"></a>

<h2 id="一、CSS-Transform"><a href="#一、CSS-Transform" class="headerlink" title="一、CSS Transform"></a>一、CSS Transform</h2><p><code>Transform</code>字面上就是<code>变形，改变</code>的意思。在CSS3中<code>transform</code>主要包括以下几种：<strong>旋转rotate</strong>、<strong>扭曲skew</strong>、<strong>缩放scale</strong>和<strong>移动translate</strong>以及<strong>矩阵变形matrix</strong>。</p>
<p><strong>语法：</strong></p>
<p><code>transform ： none | [ rotate | scale | skew | translate |matrix]</code></p>
<p><code>none</code>:表示不进么变换；后者表示一个或多个变换函数，**<u>以空格分开</u>**</p>
<h3 id="1、-旋转rotate"><a href="#1、-旋转rotate" class="headerlink" title="1、 旋转rotate"></a>1、 旋转<code>rotate</code></h3><p><strong>rotate()</strong> ：通过指定的角度参数对原元素指定一个2D 旋转，需先有<code>transform-origin</code>属性的定义。<code>transform-origin</code>定义的是旋转的基点，其中<code>angle</code>是指旋转角度，如果设置的值为正数表示顺时针旋转，如果设置的值为负数，则表示逆时针旋转。</p>
<p>如：<code>transform:rotate(30deg)</code></p>
<p><img data-src="rotate.png"></p>
<h3 id="2、移动translate"><a href="#2、移动translate" class="headerlink" title="2、移动translate"></a>2、移动<code>translate</code></h3><p>移动<code>translate</code>我们分为三种情况：</p>
<ul>
<li><code>translate(x,y)</code>水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）</li>
<li><code>translateX(x)</code>仅水平方向移动（X轴移动）</li>
<li><code>translateY(Y)</code>仅垂直方向移动（Y轴移动）</li>
</ul>
<blockquote>
<p>也可以根据<code>transform-origin</code>改变基点位置</p>
</blockquote>
<p><img data-src="translate.png"></p>
<h3 id="3、缩放scale"><a href="#3、缩放scale" class="headerlink" title="3、缩放scale"></a>3、缩放<code>scale</code></h3><p>缩放<code>scale</code>具有三种情况：</p>
<ul>
<li><code>scale(x,y)</code>使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）</li>
<li><code>scaleX(x)</code>元素仅水平方向缩放（X轴缩放）</li>
<li><code>scaleY(y)</code>元素仅垂直方向缩放（Y轴缩放）</li>
</ul>
<blockquote>
<p>但它们具有相同的缩放中心点和基数，其中心点就是元素的中心位置，<code>缩放基数为1</code>，如果<code>其值大于1</code>元素就放大，反之其值小于1，元素缩小。</p>
</blockquote>
<p><strong>scale([, ])：</strong>提供执行[sx,sy]缩放矢量的两个参数指定一个<code>2D缩放</code>。如果第二个参数未提供，则取与第一个参数一样的值。<code>scale(X,Y)</code>是用于对元素进行缩放，可以通过<code>transform-origin</code>对元素的基点进行设置，同样基点在元素中心位置；基中X表示水平方向缩放的倍数，Y表示垂直方向的缩放倍数，而Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。并以X为准。如：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:scale(<span class="number">2</span>,<span class="number">1</span>.<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p><img data-src="scale.png"></p>
<h3 id="4、扭曲skew"><a href="#4、扭曲skew" class="headerlink" title="4、扭曲skew"></a>4、扭曲skew</h3><p>扭曲<code>skew</code>具有三种情况：</p>
<ul>
<li><code>skew(x,y)</code>使元素在水平和垂直方向同时扭曲（X轴和Y轴同时按一定的角度值进行扭曲变形）</li>
<li><code>skewX(x)</code>仅使元素在水平方向扭曲变形（X轴扭曲变形）</li>
<li><code>skewY(y)</code>仅使元素在垂直方向扭曲变形（Y轴扭曲变形）</li>
</ul>
<p><strong>skew( [, ])</strong> ：X轴Y轴上的斜切变换。第一个参数对应X轴，第二个参数对应Y轴。如果第二个参数未提供，则值为0，也就是Y轴方向上无斜切。</p>
<p>skew是用来对元素进行扭曲变行，第一个参数是水平方向扭曲角度，第二个参数是垂直方向扭曲角度。其中第二个参数是可选参数，如果没有设置第二个参数，那么Y轴为0deg。同样是以元素中心为基点，我们也可以通过<code>transform-origin</code>来改变元素的基点位置。如：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">transform:skew(<span class="number">30</span>deg,<span class="number">10</span>deg):</span><br></pre></td></tr></table></figure>

<p><img data-src="skew.png"></p>
<p><strong>skewX()</strong> ： 按给定的角度沿X轴指定一个斜切变换。如：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><span class="line"><span class="variable">transform</span>:<span class="function"><span class="title">skewX</span>(<span class="number">30</span><span class="variable">deg</span>)</span></span><br></pre></td></tr></table></figure>

<p><img data-src="skewX.png"></p>
<h3 id="5、矩阵matrix"><a href="#5、矩阵matrix" class="headerlink" title="5、矩阵matrix"></a>5、矩阵<code>matrix</code></h3><p><code>matrix(, , , , , )</code> </p>
<p> 以一个含六值的(a,b,c,d,e,f)<code>变换矩阵</code>的形式指定一个<code>2D变换</code>，相当于直接应用一个<code>[a b c d e f]变换矩阵</code>。就是基于水平方向（X轴）和垂直方向（Y轴）重新定位元素,此属性值使用涉及到数学中的矩阵。</p>
<h3 id="6、改变元素基点transform-origin"><a href="#6、改变元素基点transform-origin" class="headerlink" title="6、改变元素基点transform-origin"></a>6、改变元素基点<code>transform-origin</code></h3><p><strong>其主要作用</strong>就是让我们在进行<code>transform</code>动作之前可以改变元素的基点位置。</p>
<p>因为我们元素默认基点就是其中心位置，换句话说我们没有使用transform-origin改变元素基点位置的情况下，transform进行的rotate,translate,scale,skew,matrix等操作都是以元素自己中心位置进行变化的。但有时候我们需要在不同的位置对元素进行这些操作，那么我们就可以使用transform-origin来对元素进行基点位置改变，使元素基点不在是中心位置，以达到你需要的基点位置。下面我们主要来看看其使用规则：</p>
<p><code>transform-origin(X,Y):</code> 用来设置元素的运动的基点（参照点）。默认点是元素的中心点。其中X和Y的值可以是<code>百分值</code>,<code>em</code>,<code>px</code>，其中X也可以是字符参数值<code>left,center,right</code>；Y和X一样除了百分值外还可以设置字符值<code>top,center,bottom</code></p>
<ol>
<li><code>top left | left top</code> 等价于 <code>0 0 | 0% 0%</code></li>
<li><code>top | top center | center top</code> 等价于 <code>50% 0</code></li>
<li><code>right top | top right</code> 等价于 <code>100% 0</code></li>
<li><code>left | left center | center left</code> 等价于 <code>0 50% | 0% 50%</code></li>
<li><code>center | center center</code> 等价于 <code>50% 50%（默认值）</code></li>
<li><code>right | right center | center right</code> 等价于 <code>100% 50%</code></li>
<li><code>bottom left | left bottom</code> 等价于 <code>0 100% | 0% 100%</code></li>
<li><code>bottom | bottom center | center bottom</code> 等价于 <code>50% 100%</code></li>
<li><code>bottom right | right bottom</code> 等价于 <code>100% 100%</code></li>
</ol>
<p>其中 <code>left,center right</code>是水平方向取值，对应的百分值为<code>left=0%;center=50%;right=100%</code>，而<code>top center bottom</code>是垂直方向的取值，其中<code>top=0%;center=50%;bottom=100%;</code>如果只取一个值，表示垂直方向值不变</p>
<p>这里还要提醒大家一点的是，transform-origin并不是transform中的属性值，他具有自己的语法，跟其他的css3属性一样，我们需要在不同的浏览内核中加上相应的前缀，下面列出各种浏览器内核下的语法规则：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>Mozilla内核浏览器：</span><br><span class="line">firefox3.<span class="number">5</span>+-moz-transform-origin: x y;</span><br><span class="line"><span class="regexp">//</span>Webkit内核浏览器：Safari and Chrome-webkit-transform-origin: x y;</span><br><span class="line"><span class="regexp">//</span>Opera-o-transform-origin: x y ;</span><br><span class="line"><span class="regexp">//</span>IE9-ms-transform-origin: x y;</span><br><span class="line"><span class="regexp">//</span>W3C标准transform-origin: x y ;</span><br></pre></td></tr></table></figure>

<h2 id="二、CSS-Transition"><a href="#二、CSS-Transition" class="headerlink" title="二、CSS Transition"></a>二、CSS Transition</h2><blockquote>
<p>参考自<a href="https://www.cnblogs.com/xiaohuochai/p/5347930.html">深入理解CSS过渡transition</a>（博主写的太赞了！）</p>
<p>可参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition">MDN文档</a></p>
</blockquote>
<h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>过渡<code>transition</code>是一个复合属性，包括<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timing-function</code>、<code>transition-delay</code>这四个子属性。通过这四个子属性的配合来完成一个完整的过渡效果</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">transition-<span class="keyword">property</span><span class="string"></span>: 过渡属性(默认值为all)</span><br><span class="line">transition-<span class="attribute">duration</span>: 过渡持续时间(默认值为<span class="number">0</span>s)</span><br><span class="line">transiton-timing-<span class="function"><span class="keyword">function</span>: 过渡函数(<span class="params">默认值为ease函数</span>)</span></span><br><span class="line"><span class="function"><span class="title">transition</span>-<span class="title">delay</span>: 过渡延迟时间(<span class="params">默认值为0s</span>)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>**[注意]**IE9-不支持该属性，<code>safari3.1-6</code>、<code>IOS3.2-6.1</code>、<code>android2.1-4.3</code>需要添加<code>-webkit-</code>前缀；而其余高版本浏览器支持标准写法</p>
</blockquote>
<h3 id="2、复合属性"><a href="#2、复合属性" class="headerlink" title="2、复合属性"></a>2、复合属性</h3><p>过渡<code>transition</code>的这四个子属性只有<code>&lt;transition-duration&gt;</code>是必需值且不能为0。其中，<code>&lt;transition-duration&gt;</code>和<code>&lt;transition-delay&gt;</code>都是时间。当两个时间同时出现时，第一个是<code>&lt;transition-duration&gt;</code>，第二个是<code>&lt;transition-delay&gt;</code>；当只有一个时间时，它是<code>&lt;transition-duration&gt;</code>，而<code>&lt;transition-delay&gt;</code>为默认值0</p>
<blockquote>
<p><strong>[注意]</strong><code>transition</code>的这四个子属性之间不能用逗号隔开，只能用空格隔开。因为逗号隔开的代表不同的属性(transition属性支持多值，多值部分(稍后介绍)；而空格隔开的代表不同属性的四个关于过渡的子属性</p>
</blockquote>
<h3 id="3、过渡属性-transition-property"><a href="#3、过渡属性-transition-property" class="headerlink" title="3、过渡属性 transition-property"></a>3、过渡属性 <code>transition-property</code></h3><blockquote>
<p><strong>值:</strong> <code>none</code> | <code>all</code> | <code>&lt;transition-property&gt;</code>[,<code>&lt;transition-property&gt;</code>]*</p>
<p><strong>初始值:</strong> <code>all</code></p>
<p><strong>应用于:</strong> 所有元素</p>
<p><strong>继承性:</strong> 无</p>
</blockquote>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="attribute">none</span>: 没有指定任何样式</span><br><span class="line"><span class="attribute">all</span>: 默认值，表示指定元素所有支持transition-<span class="keyword">property</span><span class="string">属性的样式</span></span><br><span class="line">&lt;transition-<span class="keyword">property</span><span class="string">&gt;</span>: 可过渡的样式，可用逗号分开写多个样式</span><br></pre></td></tr></table></figure>

<p><strong>可过渡的样式</strong></p>
<p>　　不是所有的CSS样式值都可以过渡，只有具有中间值的属性才具备过渡效果</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="attr">Vstart</span> = 开始值; <span class="attr">Vend</span> = 结束值; <span class="attr">Vres</span> = 中间值; <span class="attr">p</span> = 过渡函数的输出值</span><br><span class="line"><span class="attr">Vres</span> = (<span class="number">1</span> - p) * Vstart + p * Vend</span><br><span class="line">当Vres具有有效值时，则该CSS样式可过渡</span><br></pre></td></tr></table></figure>

<blockquote>
<p>颜色: <code>color</code> <code>background-color</code> <code>border-color</code> <code>outline-color</code></p>
<p>位置: <code>backround-position</code> <code>left</code> <code>right</code> <code>top</code> <code>bottom</code></p>
<p>长度:<br>    [1]<code>max-height</code> <code>min-height</code> <code>max-width</code> <code>min-width</code> <code>height</code> <code>width</code><br>    [2]<code>border-width</code> <code>margin</code> <code>padding</code> <code>outline-width</code> <code>outline-offset</code><br>    [3]<code>font-size</code> <code>line-height</code> <code>text-indent</code> <code>vertical-align</code><br>    [4]<code>border-spacing</code> <code>letter-spacing</code> <code>word-spacing</code></p>
<p>数字: <code>opacity</code> <code>visibility</code> <code>z-index</code> <code>font-weight</code> <code>zoom</code></p>
<p>组合: <code>text-shadow</code> <code>transform</code> <code>box-shadow</code> <code>clip</code></p>
<p>其他: <code>gradient</code></p>
</blockquote>
<h3 id="4、过渡持续时间-transition-duration"><a href="#4、过渡持续时间-transition-duration" class="headerlink" title="4、过渡持续时间 transition-duration"></a>4、过渡持续时间 <code>transition-duration</code></h3><blockquote>
<p><strong>值:</strong> <code>&lt;time&gt;</code>[,<code>&lt;time&gt;</code>]*</p>
<p><strong>初始值:</strong> 0s</p>
<p><strong>应用于:</strong> 所有元素</p>
<p><strong>继承性:</strong> 无</p>
<p>**[注意]**该属性不能为负值,单位是秒s或毫秒ms</p>
<p>**[注意]**若该属性为0s则为默认值，若为0则为无效值。所以必须带单位</p>
<p>**[注意]**该值为单值时，即所有过渡属性都对应同样时间；该值为多值时，过渡属性按照顺序对应持续时间</p>
</blockquote>
<h3 id="5、过渡延迟时间-transition-delay"><a href="#5、过渡延迟时间-transition-delay" class="headerlink" title="5、过渡延迟时间 transition-delay"></a>5、过渡延迟时间 <code>transition-delay</code></h3><p>该属性定义元素属性延迟多少时间后开始过渡效果，该属性的单位是秒s或毫秒ms</p>
<blockquote>
<p><strong>值:</strong> <code>&lt;time&gt;</code>[,<code>&lt;time&gt;</code>]*</p>
<p><strong>初始值:</strong> 0s</p>
<p><strong>应用于:</strong> 所有元素</p>
<p><strong>继承性:</strong> 无</p>
<p>**[注意]**该属性若为负值，无延迟效果，但过渡元素的起始值将从0变成设定值(设定值=延迟时间+持续时间)。若该设定值小于等于0，则无过渡效果；若该设定值大于0，则过渡元素从该设定值开始完成剩余的过渡效果</p>
<p>**[注意]**若该属性为0s则为默认值，若为0则为无效值。所以必须带单位</p>
<p>**[注意]**该值为单值时，即所有过渡属性都对应同样时间；该值为多值时，过渡属性按照顺序对应持续时间</p>
</blockquote>
<h3 id="6、过渡时间函数-transition-timing-function"><a href="#6、过渡时间函数-transition-timing-function" class="headerlink" title="6、过渡时间函数 transition-timing-function"></a>6、过渡时间函数 <code>transition-timing-function</code></h3><p><code>过渡时间函数</code>用于定义元素过渡属性随时间变化的过渡速度变化效果</p>
<blockquote>
<p><strong>值:</strong> <code>&lt;timing-function&gt;</code>[,<code>&lt;timing-function&gt;</code>]*</p>
<p><strong>初始值:</strong> ease</p>
<p><strong>应用于:</strong> 所有元素</p>
<p><strong>继承性:</strong> 无</p>
</blockquote>
<p><strong>取值</strong></p>
<p><code>过渡时间函数</code>共三种取值:分别是<code>关键字</code>、<code>steps函数</code>和<code>bezier函数</code></p>
<p><strong>①steps函数</strong></p>
<p>　　steps步进函数将过渡时间划分成大小相等的时间时隔来运行</p>
<p>　　steps步进函数为</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">steps(&lt;<span class="keyword">integer</span>&gt;[,<span class="built_in">start</span> | <span class="keyword">end</span>]?)</span><br><span class="line">&lt;<span class="keyword">integer</span>&gt;:用来指定间隔个数(该值只能是正整数)</span><br><span class="line">第二个参数: 该参数可选，默认是<span class="keyword">end</span>，表示开始值保持一次；若参数为<span class="built_in">start</span>，表示开始不保持</span><br></pre></td></tr></table></figure>

<p><strong>②贝塞尔曲线</strong></p>
<p>贝塞尔曲线通过p0-p3四个控制点来控制，其中p0表示(0,0)，p3表示(1,1)。而<code>&lt;transition-timing-function&gt;</code>就是通过确定<code>p1(x1,y1)</code>和<code>p2(x2,y2)</code>的值来确定的。可以使用<a href="http://cubic-bezier.com/">工具网站</a>来定制。</p>
<p><strong>③关键字</strong></p>
<p><code>关键字</code>其实是<code>bezier函数</code>或<code>steps函数</code>的特殊值</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ease</span>: 开始和结束慢，中间快。相当于cubic-bezier(<span class="number">0</span>.<span class="number">25</span>,<span class="number">0</span>.<span class="number">1</span>,<span class="number">0</span>.<span class="number">25</span>,<span class="number">1</span>)</span><br><span class="line"><span class="attribute">linear</span>: 匀速。相当于cubic-bezier(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="attribute">ease</span>-in: 开始慢。相当于cubic-bezier(<span class="number">0</span>.<span class="number">42</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="attribute">ease</span>-out: 结束慢。相当于cubic-bezier(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>.<span class="number">58</span>,<span class="number">1</span>)</span><br><span class="line"><span class="attribute">ease</span>-in-out: 和ease类似，但比ease幅度大。相当于cubic-bezier(<span class="number">0</span>.<span class="number">42</span>,<span class="number">0</span>,<span class="number">0</span>.<span class="number">58</span>,<span class="number">1</span>)</span><br><span class="line"><span class="attribute">step</span>-start: 直接位于结束处。相当于steps(<span class="number">1</span>,start)</span><br><span class="line"><span class="attribute">step</span>-end: 位于开始处经过时间间隔后结束。相当于steps(<span class="number">1</span>,end)</span><br></pre></td></tr></table></figure>

<p><img data-src="function.png"></p>
<h3 id="7、触发方式"><a href="#7、触发方式" class="headerlink" title="7、触发方式"></a>7、触发方式</h3><p>一般地，过渡<code>transition</code>的触发有三种方式，分别是<code>伪类触发</code>、<code>媒体查询触发</code>和<code>javascript触发</code>。其中常用伪类触发包括<code>:hover、:focus、:active</code>等</p>
<p><strong>@media触发</strong>  符合媒体查询条件时触发</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 把浏览器的宽度拖动到小于1000px时触发 */</span></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width:</span> <span class="number">1000px</span>)&#123;</span><br><span class="line">    <span class="selector-class">.test</span>&#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>点击事件</strong>    用户点击元素时触发</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    test.style.width = <span class="string">&#x27;300px&#x27;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        test.style.width = <span class="string">&#x27;100px&#x27;</span>;</span><br><span class="line">    &#125;,<span class="number">3000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8、-API"><a href="#8、-API" class="headerlink" title="8、 *API"></a>8、 *API</h3><blockquote>
<p>关于过渡transition的事件只有一个，是<code>transitionend</code>事件，它发生在过渡事件完成后</p>
<p>[注意]safari3.1-6、ISO3.2-6.1、android2.1-4.3需要使用<code>webkitTransitionEnd</code>事件</p>
</blockquote>
<h3 id="9、-transition的使用注意"><a href="#9、-transition的使用注意" class="headerlink" title="9、 transition的使用注意"></a>9、 transition的使用注意</h3><blockquote>
<p>参考自 <a href="http://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html">阮一峰网络日志</a></p>
</blockquote>
<p>（1）目前，各大浏览器（包括IE 10）都已经支持无前缀的transition，所以transition已经可以很安全地不加浏览器前缀。</p>
<p>（2）不是所有的CSS属性都支持transition，完整的列表查看<a href="http://oli.jp/2010/css-animatable-properties/">这里</a>，以及具体的<a href="http://leaverou.github.io/animatable/">效果</a>。</p>
<p>（3）transition需要明确知道，开始状态和结束状态的具体数值，才能计算出中间状态。比如，height从0px变化到100px，transition可以算出中间状态。但是，transition没法算出0px到auto的中间状态，也就是说，如果开始或结束的设置是height: auto，那么就不会产生动画效果。类似的情况还有，display: none到block，background: url(foo.jpg)到url(bar.jpg)等等。</p>
<h3 id="10、-transition的局限"><a href="#10、-transition的局限" class="headerlink" title="10、 transition的局限"></a>10、 transition的局限</h3><p>transition的优点在于简单易用，但是它有几个很大的局限。</p>
<p>（1）transition需要事件触发，所以没法在网页加载时自动发生。</p>
<p>（2）transition是一次性的，不能重复发生，除非一再触发。</p>
<p>（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。</p>
<p>（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。</p>
<p>CSS Animation就是为了解决这些问题而提出的。</p>
<h2 id="三、CSS-Animation"><a href="#三、CSS-Animation" class="headerlink" title="三、CSS Animation"></a>三、CSS Animation</h2><blockquote>
<p>参考自<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations/Using_CSS_animations">MDN 文档</a>、<a href="https://blog.csdn.net/u013243347/article/details/79976352">CSDN大佬博文</a></p>
<h4 id="SVG动画实践"><a href="#SVG动画实践" class="headerlink" title="SVG动画实践"></a>SVG动画实践</h4><p><a href="http://www.yangoogle.com/#/">动画实践</a></p>
<h4 id="CSS3动效网站"><a href="#CSS3动效网站" class="headerlink" title="CSS3动效网站:"></a>CSS3动效网站:</h4><p> 一个很全的CSS3的动效库，可以尝试看看源码进行学习。<br><a href="https://createjs.com/demos/easeljs/alphamaskreveal">CreateJS</a> 里面的特效做得也很不错，有很多酷炫的样例。<br><a href="https://fournier-pere-fils.com/story">国外css3网页</a> 布局很优雅的网站<br><a href="http://usatoday.geex-arts.com/">USAToday</a> 也是一个很酷炫的国外网站<br><a href="https://peekabeat.com/#!/">peekabeat</a> 很清爽的界面<br><a href="http://www.ensemblecorrespondances.com/">dances</a> 貌似是交响乐的网站主页（打不开）<br><a href="https://www.couleecreative.com/">reative</a> 很有时代感的网站(第一感觉有点突兀吓人)<br><a href="http://cssanimate.com/">animation</a> 在线animation编辑器</p>
</blockquote>
<p>动画可以通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p>
<p>创建动画序列，需要使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation"><code>animation</code></a>属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@keyframes"><code>@keyframes</code></a>规则实现，具体情况参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Animations/Using_CSS_animations#%E4%BD%BF%E7%94%A8keyframes%E5%AE%9A%E4%B9%89%E5%8A%A8%E7%94%BB%E5%BA%8F%E5%88%97">使用keyframes定义动画序列</a>小节部分。</p>
<blockquote>
<p><strong>实例</strong></p>
<p><code>animation</code>：<code>动画名称</code> <code>动画时间</code> <code>运动曲线</code> <code>何时开始</code> <code>播放次数</code> <code>是否反方向</code>;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animation: rotate 5s linear 0s infinite alternate;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="1、Animation-属性"><a href="#1、Animation-属性" class="headerlink" title="1、Animation 属性"></a>1、Animation 属性</h3><p><span style="color:red;font-weight:bold;">注意：由于animate为复合属性，简写时极易导致不对应而产生无效属性值的问题</span></p>
<p><span style="color:red;">也有可能因为没有将元素设置为  <code>block</code> 或者  <code>inline-block</code> 而导致</span></p>
<h4 id="简写属性形式"><a href="#简写属性形式" class="headerlink" title="简写属性形式:"></a>简写属性形式:</h4><blockquote>
<p><strong>animation:</strong></p>
<p>[<code>animation-name</code>] // 动画的名称</p>
<p>[<code>animation-duration</code>] // 持续时间</p>
<p>[<code>animation-timing-function</code>] // 关于时间的函数(properties/t)</p>
<p>[<code>animation-delay</code>] // 延迟时间</p>
<p>[<code>animation-iteration-count</code>]  // 播放次数</p>
<p>[<code>animation-direction</code>] // 播放顺序</p>
<p>[<code>animation-fill-mode</code>]  // 播放前或停止后设置相应样式</p>
<p>[<code>animation-play-state</code>]; // 控制动画运行或暂停</p>
</blockquote>
<h5 id="1-时间函数（animation-timing-function）"><a href="#1-时间函数（animation-timing-function）" class="headerlink" title="1. 时间函数（animation-timing-function）"></a>1. 时间函数（animation-timing-function）</h5><p><code>animation-timing-function</code>属性定义了动画的播放速度曲线。<br>可选配置参数为:<br><code>ease</code>   (默认值)、<br><code>ease-in</code>、<br><code>ease-out</code>、<br><code>ease-in-out</code>、<br><code>linear</code>、<br><code>cubic-bezier(number, number, number, number)</code></p>
<p><img data-src="time-function.gif"></p>
<h5 id="2-动画延迟（animation-delay）"><a href="#2-动画延迟（animation-delay）" class="headerlink" title="2. 动画延迟（animation-delay）"></a>2. 动画延迟（animation-delay）</h5><p><code>animation-delay</code>属性定义动画是从何时开始播放，即动画应用在元素上的到动画开始的这段时间的长度。<br>默认值0s，表示动画在该元素上后立即开始执行。<br>该值以秒(s)或者毫秒(ms)为单位。</p>
<h5 id="3-动画迭代次数（animation-iteration-count）"><a href="#3-动画迭代次数（animation-iteration-count）" class="headerlink" title="3. 动画迭代次数（animation-iteration-count）"></a>3. 动画迭代次数（animation-iteration-count）</h5><p><code>animation-iteration-count</code>该属性就是定义我们的动画播放的次数。次数可以是1次或者无限循环（默认值为1）</p>
<blockquote>
<p>single-animation-iteration-count = <strong>infinite</strong> | number</p>
</blockquote>
<h5 id="4-动画方向（animation-direction）"><a href="#4-动画方向（animation-direction）" class="headerlink" title="4. 动画方向（animation-direction）"></a>4. 动画方向（animation-direction）</h5><p><code>animation-direction</code>属性表示CSS动画是否反向播放。<br>可选配置参数为:</p>
<blockquote>
<p>single-animation-direction = normal | reverse | alternate | alternate-reverse</p>
</blockquote>
<ul>
<li>animation-direction: normal 正序播放</li>
<li>animation-direction: reverse 倒序播放</li>
<li>animation-direction: alternate 交替播放</li>
<li>animation-direction: alternate-reverse 反向交替播放</li>
<li>animation-direction: normal, reverse</li>
<li>animation-direction: alternate, reverse, normal</li>
</ul>
<h5 id="5-动画填充模式（animation-fill-mode）"><a href="#5-动画填充模式（animation-fill-mode）" class="headerlink" title="5.动画填充模式（animation-fill-mode）"></a>5.动画填充模式（animation-fill-mode）</h5><p><code>animation-fill-mode</code>是指给定动画播放前后应用元素的样式。</p>
<blockquote>
<p>single-animation-fill-mode = <strong>none **| **forwards **| **backwards **| **both</strong></p>
</blockquote>
<ul>
<li>animation-fill-mode: none 动画执行前后不改变任何样式</li>
<li>animation-fill-mode: forwards 保持目标动画最后一帧的样式</li>
<li>animation-fill-mode: backwards 保持目标动画第一帧的样式</li>
<li>animation-fill-mode: both 动画将会执行 forwards 和 backwards 执行的动作。</li>
</ul>
<h5 id="6-动画播放状态（animation-play-state）"><a href="#6-动画播放状态（animation-play-state）" class="headerlink" title="6.动画播放状态（animation-play-state）"></a>6.动画播放状态（animation-play-state）</h5><p><code>animation-play-state:</code> 定义动画是否运行或者暂停。可以查询它来确定动画是否运行。默认值为<strong>running</strong></p>
<blockquote>
<p>有时，动画播放过程中，会突然停止。这时，默认行为是跳回到动画的开始状态。</p>
<p>如果鼠标移走，色块立刻回到动画开始状态。如果想让动画保持突然终止时的状态，就要使用animation-play-state属性。</p>
</blockquote>
<blockquote>
<p>single-animation-timing-function = <strong>running</strong> | <strong>paused</strong></p>
</blockquote>
<ul>
<li>running 动画正常播放</li>
<li>paused 动画暂停播放</li>
</ul>
<p><img data-src="description.png"></p>
<h4 id="浏览器前缀"><a href="#浏览器前缀" class="headerlink" title="浏览器前缀"></a>浏览器前缀</h4><p>目前，IE 10和Firefox（&gt;= 16）支持没有前缀的animation，而chrome不支持，所以必须使用webkit前缀。</p>
<p>也就是说，实际运用中，代码必须写成下面的样子。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-animation</span>: <span class="number">1s</span> rainbow;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> rainbow &#123;</span><br><span class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  0% &#123; <span class="attribute">background</span>: <span class="number">#c00</span>; &#125;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange; &#125;</span><br><span class="line">  100% &#123; <span class="attribute">background</span>: yellowgreen; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、keyframes的写法"><a href="#2、keyframes的写法" class="headerlink" title="2、keyframes的写法"></a>2、keyframes的写法</h3><p><code>keyframes</code>关键字用来定义动画的各个状态，它的写法相当自由。</p>
<p>0%可以用from代表，100%可以用to代表。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  <span class="selector-tag">from</span> &#123; <span class="attribute">background</span>: <span class="number">#c00</span> &#125;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果省略某个状态，浏览器会自动推算中间状态，所以下面都是合法的写法。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  50% &#123; <span class="attribute">background</span>: orange &#125;</span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">  <span class="selector-tag">to</span> &#123; <span class="attribute">background</span>: yellowgreen &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>甚至，可以把多个状态写在一行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> pound &#123;</span><br><span class="line">  <span class="selector-tag">from</span>，<span class="selector-tag">to</span> &#123; <span class="attribute">transform</span>: none; &#125;</span><br><span class="line">  50% &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.2</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外一点需要注意的是，浏览器从一个状态向另一个状态过渡，是平滑过渡。steps函数可以实现分步过渡。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: <span class="number">1s</span> rainbow infinite <span class="built_in">steps</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>附</strong>一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation">MDN的例子</a>：<strong>赛隆人之眼(赛隆人</strong>是一个虚构的生化人种族,出自科幻电视系列剧星际大争霸系列**)**</p>
<p>然后引出  <strong>渐变色</strong>  的概念，<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Using_CSS_gradients">MDN 使用CSS渐变</a> 的传送门</p>
</blockquote>
<h2 id="四、CSS-渐变"><a href="#四、CSS-渐变" class="headerlink" title="四、CSS 渐变"></a>四、CSS 渐变</h2><p><strong>CSS 渐变</strong><code>&lt;image&gt;</code> 类型的一种特殊类型 <code>&lt;gradient&gt;</code>表示，由两种或多种颜色之间的渐进过渡组成。您可以选择三种类型的渐变：线性 (由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/linear-gradient"><code>linear-gradient</code></a> 函数创建)，径向(由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/radial-gradient"><code>radial-gradient()</code></a> 函数创建) 和圆锥 (由 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/conic-gradient"><code>conic-gradient</code></a> 函数创建)。您还可以使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeating-linear-gradient"><code>repeating-linear-gradient</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/repeating-radial-gradient"><code>repeating-radial-gradient</code></a> 函数创建重复渐变。</p>
<p>渐变可以在任何使用 <code>&lt;image&gt;</code> 的地方使用，例如在背景中。 由于渐变是动态生成的，因此它们可以消除对传统用于实现类似效果的栅格图像文件的需求。 此外，由于渐变是由浏览器生成的，因此在放大时它们看起来比栅格图像更好，并且可以动态调整大小。</p>
<h3 id="1、使用线性渐变"><a href="#1、使用线性渐变" class="headerlink" title="1、使用线性渐变"></a>1、使用线性渐变</h3><p>线性渐变创建了一条沿直线前进的颜色带。</p>
<h4 id="基础线性渐变"><a href="#基础线性渐变" class="headerlink" title="基础线性渐变"></a>基础线性渐变</h4><p>要创建最基本的渐变类型，您只需指定两种颜色即可。 这些被称为色标。 至少指定两个色标，也可以指定任意数量。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.simple-linear</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(blue, pink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="改变渐变方向"><a href="#改变渐变方向" class="headerlink" title="改变渐变方向"></a>改变渐变方向</h4><p>默认情况下，线性渐变的方向是从上到下， 你可以指定一个值来改变渐变的方向。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.horizontal-gradient</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, blue, pink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="对角线渐变"><a href="#对角线渐变" class="headerlink" title="对角线渐变"></a>对角线渐变</h4><p>你甚至可以设置渐变方向为从一个对角到另一个对角。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.diagonal-gradient</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom right, blue, pink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="设置渐变角度"><a href="#设置渐变角度" class="headerlink" title="设置渐变角度"></a>设置渐变角度</h4><p>如果你想要更精确地控制渐变的方向，你可以给渐变设置一个具体的角度。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.angled-gradient</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">70deg</span>, blue, pink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、声明颜色和创建效果"><a href="#2、声明颜色和创建效果" class="headerlink" title="2、声明颜色和创建效果"></a>2、声明颜色和创建效果</h3><p>所有的CSS渐变类型都是一个位置依赖的颜色范围。CSS渐变产生的颜色可以随位置不断变化，从而产生平滑的颜色过渡。也可以创建纯色带和两种颜色之间的硬过渡。以下内容适用于所有渐变函数：</p>
<h4 id="使用多种颜色"><a href="#使用多种颜色" class="headerlink" title="使用多种颜色"></a>使用多种颜色</h4><p>无需局限于使用两种颜色，你想使用多少种颜色都可以！ 默认情况下，所设置颜色会均匀分布在渐变路径中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.auto-spaced-linear-gradient</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(red, yellow, blue, orange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="颜色终止位置"><a href="#颜色终止位置" class="headerlink" title="颜色终止位置"></a>颜色终止位置</h4><p>你不需要让你设置的颜色在默认位置终止。 你可以通过给每个颜色设置0，1%或者2%或者其他的绝对数值来调整它们的位置。如果你将位置设置为百分数， <code>0%</code> 表示起始点, 而100%表示终点，但是如果需要的话你也可以设置这个范围之外的其他值来达到你想要的效果。如果有些位置你没有明确设置，那么它将会被自动计算，第一种颜色会在0%处停止，而最后一种颜色是100%，至于其他颜色则是在它邻近的两种颜色的中间停止。 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.multicolor-linear</span> &#123; </span><br><span class="line">   <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to left, lime <span class="number">28px</span>, red <span class="number">77%</span>, cyan);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建实线"><a href="#创建实线" class="headerlink" title="创建实线"></a>创建实线</h4><p>要在两种颜色之间创建一条硬线，即创建一个条纹而不是逐渐过渡，可以将相邻的颜色停止设置为相同的位置。在此示例中，两种颜色在50%标记处共享一个颜色停止点，即渐变的一半：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.striped</span> &#123; </span><br><span class="line">   <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom left, cyan <span class="number">50%</span>, palegoldenrod <span class="number">50%</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="渐变提示"><a href="#渐变提示" class="headerlink" title="渐变提示"></a>渐变提示</h4><p>默认情况下，渐变会平滑地从一种颜色过渡到另一种颜色。你可以通过设置一个值来将渐变的中心点移动到指定位置。 在如下示例中, 我们将渐变的中心点由50%设为10%。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.color-hint</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(blue, <span class="number">10%</span>, pink);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.simple-linear</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(blue, pink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多内容如<strong>在图片上的叠加鉴别</strong>、<strong>增加不透明度</strong>  以及其他的<strong>渐变函数</strong>  见<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Using_CSS_gradients">MDN</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 动画及图形解决方案</title>
    <url>/2020/09/09/CSS-animation-and-graphics-solutions/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>CSS动画库 （转载自知乎博主<a href="https://zhuanlan.zhihu.com/p/101563245">十个推荐的CSS动画库</a>）</p>
<p>一些CSS牛逼样式图形</p>
</blockquote>
<a id="more"></a>

<h2 id="一、十个值得推荐的CSS动画库"><a href="#一、十个值得推荐的CSS动画库" class="headerlink" title="一、十个值得推荐的CSS动画库"></a>一、十个值得推荐的CSS动画库</h2><h3 id="1-Animista-生成器"><a href="#1-Animista-生成器" class="headerlink" title="1. Animista(生成器)"></a>1. <a href="https://animista.net/play/basic/slide-bck">Animista</a>(生成器)</h3><blockquote>
<p>emmm,简直不要太爽！可视化自动生成！</p>
</blockquote>
<h3 id="2-Animation-css（调用库）"><a href="#2-Animation-css（调用库）" class="headerlink" title="2. Animation.css（调用库）"></a>2. <a href="https://animate.style/">Animation.css</a>（调用库）</h3><p>当然，我也必须提及<code>Animate CSS</code>，也许这是一个众所周知的动画库。</p>
<p><strong>1.使用</strong></p>
<p>Install with npm:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install animate.css --save</span></span><br></pre></td></tr></table></figure>

<p>or add it directly to your webpage using a CDN:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span></span></span><br><span class="line"><span class="tag">    <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">href</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在你需要添加动画的元素上添加<code>animated</code>类名，然后就是添加动画的名称。<strong>比如</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;animated slideInLeft&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你希望动画是持久的，你可以添加<code>infinite</code>类，这样动画将不停地重复自身。</p>
<ul>
<li><strong>通过 JavaScript</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.my-element&#x27;</span>).classList.add(<span class="string">&#x27;animated&#x27;</span>, <span class="string">&#x27;slideInLeft&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>通过 Jquery</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.my-element&quot;</span>).addClass(<span class="string">&quot;animated slideInLeft&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>2.额外的特性</strong></p>
<p><code>Animate CSS</code>为你提供了一些基本的类去操作动画的延时和速度。</p>
<ul>
<li>延时</li>
</ul>
<p>你可以通过使用<code>delay</code>类来延迟你的动画。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;animated slideInLeft delay-&#123;1-5&#125;&quot;</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>速度</li>
</ul>
<p>你可以通过添加下表中的类来控制动画的速度。</p>
<table>
<thead>
<tr>
<th>Class name</th>
<th>Speed time</th>
</tr>
</thead>
<tbody><tr>
<td>slow</td>
<td>2s</td>
</tr>
<tr>
<td>slower</td>
<td>3s</td>
</tr>
<tr>
<td>fast</td>
<td>800ms</td>
</tr>
<tr>
<td>faster</td>
<td>500ms</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;animated slideInLeft slow|slower|fast|faster&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>3.在vue中使用animate.css</strong></p>
<p>命令行中执行：<code>npm install animate.css --save</code></p>
<p>第二步：<code>main.js</code>中引入及使用：<code>import animated from &#39;animate.css&#39;</code></p>
<p><code>Vue.use(animated)</code></p>
<p>vue模板中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ty&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 直接使用animated中的动画class名，注意：必须使用animated这个class名，否则动画会无效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box animated bounceInDown&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Vivify（调用库）"><a href="#3-Vivify（调用库）" class="headerlink" title="3. Vivify（调用库）"></a>3. <a href="http://vivify.mkcreative.cz/">Vivify</a>（调用库）</h3><p>它的使用一样，有自己更多的类，但是也扩展了些。添加<code>vivify</code>类到元素中，而不是<code>animated</code>。比如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;vivify slideInLeft&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 Javascript</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.my-element&#x27;</span>).classList.add(<span class="string">&#x27;vivify&#x27;</span>, <span class="string">&#x27;slideInLeft&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 Jquery</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.my-element&quot;</span>).addClass(<span class="string">&quot;vivify slideInLeft&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>就像<code>Animate CSS</code>一样，<code>Vivify</code>也为你提供了一些类来控制动画的持续时间和延迟时间。</p>
<p>延迟和持续时间的类在下面的间隔中可用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;delay|duration-&#123;100|150|200|250...1000|1250|1500|1750...10750&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：值的单位是毫秒（ms）。1000ms = 1s</p>
</blockquote>
<h3 id="4-Magic-Animations-CSS3（调用库）"><a href="#4-Magic-Animations-CSS3（调用库）" class="headerlink" title="4. Magic Animations CSS3（调用库）"></a>4. <a href="https://www.minimamente.com/project/magic/">Magic Animations CSS3</a>（调用库）</h3><blockquote>
<p>官网暂无相应（可能我不会用）</p>
</blockquote>
<p>这个动画库有些不错并且流畅的动画，我特别喜欢<code>3D</code>动画。</p>
<p>没什么好说的，自己去尝试下，玩下动画。</p>
<p>你可以添加<code>magictime &#123;animation_name&#125;</code>到你的元素中，如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;magictime fadeIn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 Javascript</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.my-element&#x27;</span>).classList.add(<span class="string">&#x27;magictime&#x27;</span>, <span class="string">&#x27;fadeIn&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 Jquery</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.my-element&quot;</span>).addClass(<span class="string">&quot;magictime fadeIn&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-cssanimation-io（调用库）"><a href="#5-cssanimation-io（调用库）" class="headerlink" title="5. cssanimation.io（调用库）"></a>5. <a href="http://cssanimation.io/index.html">cssanimation.io</a>（调用库）</h3><blockquote>
<p>此时，我打不开它。。。</p>
</blockquote>
<p><code>cssanimation.io</code>是一大堆不同动画的集合，总共大约有200个，真是太神奇了。</p>
<p>如果在这里都找不到你想要的动画，那你在哪都找不到了。</p>
<p>它的使用方式类似<code>animista</code>。比如，你可以直接选择动画，然后直接从网站中获取，或者下载整个库。</p>
<p><strong>使用</strong></p>
<p>为你的元素添加<code>cssanimation &#123;animation_name&#125;</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cssanimation fadeIn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 Javascript</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.my-element&#x27;</span>).classList.add(<span class="string">&#x27;cssanimation&#x27;</span>,<span class="string">&#x27;fadeIn&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 Jquery</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.my-element&quot;</span>).addClass(<span class="string">&quot;cssanimation fadeIn&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>你也可以添加<code>infinite</code>类，以便动画不断重复。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cssanimation fadeIn infinite&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外，<code>cssanimations.io</code>为你提供了动画字母的功能。为了实现这个，你需要在<code>head</code>标签中引入<code>letteranimation.js</code>文件，然后在你的文本元素中添加<code>le&#123;animation_name&#125;</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cssanimation leSnake&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>想要字母动画有序进行，添加<code>sequence</code>类；想要字母动画无序进行，添加<code>random</code>类。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cssanimation leSnake &#123;sequence|random&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-Angrytools（生成器）"><a href="#6-Angrytools（生成器）" class="headerlink" title="6. Angrytools（生成器）"></a>6. <a href="https://angrytools.com/css/animation/">Angrytools</a>（生成器）</h3><p>如果使用生成器（<code>Angrytools</code>不错），<code>Angrytools</code>实际上是一个集合，其中还包括<code>CSS</code>动画生成器。</p>
<p>这个网站也为你提供了定制动画的功能，比如持续时间和延迟时间。</p>
<p>最重要的是，你可以在时间线上添加<code>keyframes（关键帧）</code>，并且你可以直接在那里写代码。而且，你也可以编辑现有的一个效果。</p>
<h3 id="7-Hover-css（调用库）"><a href="#7-Hover-css（调用库）" class="headerlink" title="7. Hover.css（调用库）"></a>7. <a href="http://ianlunn.github.io/Hover/">Hover.css</a>（调用库）</h3><p><code>Hover.css</code>是众多<code>CSS</code>动画的集合，与上面的动画不同，<strong>每次将元素悬停时</strong>都会触发。</p>
<blockquote>
<p>一组CSS3驱动的悬停效果，可以应用到链接，按钮，logos，svg，图片特性和其他。</p>
</blockquote>
<p>它有一些惊人的动效。而且它还有用于动画图标的类，比如超棒的字体。</p>
<p><strong>使用</strong></p>
<p>使用很简单：将类名添加到你的元素中，比如：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;button class=&quot;hvr-fade&quot;&gt;Hover me!&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="8-WickedCSS-（调用库）"><a href="#8-WickedCSS-（调用库）" class="headerlink" title="8. WickedCSS （调用库）"></a>8. <a href="http://kristofferandreasen.github.io/wickedCSS/#">WickedCSS</a> （调用库）</h3><p><code>WickedCSS</code>是一个小型的<code>CSS</code>动画库，没有太多的动画体，但是它至少有很棒的动画。它们中大多数是我们熟悉的基本动画，但是它们真是很简洁。</p>
<p>使用方法很简单，只要为你的元素添加动画名就行了。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bounceIn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 Javascript</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.my-element&#x27;</span>).classList.add(<span class="string">&#x27;bounceIn&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 Jquery</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.my-element&quot;</span>).addClass(<span class="string">&quot;bounceIn&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="9-Three-Dots（调用库）"><a href="#9-Three-Dots（调用库）" class="headerlink" title="9.  Three Dots（调用库）"></a>9.  <a href="https://nzbin.github.io/three-dots/">Three Dots</a>（调用库）</h3><blockquote>
<p><code>Three Dots</code>是<code>CSS</code>加载动画的集合，仅由三个简单元素制作而成的三个点创建。</p>
</blockquote>
<p><strong>使用</strong></p>
<p>创建一个<code>div</code>元素，然后添加动画名。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dot-elastic&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="10-CSSHake（调用库）"><a href="#10-CSSHake（调用库）" class="headerlink" title="10. CSSHake（调用库）"></a>10. <a href="https://elrumordelaluz.github.io/csshake/">CSSHake</a>（调用库）</h3><p>最后，来点摇晃的抖动。</p>
<p>如其名，<code>CSShake</code>包含了不同类型的抖动动画的<code>CSS</code>动画库。</p>
<ul>
<li><strong>使用</strong></li>
</ul>
<p>添加<code>shake &#123;animation_name&#125;</code>到你的元素中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;shake shake-hard&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 Javascript</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">&#x27;.my-element&#x27;</span>).classList.add(<span class="string">&#x27;shake&#x27;</span>,<span class="string">&#x27;shake-hard&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 Jquery</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;.my-element&quot;</span>).addClass(<span class="string">&quot;shake shake-hard&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="二、神奇的CSS多边形绘制"><a href="#二、神奇的CSS多边形绘制" class="headerlink" title="二、神奇的CSS多边形绘制"></a>二、神奇的CSS多边形绘制</h2><blockquote>
<p>转载自 <a href="https://www.imooc.com/article/27838">手记</a></p>
</blockquote>
<p>CSS3之前，我们能做的只有矩形，四四方方，条条框框</p>
<p>CSS3出来后，我们有了更广阔的施展空间，通过</p>
<ul>
<li><code>border-radius</code></li>
<li><code>border</code></li>
<li><code>transform</code></li>
<li>伪元素配合</li>
<li>gradient 渐变</li>
</ul>
<p>我们能够作出非常多的几何图形。</p>
<h3 id="传统方式绘制"><a href="#传统方式绘制" class="headerlink" title="传统方式绘制"></a>传统方式绘制</h3><p>除去最常见的矩形，圆形（<code>border-radius</code>），下面稍微列举一些其他几何图形：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 三角形 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;traingle&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 切角 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;notching&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 梯形 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;trapezoid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 五边形 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;pentagon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 六边形 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hexagon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 八边形 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;octagon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- star --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;star&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 六角星 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sixstar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 八角星 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;eightstar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 十二角星 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;twelvestar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 椭圆 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ellipse&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-三角形"><a href="#1-三角形" class="headerlink" title="1. 三角形"></a>1. 三角形</h4><p>通常会使用透明的border模拟出一个三角形：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.traingle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid yellowgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="shape1.png"></p>
<h4 id="2-切角"><a href="#2-切角" class="headerlink" title="2. 切角"></a>2. 切角</h4><p>《CSS Secret》里面的方法，采用多重线性渐变实现切角。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.notching</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="number">135deg</span>, transparent <span class="number">15px</span>, yellowgreen <span class="number">0</span>) top left,</span><br><span class="line">        <span class="built_in">linear-gradient</span>(-<span class="number">135deg</span>, transparent <span class="number">15px</span>, yellowgreen <span class="number">0</span>) top right,</span><br><span class="line">        <span class="built_in">linear-gradient</span>(-<span class="number">45deg</span>, transparent <span class="number">15px</span>, yellowgreen <span class="number">0</span>) bottom right,</span><br><span class="line">        <span class="built_in">linear-gradient</span>(<span class="number">45deg</span>, transparent <span class="number">15px</span>, yellowgreen <span class="number">0</span>) bottom left;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="shape2.png"></p>
<h4 id="3-梯形"><a href="#3-梯形" class="headerlink" title="3. 梯形"></a>3. 梯形</h4><p>利用伪元素加旋转透视实现梯形：</p>
<p><img data-src="shape3.png"></p>
<h4 id="4-五边形"><a href="#4-五边形" class="headerlink" title="4. 五边形"></a>4. 五边形</h4><p>梯形加上三角形，很容易就组合成一个五边形，这里需要借助一个伪元素实现：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.pentagon</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">100px</span><span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">60px</span> solid yellowgreen;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.pentagon</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">60px</span> solid yellowgreen;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">70px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">70px</span> solid transparent;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="shape4.png"></p>
<h4 id="5-六边形"><a href="#5-六边形" class="headerlink" title="5. 六边形"></a>5. 六边形</h4><p>看看上面的梯形，如果两个反方向且底边同样大小的梯形，叠加在一起，是不是就能得到一个六边形</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.hexagon</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">120px</span><span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">60px</span> solid yellowgreen;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hexagon</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">60px</span> solid yellowgreen;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">40px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img data-src="shape5.png"></p>
<h4 id="6-八边形"><a href="#6-八边形" class="headerlink" title="6. 八边形"></a>6. 八边形</h4><p>六边形都解决了，八边形也不在话下，一个矩形加上两个梯形，可以合成一个八边形。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.octagon</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background</span>: yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.octagon</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">30px</span> solid yellowgreen;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.octagon</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">30px</span> solid yellowgreen;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="shape6.png"></p>
<h4 id="7-五角星"><a href="#7-五角星" class="headerlink" title="7. 五角星"></a>7. 五角星</h4><p>好的，探索完多边形，我们继续探索X角星——-这里使用 3 个三角形叠加旋转在一起实现。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.star</span> &#123;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">position</span>: relative;</span><br><span class="line">   <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">   <span class="attribute">border-bottom</span>: <span class="number">70px</span>  solid yellowgreen;</span><br><span class="line">   <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">   <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">35deg</span>) <span class="built_in">scale</span>(.<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">80px</span> solid yellowgreen;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">30px</span> solid transparent;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">45px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">65px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">35deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">color</span>: yellowgreen;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">105px</span>;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">70px</span> solid yellowgreen;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">70deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="shape7.png"></p>
<h4 id="8-六角星"><a href="#8-六角星" class="headerlink" title="8. 六角星"></a>8. 六角星</h4><p>六角星呢？想象一下，一个向上的三角形 ▲，叠加上一个向下的三角形 ▼，就可以得到一个六边形：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sixstar</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sixstar</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparen;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid yellowgreen;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><img data-src="shape8.png"></p>
<h4 id="9-八角星"><a href="#9-八角星" class="headerlink" title="9. 八角星"></a>9. 八角星</h4><p>八角星呢？八个角那么多呢。其实使用两个矩形进行旋转拼接就可以了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.eightstar</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">100px</span><span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.eightstar</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="shape9.png"></p>
<h4 id="10-十二角星"><a href="#10-十二角星" class="headerlink" title="10. 十二角星"></a>10. 十二角星</h4><p>好。最后多角星再来一个十二级角星。在八角星的基础上，再增加一个矩形，就能得到十二角啦。也就是要过第一个伪元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.twelvestar</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">100px</span><span class="meta">!important</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.twelvestar</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.twelvestar</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">60deg</span>);</span><br><span class="line">    <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="shape10.png"></p>
<h4 id="11-椭圆"><a href="#11-椭圆" class="headerlink" title="11. 椭圆"></a>11. 椭圆</h4><p>最后，再来使用传统的方法画一个椭圆，过去 CSS3 画椭圆，基本上只能借助 border 实现。</p>
<p>这里使用 border 画一个蛋的形状：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ellipse</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">160px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: yellowgreen;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>` <span class="number">50%</span> <span class="number">50%</span> <span class="number">50%</span> / <span class="number">60%</span> <span class="number">60%</span> <span class="number">40%</span> <span class="number">40%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="shape11.png"></p>
<h4 id="12-爱心"><a href="#12-爱心" class="headerlink" title="12. 爱心"></a>12. 爱心</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#heart</span> &#123; </span><br><span class="line"><span class="attribute">position</span>: relative; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">90px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-id">#heart</span><span class="selector-pseudo">:before</span>, </span><br><span class="line"><span class="selector-id">#heart</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line"><span class="attribute">position</span>: absolute; </span><br><span class="line"><span class="attribute">content</span>: <span class="string">&quot;&quot;</span>; </span><br><span class="line"><span class="attribute">left</span>: <span class="number">50px</span>; </span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">50px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">80px</span>; </span><br><span class="line"><span class="attribute">background</span>: red; </span><br><span class="line"><span class="attribute">-moz-border-radius</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">0</span> <span class="number">0</span>; </span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">0</span> <span class="number">0</span>; </span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-o-transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-webkit-transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">-moz-transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">-ms-transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">-o-transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">100%</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-id">#heart</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>; </span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-o-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-webkit-transform-origin</span>: <span class="number">100%</span> <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">-moz-transform-origin</span>: <span class="number">100%</span> <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">-ms-transform-origin</span>: <span class="number">100%</span> <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">-o-transform-origin</span>: <span class="number">100%</span> <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">transform-origin </span>:<span class="number">100%</span> <span class="number">100%</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="shape13.png"></p>
<h4 id="13-无穷大"><a href="#13-无穷大" class="headerlink" title="13. 无穷大"></a>13. 无穷大</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#infinity</span> &#123; </span><br><span class="line"><span class="attribute">position</span>: relative; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">212px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-id">#infinity</span><span class="selector-pseudo">:before</span>, </span><br><span class="line"><span class="selector-id">#infinity</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line"><span class="attribute">content</span>: <span class="string">&quot;&quot;</span>; </span><br><span class="line"><span class="attribute">position</span>: absolute; </span><br><span class="line"><span class="attribute">top</span>: <span class="number">0</span>; </span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">60px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">60px</span>; </span><br><span class="line"><span class="attribute">border</span>: <span class="number">20px</span> solid red; </span><br><span class="line"><span class="attribute">-moz-border-radius</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">0</span> <span class="number">50px</span>; </span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">0</span> <span class="number">50px</span>; </span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-o-transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-id">#infinity</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line"><span class="attribute">left</span>: auto; </span><br><span class="line"><span class="attribute">right</span>: <span class="number">0</span>; </span><br><span class="line"><span class="attribute">-moz-border-radius</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">0</span>; </span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">0</span>; </span><br><span class="line"><span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">-o-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); </span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img data-src="shape14.png"></p>
<h4 id="14-食逗人（Pac-Man）"><a href="#14-食逗人（Pac-Man）" class="headerlink" title="14. 食逗人（Pac-Man）"></a>14. 食逗人（Pac-Man）</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#pacman</span> &#123; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">0px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">0px</span>; </span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">60px</span> solid transparent; </span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">60px</span> solid red; </span><br><span class="line"><span class="attribute">border-left</span>: <span class="number">60px</span> solid red; </span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">60px</span> solid red; </span><br><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">60px</span>; </span><br><span class="line"><span class="attribute">border-top-right-radius</span>: <span class="number">60px</span>; </span><br><span class="line"><span class="attribute">border-bottom-left-radius</span>: <span class="number">60px</span>; </span><br><span class="line"><span class="attribute">border-bottom-right-radius</span>: <span class="number">60px</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img data-src="shape15.png"></p>
<h4 id="15-提示对话框"><a href="#15-提示对话框" class="headerlink" title="15. 提示对话框"></a>15. 提示对话框</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#talkbubble</span> &#123; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">120px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">80px</span>; </span><br><span class="line"><span class="attribute">background</span>: red; </span><br><span class="line"><span class="attribute">position</span>: relative; </span><br><span class="line"><span class="attribute">-moz-border-radius</span>: <span class="number">10px</span>; </span><br><span class="line"><span class="attribute">-webkit-border-radius</span>: <span class="number">10px</span>; </span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">10px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-id">#talkbubble</span><span class="selector-pseudo">:before</span> &#123; </span><br><span class="line"><span class="attribute">content</span>:<span class="string">&quot;&quot;</span>; </span><br><span class="line"><span class="attribute">position</span>: absolute; </span><br><span class="line"><span class="attribute">right</span>: <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">top</span>: <span class="number">26px</span>; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">0</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">0</span>; </span><br><span class="line"><span class="attribute">border-top</span>: <span class="number">13px</span> solid transparent; </span><br><span class="line"><span class="attribute">border-right</span>: <span class="number">26px</span> solid red; </span><br><span class="line"><span class="attribute">border-bottom</span>: <span class="number">13px</span> solid transparent; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img data-src="shape16.png"></p>
<h4 id="16-阴阳八卦"><a href="#16-阴阳八卦" class="headerlink" title="16. 阴阳八卦"></a>16. 阴阳八卦</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#yin-yang</span> &#123; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">96px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">48px</span>; </span><br><span class="line"><span class="attribute">background</span>: <span class="number">#eee</span>; </span><br><span class="line"><span class="attribute">border-color</span>: red; </span><br><span class="line"><span class="attribute">border-style</span>: solid; </span><br><span class="line"><span class="attribute">border-width</span>: <span class="number">2px</span> <span class="number">2px</span> <span class="number">50px</span> <span class="number">2px</span>; </span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">position</span>: relative; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-id">#yin-yang</span><span class="selector-pseudo">:before</span> &#123; </span><br><span class="line"><span class="attribute">content</span>: <span class="string">&quot;&quot;</span>; </span><br><span class="line"><span class="attribute">position</span>: absolute; </span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>; </span><br><span class="line"><span class="attribute">left</span>: <span class="number">0</span>; </span><br><span class="line"><span class="attribute">background</span>: <span class="number">#eee</span>; </span><br><span class="line"><span class="attribute">border</span>: <span class="number">18px</span> solid red; </span><br><span class="line"><span class="attribute">border-radius</span>: <span class="number">100%</span>; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">12px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">12px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-id">#yin-yang</span><span class="selector-pseudo">:after</span> &#123; </span><br><span class="line"><span class="attribute">content</span>: <span class="string">&quot;&quot;</span>; </span><br><span class="line"><span class="attribute">position</span>: absolute; </span><br><span class="line"><span class="attribute">top</span>: <span class="number">50%</span>; </span><br><span class="line"><span class="attribute">left</span>: <span class="number">50%</span>; </span><br><span class="line"><span class="attribute">background</span>: red; </span><br><span class="line"><span class="attribute">border</span>: <span class="number">18px</span> solid <span class="number">#eee</span>; </span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">100%</span>; </span><br><span class="line"><span class="attribute">width</span>: <span class="number">12px</span>; </span><br><span class="line"><span class="attribute">height</span>: <span class="number">12px</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img data-src="shape17.png"></p>
<h3 id="CSS3新绘制方式"><a href="#CSS3新绘制方式" class="headerlink" title="CSS3新绘制方式"></a>CSS3新绘制方式</h3><blockquote>
<p>上面所讲述的是使用传统 CSS3 的方式绘制几何图形，前人栽树后人乘凉，之前的大牛们在 CSS 绘制几何图形上已经做了非常深入的研究，更多的 CSS 图形你可以戳这里：The Shapes of CSS 。接下来我们将要了解一些更高级的绘制几何图形的方法。</p>
</blockquote>
<ul>
<li>clip-path</li>
<li>shape-outside</li>
</ul>
<h4 id="1-clip-path"><a href="#1-clip-path" class="headerlink" title="1. clip-path"></a>1. clip-path</h4><p>CSS 新属性 <code>clip-path</code>，意味裁剪路径的意思，让我们可以很便捷的生成各种几何图形。</p>
<p>clip-path 通过定义特殊的路径，实现我们想要的图形。而这个路径，正是 SVG 中的 path 。</p>
<p>看看它的 API：</p>
<p><img data-src="ref1.png"></p>
<p>看上去很多，其实很好理解，如果接触过 SVG 的 path，其实就是照搬 SVG 的 path 的一些定义。换言之，如果没有接触过 SVG，看完本文后再去学习 SVG 路径 ，也会十分容易上手。</p>
<p>根据不同的语法，我们可以生成不同的图形。</p>
<p>例如 <code>clip-path: circle(50px at 50px 50px)</code> 表示在元素的 （50px, 50px）处，裁剪生成一个半径为 50px 的圆。</p>
<p>而整个 <code>clip-path</code> 属性，最为重要的当属 <code>polygon</code>，可以利用 <code>polygon</code> 生成任意多边形。clip-path 示例</p>
<p>下面分别列举使用 clip-path 生成一个圆形和一个十边形。</p>
<p><img data-src="shape12.png"></p>
<p> <code>clip-path: polygon(50% 0%, 80% 10%, 100% 35%, 100% 70%, 80% 90%, 50% 100%, 20% 90%, 0% 70%, 0% 35%, 20% 10%)</code> 中，依次列出了 10 个坐标点。我们的图形就是依次连接这 10 个坐标点形成一个裁切图形。</p>
<p>当然，这里采用的是百分比，也可以使用具体的数值。</p>
<h4 id="2-clip-path-动画"><a href="#2-clip-path-动画" class="headerlink" title="2. clip-path 动画"></a>2. clip-path 动画</h4><p>clip-path 另外一个强大之处在于可以进行 CSS transtion 与 CSS animation，也就是过渡和动画。</p>
<p>效果见<a href="https://codepen.io/Chokcoco/pen/LLNWyZ?editors=1100">这儿</a></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">.polygon-animate</span> &#123;</span><br><span class="line">    <span class="attr">position:</span> <span class="string">absolute;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="string">200px;</span></span><br><span class="line">    <span class="attr">height:</span> <span class="string">200px;</span></span><br><span class="line">    <span class="attr">top:</span> <span class="number">50</span><span class="string">%;</span></span><br><span class="line">    <span class="attr">left:</span> <span class="number">50</span><span class="string">%;</span></span><br><span class="line">    <span class="attr">transform:</span> <span class="string">translate(-50%</span>, <span class="number">-50</span><span class="string">%);</span></span><br><span class="line">    <span class="attr">background-color:</span> <span class="string">crimson;</span></span><br><span class="line">    <span class="attr">transition:</span> <span class="string">.3s;</span></span><br><span class="line">    <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">        <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">        <span class="number">0</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">        <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">        <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">        <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">        <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">        <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">        <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">        <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span></span><br><span class="line">    <span class="string">);</span></span><br><span class="line">    <span class="attr">animation:</span> <span class="string">polygon-ani</span> <span class="string">5s</span> <span class="string">linear</span> <span class="string">infinite;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">@keyframes</span> <span class="string">polygon-ani</span> &#123;</span><br><span class="line">    <span class="number">10</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">background-color:</span> <span class="string">darkorange;</span></span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">14</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">50</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">24</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">background-color:</span> <span class="string">lemonchiffon;</span></span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">38</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">82</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">82</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">18</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">38</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">38</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">38</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">38</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">28</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">38</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">82</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">82</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">18</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">38</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">38</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">38</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">38</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">38</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">background-color:</span> <span class="string">darkturquoise;</span></span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">25</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">75</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">75</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">75</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">75</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">25</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">42</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">25</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">75</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">75</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">75</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">75</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">25</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">25</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">52</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">background-color:</span> <span class="string">darkcyan;</span></span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">90</span><span class="string">%</span> <span class="number">20</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">60</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">75</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">25</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">25</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">60</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">10</span><span class="string">%</span> <span class="number">20</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">56</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">90</span><span class="string">%</span> <span class="number">20</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">60</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">75</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">25</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">25</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">60</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">10</span><span class="string">%</span> <span class="number">20</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">66</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">background-color:</span> <span class="string">deepskyblue;</span></span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">30</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">70</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">70</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">30</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">70</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">70</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">30</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">70</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">30</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">70</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">30</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">70</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">70</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">30</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">70</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">70</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">30</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">70</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">30</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">80</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">background-color:</span> <span class="string">indigo;</span></span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">83</span><span class="string">%</span> <span class="number">12</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">43</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">94</span><span class="string">%</span> <span class="number">78</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">68</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">32</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">6</span><span class="string">%</span> <span class="number">78</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">43</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">17</span><span class="string">%</span> <span class="number">12</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">84</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">83</span><span class="string">%</span> <span class="number">12</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">43</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">94</span><span class="string">%</span> <span class="number">78</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">68</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">32</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">6</span><span class="string">%</span> <span class="number">78</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">43</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">17</span><span class="string">%</span> <span class="number">12</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">94</span><span class="string">%</span> &#123;</span><br><span class="line">        <span class="attr">background-color:</span> <span class="string">crimson;</span></span><br><span class="line">        <span class="attr">clip-path:</span> <span class="string">polygon(</span></span><br><span class="line">            <span class="number">50</span><span class="string">%</span> <span class="number">0</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">0</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span>,</span><br><span class="line">            <span class="number">100</span><span class="string">%</span> <span class="number">100</span><span class="string">%</span></span><br><span class="line">        <span class="string">);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>图形变换动画</strong></p>
<p>除此之外，我们还可以尝试，将一个完整的图形，分割成多个小图形，这也是 <code>clip-path</code> 的魅力所在，纯 CSS 的图形变换：</p>
<p><a href="https://codepen.io/Chokcoco/pen/yXOjZm">多边形切换传送门</a></p>
<p><a href="https://codepen.io/Chokcoco/pen/XgJRzO">N边形切换传送门</a></p>
<p><a href="https://codepen.io/Chokcoco/pen/NgqGOo">VueN边形切换</a></p>
<h4 id="3-shape-outside"><a href="#3-shape-outside" class="headerlink" title="3. shape-outside"></a>3. shape-outside</h4><p>最后再来看看 <code>shape-outside</code>，另外一个有趣的有能力生成几何图形的属性。</p>
<p><code>shape-outside</code> 是啥？它也有制造各种几何图形的能力，但是它只能和浮动 <code>float</code> 一起使用。</p>
<p>虽然使用上有所限制，但是它赋予了我们一种更为自由的图文混排的能力。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/shape-outside">MDN文档传送门</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 小知识点汇总</title>
    <url>/2020/09/17/css-knowledge-points-summary/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT-OUTLINE"></a>CONTENT-OUTLINE</h2><blockquote>
<p>汇总一些日常碰见的<code>CSS</code>小问题</p>
<p>–  盒子模型 <code>box-size</code></p>
<p>–  CSS <code>BFC</code></p>
<p>–  使用外部字体<code>@Font-Face</code></p>
<p>–  禁用输入法<code>（chrome、opera、Safari尚未支持）</code></p>
<p>–  高度塌陷问题</p>
<p>–  <code>margin-top</code>失效问题</p>
<p>–  <code>css overflow</code> 隐藏滚动条</p>
<p>–  <code>base64</code> 格式</p>
<p>–  CSS 文本换行总结</p>
</blockquote>
<a id="more"></a>

<h2 id="一、盒子模型"><a href="#一、盒子模型" class="headerlink" title="一、盒子模型"></a>一、盒子模型</h2><p><strong>定义：</strong><code>box-sizing</code>  允许您以特定的方式定义匹配某个区域的特定元素(W3C上的原话 )</p>
<p><strong>语法：</strong>box-sizing:content-box|border-box</p>
<p><code>content-box:</code></p>
<p>宽度和高度分别应用到元素的内容框。</p>
<p>在宽度和高度之外绘制元素的内边距和边框。</p>
<p><code>border-box:</code></p>
<p>为元素设定的宽度和高度决定了元素的边框盒。</p>
<p>就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。</p>
<p>通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</p>
<p><img data-src="css-box-sizing.png"></p>
<p><strong>浏览器兼容性：</strong></p>
<p><code>Internet Explorer</code>、<code>Opera</code> 以及 <code>Chrome</code> 支持 box-sizing 属性。</p>
<p><code>Firefox</code> 支持替代的 -moz-box-sizing 属性。</p>
<p><strong>个人理解：</strong></p>
<p>content-box:</p>
<blockquote>
<p>padding值和border值不计算到内容（content）的宽度之内</p>
<p>即：一个盒子模型的总宽度=margin+padding+border+width;</p>
</blockquote>
<p>border-box:</p>
<blockquote>
<p>content的值包含了padding值和border值</p>
<p>即：一个盒子的总宽度=margin+width.</p>
</blockquote>
<h2 id="二、CSS-BFC"><a href="#二、CSS-BFC" class="headerlink" title="二、CSS  BFC"></a>二、CSS  BFC</h2><blockquote>
<p><a href="https://www.jianshu.com/p/828023418450">原文传送门</a></p>
</blockquote>
<p><code>block formatting context </code> 块级格式化上下文<br><code>BFC</code>  是一个独立的渲染区域，只有block-level box参与，它规定了内部的block-level box如何布局，并且与这个区域外部毫不相干。<br><code>BFC</code>  就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此，包括浮动和外边距合并等等，有了这个特性我们布局的时候就不会出现意外情况了。</p>
<h3 id="哪些元素会产生BFC"><a href="#哪些元素会产生BFC" class="headerlink" title="哪些元素会产生BFC"></a>哪些元素会产生BFC</h3><p><code>display</code>属性为<code>block</code>、<code>list-item</code>、<code>table</code>的元素，会产生<code>BFC</code>  。（最常用的就是块级元素）</p>
<h3 id="什么情况下会触发BFC"><a href="#什么情况下会触发BFC" class="headerlink" title="什么情况下会触发BFC"></a>什么情况下会触发BFC</h3><ol>
<li>设置了float属性，并且不为none</li>
<li>position属性为absolute或fixed</li>
<li>display为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>、<code>inline-flex</code></li>
<li>overflow 除了 visible 以外的值<code>（hidden，auto，scroll）</code></li>
</ol>
<h3 id="BFC元素所具有的特性"><a href="#BFC元素所具有的特性" class="headerlink" title="BFC元素所具有的特性"></a>BFC元素所具有的特性</h3><ol>
<li>在bfc中，盒子从顶端开始垂直地一个接一个的排列；</li>
<li>盒子垂直方向的距离由margin决定，<strong>属于同一个BFC的盒子的margin会重叠；</strong></li>
<li>在bfc中，每一个盒子的左边缘会触碰到父容器的左边缘内部，也就是说在没有margin和padding时，父border的内边和子border的外边重叠；</li>
<li>bfc的区域不会与浮动盒子产生交集，而是紧贴浮动边缘；</li>
<li><strong>如果父盒子没有设置高度，但子盒子中有浮动元素，那么在计算bfc的高度时， 会计算上浮动盒子的高度。</strong></li>
</ol>
<h4 id="特性解读"><a href="#特性解读" class="headerlink" title="特性解读"></a>特性解读</h4><h5 id="第二条解读"><a href="#第二条解读" class="headerlink" title="第二条解读"></a>第二条解读</h5><p>在常规文档流中，两个兄弟盒子之间的垂直距离是由他们的外边距所决定的，但不是他们的两个外边距之和，而是以较大的为准。</p>
<p><img data-src="css-bfc-6.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box2</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">20px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这里我门可以看到，第一个子盒子有上边距（不会发生margin穿透的问题）；两个子盒子的垂直距离为20px而不是30px，因为垂直外边距会折叠，间距以较大的为准。</p>
<p> 那么有没有方法让垂直外边距不折叠呢？答案是：有。特性的第5条就说了：bfc就是页面上的一个独立容器，容器里面的子元素不会影响外面元素，同样外面的元素不会影响到BFC内的元素。所以就让box1或box2再处于另一个BFC中就行了。</p>
<p><img data-src="css-bfc-7.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BFC的主要用途"><a href="#BFC的主要用途" class="headerlink" title="BFC的主要用途"></a>BFC的主要用途</h3><h4 id="1-清除元素内部浮动"><a href="#1-清除元素内部浮动" class="headerlink" title="1. 清除元素内部浮动    "></a>1. 清除元素内部浮动    <i class="fas fa-star" style="color:#e97171"></i></h4><p>    只要把父元素设置为 <code>BFC</code> 就可以清除子元素的浮动，最常见的就是给父元素添加<code>overflow：hidden</code>属性。<br>    <strong>其实我有一段时间不是很明白“清除子元素浮动”这句话，人家设置的好好的浮动，你干嘛给人家清除呢，那不就是不生效了么？其实清除浮动的意思不是清除你设置的元素的浮动属性，而是清除设置了浮动属性之后给别的元素带来的影响。</strong>举个栗子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;son2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son1</span>, <span class="selector-class">.son2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.son2</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: purple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常情况下的样子是上下块撑开父元素的高度</p>
<p><img data-src="css-bfc-1.png"></p>
<p>当给两个子元素设置了float属性之后，子元素不再占据父元素的空间，此时父元素的高度就为0</p>
<p><img data-src="css-bfc-2.png"></p>
<p>当设置父元素 <code>BFC</code> 后，此时就清除了子元素浮动带来的影响，什么影响呢，就是不撑开父元素的高度的影响，那么父元素的高度就是子元素的高度</p>
<blockquote>
<p>为父元素添加  <code>overflow: hidden;</code></p>
</blockquote>
<p><img data-src="css-bfc-3.png"></p>
<h4 id="2-解决外边距合并问题"><a href="#2-解决外边距合并问题" class="headerlink" title="2. 解决外边距合并问题"></a>2. 解决外边距合并问题</h4><p>我们知道，两个盒子在一起时，当有相邻的外边距时，会取外边距较大的那一个，也就是外边距会合并，但这种情况只发生在同属一个bfc的两个盒子中间，换言之，要想解决外边距合并问题，只要把两个盒子放在不同的<code>BFC</code>中即可。</p>
<h4 id="3-制作右侧盒子自适应宽度的问题"><a href="#3-制作右侧盒子自适应宽度的问题" class="headerlink" title="3. 制作右侧盒子自适应宽度的问题"></a>3. 制作右侧盒子自适应宽度的问题</h4><p><strong>左侧盒子宽度固定，右侧宽度不固定</strong>：当在父元素中只设定一个盒子浮动，另一个不浮动时，会造成第二个盒子在第一个盒子的下方，被覆盖掉一部分（但文字不会被覆盖）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father2</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.s1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.s2</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: purple;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="css-bfc-4.png"></p>
<p>给第2个元素设定  <code>BFC</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.s2</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: purple;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: auto;</span><br><span class="line">    <span class="attribute">word-break</span>: break-all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="css-bfc-5.png"></p>
<p>当增加第一个块的宽度时，第二个块的宽度会自动缩小，实现宽度自适应。</p>
<h2 id="三、使用外部字体"><a href="#三、使用外部字体" class="headerlink" title="三、使用外部字体"></a>三、使用外部字体</h2><p>先说自己遇到的问题：有个vue项目需要用给定的字体包，一直不能正确显示</p>
<p>刚开始的时候，字体包 是放在<code>public</code>下，并在<code>src</code>中的 <code>css文件</code>中使用绝对路径引用，像这样</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;MHei-PRC-Heavy&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;/public/fonts/MHeiPRC-Heavy.ttf&quot;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="font-face-1.png"></p>
<p>但一直报错</p>
<p><img data-src="font-face-2.png"></p>
<p>后来的<strong>解决办法</strong>是 把<code>fonts文件</code>移到<code>asset</code>中，然后在引用时候使用<code>相对路径</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;MHei-PRC-Heavy&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&quot;../assets/fonts/MHeiPRC-Heavy.ttf&quot;</span>) <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，在<code>@font-face</code>中使用<code>font-weight</code>不生效（未解决）</p>
<p>下面是关于<code>@font-face</code>的内容  <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face">MDN文档</a></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote>
<p>参考自 <a href="https://www.jianshu.com/p/2fb8ef458400">font-face 详解</a></p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  [ font-family: &lt;family-name&gt;; ] ||</span><br><span class="line">  [ src: &lt;src&gt;; ] ||</span><br><span class="line">  [ unicode-range: &lt;unicode-range&gt;; ] ||</span><br><span class="line">  [ font-variant: &lt;font-variant&gt;; ] ||</span><br><span class="line">  [ font-feature-settings: &lt;font-feature-settings&gt;; ] ||</span><br><span class="line">  [ font-variation-settings: &lt;font-variation-settings&gt;; ] ||</span><br><span class="line">  [ font-stretch: &lt;font-stretch&gt;; ] ||</span><br><span class="line">  [ font-weight: &lt;font-weight&gt;; ] ||</span><br><span class="line">  <span class="selector-attr">[ font-style: &lt;font-style&gt;; ]</span></span><br><span class="line">&#125;where &lt;family-name&gt; = &lt;string&gt; | &lt;custom-ident&gt;+</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: &lt;webFontName&gt;;</span><br><span class="line">    <span class="attribute">src</span>: &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*;</span><br><span class="line">    [font-weight: &lt;weight&gt;];</span><br><span class="line">    <span class="selector-attr">[font-style: &lt;style&gt;]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>webFontName</code>: 引入的自定义字体名称，将会为指定的元素添加 <code>font-family: webFontName</code></p>
</li>
<li><p><code>source</code>: 字体路径</p>
</li>
<li><p><code>format</code>: 字体格式，用于帮助浏览器识别</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span>type  opentype  <span class="literal">true</span>type-aat   embedded-opentype   svg …</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>weight</code>: 字体是否粗体</p>
</li>
<li><p><code>style</code>: 字体样式</p>
</li>
</ul>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><ol>
<li><code>truetype - ttf</code><ul>
<li>Windows 和 Mac 最常见字体</li>
<li>RAW 格式，不为任何网站优化</li>
<li>IE9+、Firefox3.5+、Chrome4+、Safari3+、Opera10+、iOS Mobile Safari4.2+</li>
</ul>
</li>
<li><code>opentype - otf</code><ul>
<li>原始字体格式，内置在 truetype 基础之上</li>
<li>提供更多功能</li>
<li>Firefox3.5+、Chrome4.0+、Safari3.1+、Opera10.0+、iOS Mobile Safari4.2+</li>
</ul>
</li>
<li><code>web-open-font-format - woff</code><ul>
<li>Web 字体最佳格式</li>
<li>是一个开放的 truetype、opentype 压缩版本</li>
<li>支持元数据包的分离</li>
<li>IE9+、Firefox3.5+、Chrome6+、Safari3.6+、Opera11.1+</li>
</ul>
</li>
<li><code>embedded-opentype - eot</code><ul>
<li>IE 专用字体</li>
<li>可以从 truetype 创建此格式</li>
<li>IE4+</li>
</ul>
</li>
<li><code>svg - svg</code><ul>
<li>基于 svg 渲染</li>
<li>Chrome4+、Safari3.1+、Opera10.0+、iOS Mobile Safari3.2+</li>
</ul>
</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>获取自定义字体的原始文件，可前往 <a href="https://www.dafont.com/">DaFont</a> 下载</li>
<li>在 <a href="https://www.fontsquirrel.com/fontface/generator">Font Squirrel</a> 将字体转换为兼容各浏览器的 Web 字体</li>
<li>按上述兼容性语法指定 @font-face 中的字体</li>
<li>在指定元素中调用该自定义字体</li>
</ul>
<h3 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h3><h4 id="1-字体文件名简写"><a href="#1-字体文件名简写" class="headerlink" title="1. 字体文件名简写"></a>1. 字体文件名简写</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">　　<span class="attribute">font-family</span>: <span class="string">&#x27;YT&#x27;</span>;   <span class="comment">/*声明一个名为yt的字体变量*/</span></span><br><span class="line">　　<span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;YourWebFontName.eot&#x27;</span>)，<span class="built_in">local</span>(<span class="string">&#x27;YourFontName.eot&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 然后在任何需要使用YT字体的地方就可以直接使用以下：</span><br><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">font-family</span>:YT;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>src</code>属性定义字体的下载地址，<code>local</code>表示本机地址，<code>url</code>表示网址（比如使用服务器上下载的字体）</li>
<li>如果在<code>src</code>上定义了多种字体，他们也是候选关系，如上段代码</li>
<li>如果修改了src中定义的字体或者顺序，一定要关闭浏览器再打开才能看到修改后的效果，刷新是看不到的</li>
<li>在<code>@font-face</code>规则中,font-family的作用是声明字体变量，与普通选择器中的font-family是不一样的。</li>
</ul>
<h4 id="2-使用服务端字体"><a href="#2-使用服务端字体" class="headerlink" title="2. 使用服务端字体"></a>2. 使用服务端字体</h4><p>在<code>@font-face</code>规则中，如果src属性定义的字体是一个<code>url路径</code>，则网页加载时会自动从服务器下载字体文件，再显示出来。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;FZCYS&#x27;</span>;</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">local</span>(<span class="string">&#x27;FZYaSongA-B-GB&#x27;</span>);</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;YourWebFontName.eot&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-font-face浏览器兼容"><a href="#3-font-face浏览器兼容" class="headerlink" title="3. @font-face浏览器兼容"></a>3. <code>@font-face</code>浏览器兼容</h4><p>由于每种浏览器对@font-face的兼容性不同，不同的浏览器对字体的支持格式不同，这就意味着在<code>@font-face</code>中我们至少需要.woff,.eot两种格式字体，甚至还需要.svg等字体达到更多种浏览版本的支持。</p>
<ul>
<li><code>.TTF</code>或<code>.OTF</code>，适用于Firefox 3.5、Safari、Opera；</li>
<li><code>.EOT</code>  适用于Internet Explorer 4.0+；</li>
<li><code>.SVG</code>  适用于Chrome、IPhone， 获取要使用字体的三种文件格式，确保能在主流浏览器中都能正常显示该字体。</li>
</ul>
<p>使用CSS3的<code>@font-face</code>属性可以实现在网页中嵌入任意字体，但是IE只支持微软自有的EOT格式字体，而其他浏览器都不支持这一字体格式，其它浏览器可以设置TTF(TrueType)和OTF(OpenType)两种字体作为自定义字体</p>
<p>下面要解决的是如何获取到某种字体的这三种格式文件。一般地，我们在手头上（或在设计资源站点已经找到）有该字体的某种格式文件，最常见的是.TTF 文件，我们需要通过这种文件格式转换为其余两种文件格式。字体文件格式的转换可以通过网站<a href="https://www.fontsquirrel.com/tools/webfont-generator">FontsQuirrel</a>或 onlinefontconverter提供的在线字体转换服务获取。获取到三种格式的字体文件后，</p>
<p>下一步要在样式表中声明该字体，并在需要的地方使用该字体。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line"><span class="attribute">font-family</span>: <span class="string">&#x27;YourWebFontName&#x27;</span>;</span><br><span class="line"><span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;YourWebFontName.eot&#x27;</span>); <span class="comment">/* IE9 Compat Modes */</span></span><br><span class="line"><span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;YourWebFontName.eot?#iefix&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>), <span class="comment">/* IE6-IE8 */</span></span><br><span class="line">     <span class="built_in">url</span>(<span class="string">&#x27;YourWebFontName.woff&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>), <span class="comment">/* Modern Browsers */</span></span><br><span class="line">     <span class="built_in">url</span>(<span class="string">&#x27;YourWebFontName.ttf&#x27;</span>)  <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>), <span class="comment">/* Safari, Android, iOS */</span></span><br><span class="line">     <span class="built_in">url</span>(<span class="string">&#x27;YourWebFontName.svg#YourWebFontName&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>); <span class="comment">/* Legacy iOS */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、禁用输入法"><a href="#四、禁用输入法" class="headerlink" title="四、禁用输入法"></a>四、禁用输入法</h2><h3 id="1-CSS3-ime-mode"><a href="#1-CSS3-ime-mode" class="headerlink" title="1. CSS3   ime-mode"></a>1. CSS3   <code>ime-mode</code></h3><blockquote>
<p>IE浏览器从IE5开始就支持该属性，FireFox浏览器从FireFox3.0开始也支持该ime-mode属性。不过chrome、opera、Safari浏览器还没有开始支持该属性。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="left">名称:</th>
<th>ime-mode</th>
</tr>
</thead>
<tbody><tr>
<td align="left">值:</td>
<td>auto | normal | active | inactive | disabled | inherit</td>
</tr>
<tr>
<td align="left">初始值:</td>
<td>auto</td>
</tr>
<tr>
<td align="left">应用元素:</td>
<td>text fields（文本字段）</td>
</tr>
<tr>
<td align="left">继承性:</td>
<td>no</td>
</tr>
</tbody></table>
<ul>
<li>auto : 默认值，不影响当前输入法编辑器的状态 </li>
<li>normal : 输入法编辑器的状态应该是normal，这个值可以用于用户样式表来覆盖页面的设置。IE浏览器不支持该属性 </li>
<li>active : 输入法编辑器的状态初始时是激活的；输入将一直使用该输入法直到用户切换输入法。该属性在Linux操作系统下不支持 </li>
<li>inactive : 输入法编辑器的状态初始时是非激活状态；除非用户激活输入法 </li>
<li>disabled : 禁用输入法编辑器；该输入法编辑器也许不会被用户激活 </li>
</ul>
<h3 id="2-替代方法"><a href="#2-替代方法" class="headerlink" title="2. 替代方法"></a>2. 替代方法</h3><p>由于第一种方法不被广泛支持，因此另一种方法就是  <strong>使用<code>readonly</code>禁止掉文本框弹出输入法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;selectCarBtn&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;readonly&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;输入车牌号&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="五、高度塌陷"><a href="#五、高度塌陷" class="headerlink" title="五、高度塌陷"></a>五、高度塌陷</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>高度塌陷问题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">            <span class="selector-class">.div-outer</span> &#123;</span></span><br><span class="line"><span class="css">                <span class="selector-tag">border</span>: <span class="selector-tag">solid</span> 2<span class="selector-tag">px</span> <span class="selector-id">#223344</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.div1</span> &#123;</span></span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 100px;</span><br><span class="line"><span class="css">                <span class="selector-tag">border</span>: <span class="selector-tag">solid</span> 2<span class="selector-tag">px</span> <span class="selector-id">#667788</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.div2</span> &#123;</span></span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 100px;</span><br><span class="line"><span class="css">                <span class="selector-tag">border</span>: <span class="selector-tag">solid</span> 2<span class="selector-tag">px</span> <span class="selector-id">#667788</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="css">            <span class="selector-class">.div3</span> &#123;</span></span><br><span class="line">                width: 200px;</span><br><span class="line">                height: 100px;</span><br><span class="line"><span class="css">                <span class="selector-tag">border</span>: <span class="selector-tag">solid</span> 2<span class="selector-tag">px</span> <span class="selector-id">#667788</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div-outer&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div1&quot;</span>&gt;</span>div1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div2&quot;</span>&gt;</span>div2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;div3&quot;</span>&gt;</span>div3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>页面效果如下：</p>
<p><img data-src="css-gdtx-0.jpg"></p>
<p>在div-outer内部的三个div默认每个div会占一行，所以三个div会成列显示。</p>
<hr>

<p>现在对div1设置<code>float: left</code>，页面如图所示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*操作一*/</span></span><br><span class="line"><span class="selector-class">.div1</span>&#123; <span class="attribute">float</span>: left; &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="css-gdtx-2.png"></p>
<p>可以看到div2和div3重合了</p>
<hr>

<p>对div1设置float: left属性，div1脱离文档流，但是仍占据位置，div2和div3重合是因为div2位置不变，div3也在div2的位置。但是发现这样理解是不对的，正确的理解是<strong>div2被div1挤到了现在div3的位置</strong>。</p>
<p>因为如果对div1设置<code>float: right</code>，页面如图所示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*操作二*/</span></span><br><span class="line"><span class="selector-class">.div1</span>&#123; <span class="attribute">float</span>: right; &#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="css-gdtx-1.png"></p>
<p>所以如果对div1设置float: left时，div2会被div1挤到现在div3的位置。</p>
<h3 id="对css高度塌陷问题的理解"><a href="#对css高度塌陷问题的理解" class="headerlink" title="对css高度塌陷问题的理解"></a>对css高度塌陷问题的理解</h3><p>如果对div1，div2，div3都设置float: left，但是父元素div-outer没有设置宽度和高度，页面如图所示</p>
<p><img data-src="css-gdtx-3.png"></p>
<p>如果没有设置父元素高度，父元素的高度默认是auto，会随子元素的高度而改变，如果对div1，div2，div3都设置float: left，那么此时父元素高度为0，这就是<strong>浮动塌陷</strong>。</p>
<p><strong>解决办法一：添加一个新的div</strong></p>
<p>设置该div为 <code>clear：both;</code>  的空div</p>
<p><strong>解决办法二：设置父元素属性</strong></p>
<p>对父元素设置属性overflow: hidden或overflow: auto，</p>
<p>设置overflow: hidden的意思是，overflow规定当内容溢出元素框时发生的事情</p>
<p><img data-src="css-gdtx-4.png"></p>
<p>因为父元素没有指定高度，默认是auto，所以需要计算父元素包含的内容的高度，这样子元素浮动的高度就被计算进去，解决了浮动塌陷。</p>
<p><strong>解决办法三：设置父元素display:table</strong></p>
<p><strong>解决办法四：内墙法</strong></p>
<h2 id="六、margin-top失效问题"><a href="#六、margin-top失效问题" class="headerlink" title="六、margin-top失效问题"></a>六、<code>margin-top</code>失效问题</h2><h3 id="现象："><a href="#现象：" class="headerlink" title="现象："></a>现象：</h3><p>当两个空的块级元素嵌套时，如果内部的块设置有margin-top属性，而且父元素没有下边解决方法所述的特征，那么内部块的margin-top属性会绑架父元素（即将margin-top传递凌驾给了父元素）。</p>
<blockquote>
<p>就好比一个小兵，看到上级有漏洞，就假传圣旨，利用漏洞扩张自己的权利。只要设置父元素的border（栅栏）或者padding（隔离墙），就能管住这个调皮的下属。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parrent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-id">#parrent</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:500px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span><span class="selector-pseudo">:teal</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-id">#box1</span>&#123; </span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>; </span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span><span class="selector-pseudo">:aqua</span>; </span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:20px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img data-src="css-margin-1.png"></p>
<p><strong>这个现象并不是bug，而是有理论依据的</strong>：</p>
<blockquote>
<p>《on having layout》</p>
</blockquote>
<p><code>hasLayout</code> 会影响一个盒子和其子孙的边距重叠。<strong>根据规范，一个盒子如果没有上补白和上边框，那么它的上边距应该和其文档流中的第一个孩子元素的上边距重叠。</strong></p>
<p>但值得一提的是，只有在<code>Fire Fox</code>和<code>Chrome</code>下才会出现这种margin-top绑架父节点的情况，在IE6 IE7中均显示正常，但这恰恰说明了他们是不符合规范的，而FF合Chrome则是严格遵守规范的。</p>
<h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><ol>
<li>设置父元素或者自身的display:inline-block;</li>
<li><strong>设置父元素的border</strong>:1px aqua solid;(&gt;0)</li>
<li><strong>设置父元素的padding</strong>:1px;(&gt;0)</li>
<li>给父元素设置overflow:hidden;</li>
<li>给父元素或者自身设置position:absolute;</li>
<li>设置父元素非空，填充一定的内容。</li>
</ol>
<h2 id="七、css-overflow-隐藏滚动条"><a href="#七、css-overflow-隐藏滚动条" class="headerlink" title="七、css overflow 隐藏滚动条"></a>七、<code>css overflow</code> 隐藏滚动条</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#fuchuang-3</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1080px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1920px</span>;</span><br><span class="line">  <span class="attribute">transform-origin</span>: left top;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#fuchuang-3</span><span class="selector-pseudo">::-webkit-scrollbar</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、base64格式"><a href="#八、base64格式" class="headerlink" title="八、base64格式"></a>八、<code>base64</code>格式</h2><blockquote>
<p><a href="https://www.cnblogs.com/Renyi-Fan/p/9588306.html">大佬文章传送门</a></p>
<p>图片转<code>base64</code>格式工具  <strong>FeHelper</strong></p>
</blockquote>
<h3 id="1、Base64编码表"><a href="#1、Base64编码表" class="headerlink" title="1、Base64编码表"></a>1、Base64编码表</h3><table>
<thead>
<tr>
<th>码值</th>
<th>字符</th>
<th>码值</th>
<th>字符</th>
<th>码值</th>
<th>字符</th>
<th>码值</th>
<th>字符</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>A</td>
<td>16</td>
<td>Q</td>
<td>32</td>
<td>g</td>
<td>48</td>
<td>w</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>17</td>
<td>R</td>
<td>33</td>
<td>h</td>
<td>49</td>
<td>x</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>18</td>
<td>S</td>
<td>34</td>
<td>i</td>
<td>50</td>
<td>y</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>19</td>
<td>T</td>
<td>35</td>
<td>j</td>
<td>51</td>
<td>z</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>20</td>
<td>U</td>
<td>36</td>
<td>k</td>
<td>52</td>
<td>0</td>
</tr>
<tr>
<td>5</td>
<td>F</td>
<td>21</td>
<td>V</td>
<td>37</td>
<td>l</td>
<td>53</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>G</td>
<td>22</td>
<td>W</td>
<td>38</td>
<td>m</td>
<td>54</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td>H</td>
<td>23</td>
<td>X</td>
<td>39</td>
<td>n</td>
<td>55</td>
<td>3</td>
</tr>
<tr>
<td>8</td>
<td>I</td>
<td>24</td>
<td>Y</td>
<td>40</td>
<td>o</td>
<td>56</td>
<td>4</td>
</tr>
<tr>
<td>9</td>
<td>J</td>
<td>25</td>
<td>Z</td>
<td>41</td>
<td>p</td>
<td>57</td>
<td>5</td>
</tr>
<tr>
<td>10</td>
<td>K</td>
<td>26</td>
<td>a</td>
<td>42</td>
<td>q</td>
<td>58</td>
<td>6</td>
</tr>
<tr>
<td>11</td>
<td>L</td>
<td>27</td>
<td>b</td>
<td>43</td>
<td>r</td>
<td>59</td>
<td>7</td>
</tr>
<tr>
<td>12</td>
<td>M</td>
<td>28</td>
<td>c</td>
<td>44</td>
<td>s</td>
<td>60</td>
<td>8</td>
</tr>
<tr>
<td>13</td>
<td>N</td>
<td>29</td>
<td>d</td>
<td>45</td>
<td>t</td>
<td>61</td>
<td>9</td>
</tr>
<tr>
<td>14</td>
<td>O</td>
<td>30</td>
<td>e</td>
<td>46</td>
<td>u</td>
<td>62</td>
<td>+</td>
</tr>
<tr>
<td>15</td>
<td>P</td>
<td>31</td>
<td>f</td>
<td>47</td>
<td>v</td>
<td>63</td>
<td>/</td>
</tr>
</tbody></table>
<p><strong>编码说明</strong></p>
<p>​        Base64编码要求把3个8位字节（<code>3*8=24</code>）转化为4个6位的字节（<code>4*6=24</code>），之后在6位的前面补两个0，形成8位一个字节的形式。 如果剩下的字符不足3个字节，则用0填充，输出字符使用’=’，因此编码后输出的文本末尾可能会出现1或2个’=’。</p>
<p>　　为了保证所输出的编码位可读字符，Base64制定了一个编码表，以便进行统一转换。编码表的大小为<code>2^6=64</code>，这也是Base64名称的由来。</p>
<h3 id="2、base64做图片src属性的地址"><a href="#2、base64做图片src属性的地址" class="headerlink" title="2、base64做图片src属性的地址"></a>2、base64做图片src属性的地址</h3><p>使用<code>base64</code>格式图片，这种方法可以在页面文件中嵌入图片，嵌入方法同引入外部图片</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAMAAAAOus </span></span></span><br><span class="line"><span class="tag"><span class="string">bgAAAAeFBMVEUAwAD///+U5ZTc9twOww7G8MYwzDCH4==&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>src或 url() 中有一大串编码。它把一些 8-bit 数据翻译成标准 ASCII 字符，网上有很多免费的base64 编码和解码的工具， 后面跟的一串代码就相当于链接地址。</p>
<h3 id="3、Data-URL-scheme-支持的类型有哪些？"><a href="#3、Data-URL-scheme-支持的类型有哪些？" class="headerlink" title="3、Data URL scheme 支持的类型有哪些？"></a>3、Data URL scheme 支持的类型有哪些？</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span>:,文本数据 </span></span><br><span class="line"><span class="class"><span class="keyword">data</span>:text/plain,文本数据 </span></span><br><span class="line"><span class="class"><span class="keyword">data</span>:text/html,<span class="type">HTML</span>代码 </span></span><br><span class="line"><span class="class"><span class="keyword">data</span>:text/html;base64,base64编码的<span class="type">HTML</span>代码 </span></span><br><span class="line"><span class="class"><span class="keyword">data</span>:text/css,<span class="type">CSS</span>代码 </span></span><br><span class="line"><span class="class"><span class="keyword">data</span>:text/css;base64,base64编码的<span class="type">CSS</span>代码 </span></span><br><span class="line"><span class="class"><span class="keyword">data</span>:text/<span class="type">JavaScript</span>,<span class="type">Javascript</span>代码 </span></span><br><span class="line"><span class="class"><span class="keyword">data</span>:text/javascript;base64,base64编码的<span class="type">Javascript</span>代码 </span></span><br><span class="line"><span class="class"><span class="keyword">data</span>:image/gif;base64,base64编码的gif图片数据 </span></span><br><span class="line"><span class="class"><span class="keyword">data</span>:image/png;base64,base64编码的png图片数据 </span></span><br><span class="line"><span class="class"><span class="keyword">data</span>:image/jpeg;base64,base64编码的jpeg图片数据 </span></span><br><span class="line"><span class="class"><span class="keyword">data</span>:image/x-icon;base64,base64编码的icon图片数据</span></span><br></pre></td></tr></table></figure>

<h3 id="4、将图片转化为base64格式的方法？"><a href="#4、将图片转化为base64格式的方法？" class="headerlink" title="4、将图片转化为base64格式的方法？"></a>4、将图片转化为base64格式的方法？</h3><p>a、利用canvas 将图片转化为base64 编码格式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dataURL = canvas.toDataURL(<span class="string">&quot;image/jpeg&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>b、利用 html5 的 FileReader 将图片转化base64格式 FileReader 是H5提供的一个处理文件的API，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reader=<span class="keyword">new</span> FileReader();  </span><br><span class="line">reader.readAsBinaryString(file);  </span><br></pre></td></tr></table></figure>

<br>

<h2 id="九、CSS-文本换行总结"><a href="#九、CSS-文本换行总结" class="headerlink" title="九、CSS 文本换行总结"></a>九、CSS 文本换行总结</h2><h3 id="1、文本超出隐藏"><a href="#1、文本超出隐藏" class="headerlink" title="1、文本超出隐藏"></a>1、文本超出隐藏</h3><p>实现这个效果需要用到css的 <code>text-overflow</code> 属性，其表示文本溢出时发生的事情。</p>
<p>它有三个属性值，分别是clip(修剪文本)、ellipsis(省略号代替)、<em>string</em>(指定字符串代替)。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;context&quot;</span>&gt;</span>sdsdsdsadsadsadas<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.context</span>&#123;</span></span><br><span class="line">    width:50px; //div的宽度必须是固定的</span><br><span class="line"><span class="css">    <span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">text-overflow</span><span class="selector-pseudo">:ellipsis</span>;</span></span><br><span class="line">    white-space: nowrap;//文本不进行换行，默认下宽度不够就会换行。</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> <strong>接下来重点说一说多行文本溢出显示省略号，实现方法如下：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 3;</span><br><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure>

<p>效果如图：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">aaaaaaaaaaaaaa</span><br><span class="line">aaaaaaaaaaaaaa</span><br><span class="line"><span class="function"><span class="title">aaaaaaaaaaa</span></span>...</span><br></pre></td></tr></table></figure>

<p><strong>适用范围：</strong></p>
<p>因使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端；</p>
<blockquote>
<p>注意：</p>
<ul>
<li><code>-webkit-line-clamp</code>用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：</li>
<li><code>display: -webkit-box;</code> 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。</li>
<li><code>-webkit-box-orient</code> 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。</li>
</ul>
</blockquote>
<h3 id="2、文本换行（简要概括）"><a href="#2、文本换行（简要概括）" class="headerlink" title="2、文本换行（简要概括）"></a>2、文本换行（简要概括）</h3><h4 id="①文字不换行（-white-space-）"><a href="#①文字不换行（-white-space-）" class="headerlink" title="①文字不换行（ white-space ）"></a>①文字不换行（ <code>white-space</code> ）</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>normal：连续的空白符会被合并，换行符会被当作空白符处理。填充line盒子时，必要的话会换行。</li>
<li>nowrap：和normal一样，连续的空白符会被合并。但文本内的换行无效。</li>
<li>pre：连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素时才会换行。</li>
<li>pre-wrap：连续的空白符会被保留。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时才会换行。</li>
<li>pre-line：连续的空白符会被合并。在遇到换行符或者<code>&lt;br&gt;</code>元素，或者需要为了填充line盒子时会换行。</li>
</ul>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>默认。空白会被浏览器忽略。</td>
</tr>
<tr>
<td>pre</td>
<td>空白会被浏览器保留。其行为方式类似 HTML 中的 <code>&lt;pre&gt;</code> 标签。</td>
</tr>
<tr>
<td>nowrap</td>
<td>文本不会换行，文本会在在同一行上继续，直到遇到 <code>&lt;br&gt;</code> 标签为止。</td>
</tr>
<tr>
<td>pre-wrap</td>
<td>保留空白符序列，但是正常地进行换行。</td>
</tr>
<tr>
<td>pre-line</td>
<td>合并空白符序列，但是保留换行符。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 white-space 属性的值。</td>
</tr>
</tbody></table>
<h4 id="②允许长单词换行-（-word-wrap-overflow-wrap-）"><a href="#②允许长单词换行-（-word-wrap-overflow-wrap-）" class="headerlink" title="②允许长单词换行 （ word-wrap  ||  overflow-wrap ）"></a>②允许长单词换行 （ <code>word-wrap</code>  ||  <code>overflow-wrap</code> ）</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">word-wrap</span>: <span class="selector-tag">break-word</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>只在允许的断字点换行（浏览器保持默认处理）。</td>
</tr>
<tr>
<td>break-word</td>
<td>在长单词或 URL 地址内部进行换行。</td>
</tr>
</tbody></table>
<h4 id="③换行不截断单词（-word-break-）"><a href="#③换行不截断单词（-word-break-）" class="headerlink" title="③换行不截断单词（ word-break ）"></a>③换行不截断单词（ <code>word-break</code> ）</h4><blockquote>
<p>先介绍一个缩写CJK：中日韩统一表意文字</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">word-break</span>: <span class="selector-tag">break-all</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>normal</td>
<td>使用浏览器默认的换行规则。</td>
</tr>
<tr>
<td>break-all</td>
<td>允许在单词内换行  ||对于非CJK文本，可在任意字符间断行</td>
</tr>
<tr>
<td>keep-all</td>
<td>只能在半角空格或连字符处换行。||  CJK文本不断行，非CJK文本表现同normal一样</td>
</tr>
</tbody></table>
<h4 id="④换行时使用连字符连接单词（-hyphens-—-实验中）"><a href="#④换行时使用连字符连接单词（-hyphens-—-实验中）" class="headerlink" title="④换行时使用连字符连接单词（ hyphens — 实验中）"></a>④换行时使用连字符连接单词（ <code>hyphens</code> — 实验中）</h4><p>此属性告诉浏览器在换行时使用连字符连接单词</p>
<p>属性值：none | manual | auto</p>
<h4 id="⑤单行文字超出显示省略号"><a href="#⑤单行文字超出显示省略号" class="headerlink" title="⑤单行文字超出显示省略号"></a>⑤单行文字超出显示省略号</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure>

<h4 id="⑥多行文字超出显示省略号"><a href="#⑥多行文字超出显示省略号" class="headerlink" title="⑥多行文字超出显示省略号"></a>⑥多行文字超出显示省略号</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 3;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br></pre></td></tr></table></figure>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 布局</title>
    <url>/2020/09/10/css-layout/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>这篇文章来一次查漏补缺，回顾<code>CSS布局</code></p>
<p>列举的布局如下：</p>
<p>–  弹性布局<code>Flex</code></p>
<p>–  <code>Grid</code> 网格布局</p>
<p>–  浮动布局</p>
<p>–  圣杯布局</p>
<p>–  双飞翼布局</p>
<p>–  水平居中对齐</p>
</blockquote>
<a id="more"></a>

<h2 id="一、CSS3弹性盒布局方式"><a href="#一、CSS3弹性盒布局方式" class="headerlink" title="一、CSS3弹性盒布局方式"></a>一、CSS3弹性盒布局方式</h2><p>弹性盒子是CSS3的一种新布局模式。</p>
<p>CSS3 弹性盒（ <code>Flexible Box</code> 或 <code>flexbox</code>），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。</p>
<p>引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。</p>
<p><strong>浏览器支持</strong></p>
<blockquote>
<p>表格中的数字表示支持该属性的第一个浏览器的版本号。</p>
<p>紧跟在数字后面的 <code>-webkit-</code> 或 <code>-moz-</code> 为指定浏览器的前缀。</p>
</blockquote>
<p><img data-src="support.png"></p>
<p><strong>注意：</strong> </p>
<ul>
<li>弹性盒子由弹性容器(<code>Flex container</code>)和弹性子元素(<code>Flex item</code>)组成。</li>
<li>弹性容器通过设置 <code>display</code> 属性的值为 <code>flex</code> 或 <code>inline-flex</code>将其定义为弹性容器。</li>
<li>弹性容器内包含了一个或多个弹性子元素。</li>
<li>弹性容器外及弹性子元素内是正常渲染的。弹性盒子只定义了弹性子元素如何在弹性容器内布局。</li>
</ul>
<p><img data-src="flex0.png"></p>
<h3 id="1-Flex-容器属性（设置在容器上）"><a href="#1-Flex-容器属性（设置在容器上）" class="headerlink" title="1. Flex 容器属性（设置在容器上）"></a>1. <code>Flex</code> 容器属性（设置在容器上）</h3><p><code>flex-direction</code>     指定弹性容器中子元素排列方式</p>
<p><code>flex-wrap</code>     设置弹性盒子的子元素超出父容器时是否换行</p>
<p><code>flex-flow</code>     <u>flex-direction</u> 和 <u>flex-wrap</u> 的简写</p>
<p><code>align-items</code>    设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式</p>
<p><code>align-content</code>    修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐  </p>
<p><code>justify-content</code>    设置弹性盒子元素在主轴（横轴）方向上的对齐方式</p>
<h4 id="1-1-flex-direction-属性"><a href="#1-1-flex-direction-属性" class="headerlink" title="1.1 flex-direction 属性"></a>1.1 flex-direction 属性</h4><p>决定项目的方向。</p>
<p><strong>注意：</strong>如果元素不是弹性盒对象的元素，则 <code>flex-direction</code> 属性不起作用。</p>
<p><img data-src="flex1.png"></p>
<p><strong>属性值</strong></p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row</td>
<td>默认值。主轴为水平方向，起点在左端</td>
</tr>
<tr>
<td>row-reverse</td>
<td>主轴为水平方向，起点在右端</td>
</tr>
<tr>
<td>column</td>
<td>主轴为垂直方向，起点在上沿</td>
</tr>
<tr>
<td>column-reverse</td>
<td>主轴为垂直方向，起点在下沿</td>
</tr>
</tbody></table>
<h4 id="1-2-flex-wrap-属性"><a href="#1-2-flex-wrap-属性" class="headerlink" title="1.2 flex-wrap 属性"></a>1.2 flex-wrap 属性</h4><p><code>flex-wrap</code> 属性规定flex容器是单行或者多行，同时横轴的方向决定了新行堆叠的方向。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nowrap</td>
<td>默认值。规定元素不拆行或不拆列。</td>
</tr>
<tr>
<td>wrap</td>
<td>规定元素在必要的时候拆行或拆列。</td>
</tr>
<tr>
<td>wrap-reverse</td>
<td>规定元素在必要的时候拆行或拆列，但是以相反的顺序。</td>
</tr>
</tbody></table>
<p><img data-src="flex2.png"></p>
<h4 id="1-3-flex-flow-属性"><a href="#1-3-flex-flow-属性" class="headerlink" title="1.3 flex-flow 属性"></a>1.3 flex-flow 属性</h4><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p>
<h4 id="1-4-align-items属性"><a href="#1-4-align-items属性" class="headerlink" title="1.4 align-items属性"></a>1.4 align-items属性</h4><p><code>align-items</code> 属性定义flex子项在flex容器的当前行的侧轴（纵轴）方向上的对齐方式。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>stretch</td>
<td>默认值。项目被拉伸以适应容器。如果项目未设置高度或设为auto，将占满整个容器的高度。</td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
</tr>
<tr>
<td>flex-start</td>
<td>项目位于容器的开头。</td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
</tr>
<tr>
<td>baseline</td>
<td>项目位于容器的基线上。</td>
</tr>
</tbody></table>
<p><img data-src="flex3.png"></p>
<h4 id="1-5-justify-content属性"><a href="#1-5-justify-content属性" class="headerlink" title="1.5 justify-content属性"></a>1.5 justify-content属性</h4><p><code>justify-content</code> 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>flex-start</td>
<td>默认值。项目位于容器的开头。</td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
</tr>
<tr>
<td>space-between</td>
<td>两端对齐，项目之间的间隔都相等</td>
</tr>
<tr>
<td>space-around</td>
<td>项目位于各行之前、之间、之后都留有空白的容器内。</td>
</tr>
</tbody></table>
<blockquote>
<p>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。    </p>
</blockquote>
<p><img data-src="flex4.png"></p>
<h3 id="2-Flex-弹性子元素属性"><a href="#2-Flex-弹性子元素属性" class="headerlink" title="2. Flex 弹性子元素属性"></a>2. <code>Flex</code> 弹性子元素属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td>order</td>
<td align="left">设置弹性盒子的子元素排列顺序。</td>
</tr>
<tr>
<td>flex-grow</td>
<td align="left">设置或检索弹性盒子元素的扩展比率。</td>
</tr>
<tr>
<td>flex-shrink</td>
<td align="left">指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。</td>
</tr>
<tr>
<td>flex-basis</td>
<td align="left">用于设置或检索弹性盒伸缩基准值。</td>
</tr>
<tr>
<td>flex</td>
<td align="left">设置弹性盒子的子元素如何分配空间。</td>
</tr>
<tr>
<td>align-self</td>
<td align="left">在弹性子元素上使用。覆盖容器的 align-items 属性。</td>
</tr>
</tbody></table>
<h4 id="2-1-order属性"><a href="#2-1-order属性" class="headerlink" title="2.1 order属性"></a>2.1 order属性</h4><p><code>&lt;integer&gt;</code>：用整数值来定义排列顺序，数值小的排在前面。可以为负值，默认为0。</p>
<p><img data-src="flex5.png"></p>
<h4 id="2-2-flex-grow属性"><a href="#2-2-flex-grow属性" class="headerlink" title="2.2 flex-grow属性"></a>2.2 flex-grow属性</h4><p><code>&lt;integer&gt;</code>：一个数字，规定项目将相对于其他灵活的项目进行扩展的量。默认值是 0。</p>
<blockquote>
<p><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。　　</p>
<p>如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
</blockquote>
<p><img data-src="flex6.png"></p>
<h4 id="2-3-flex-shrink属性"><a href="#2-3-flex-shrink属性" class="headerlink" title="2.3 flex-shrink属性"></a>2.3 flex-shrink属性</h4><p><code>&lt;integer&gt;</code>：一个数字，规定项目将相对于其他灵活的项目进行收缩的量。默认值是 1。</p>
<blockquote>
<p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<p>如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。</p>
<p>如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flex-shrink</span>: &lt;<span class="selector-tag">number</span>&gt;; <span class="comment">/* default 1 */</span></span><br></pre></td></tr></table></figure>

<p><img data-src="flex7.png"></p>
<h4 id="2-4-flex-basis属性"><a href="#2-4-flex-basis属性" class="headerlink" title="2.4 flex-basis属性"></a>2.4 flex-basis属性</h4><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> <span class="selector-class">.flex-item</span> &#123; <span class="attribute">flex-basis</span>: &lt;integer&gt; | auto; &#125;</span><br></pre></td></tr></table></figure>

<p><code>&lt;integer&gt;</code>：一个长度单位或者一个百分比，规定元素的初始长度。<br> <code>auto</code>：默认值。长度等于元素的长度。如果该项目未指定长度，则长度将根据内容决定。</p>
<blockquote>
<p>浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>
<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
</blockquote>
<h4 id="2-5-flex属性"><a href="#2-5-flex属性" class="headerlink" title="2.5 flex属性"></a>2.5 flex属性</h4><p>flex 属性用于设置或检索弹性盒模型对象的子元素如何分配空间。</p>
<p>flex 属性是 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 属性的简写属性，默认值为<code>0 1 auto</code>。后两个属性可选。</p>
<blockquote>
<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
</blockquote>
<p><strong>特殊值</strong>： <code>flex: 1;</code>  等价于  <code>flex: 1 1</code>   但不等于  <code>flex: auto;</code></p>
<p>其含义为为<strong>均分</strong>，详细解释见<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex">MDN文档</a>和<a href="https://zhuanlan.zhihu.com/p/136223806">知乎解答文档</a></p>
<p><img data-src="flex9.png"></p>
<h4 id="2-6-align-self属性"><a href="#2-6-align-self属性" class="headerlink" title="2.6     align-self属性"></a>2.6     align-self属性</h4><p><code>align-self</code> 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。</p>
<blockquote>
<p>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> <span class="selector-class">.flex-item</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: auto | stretch | center | flex-start | flex-end | baseline | initial | inherit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>auto</td>
<td>默认值。元素继承了它的父容器的 align-items 属性。如果没有父容器则为 “stretch”。</td>
</tr>
<tr>
<td>stretch</td>
<td>元素被拉伸以适应容器。</td>
</tr>
<tr>
<td>center</td>
<td>元素位于容器的中心。</td>
</tr>
<tr>
<td>flex-start</td>
<td>元素位于容器的开头。</td>
</tr>
<tr>
<td>flex-end</td>
<td>元素位于容器的结尾。</td>
</tr>
<tr>
<td>baseline</td>
<td>元素位于容器的基线上。</td>
</tr>
<tr>
<td>initial</td>
<td>设置该属性为它的默认值。</td>
</tr>
<tr>
<td>inherit</td>
<td>从父元素继承该属性。</td>
</tr>
</tbody></table>
<p><img data-src="flex8.png"></p>
<h2 id="二、Grid-网格布局"><a href="#二、Grid-网格布局" class="headerlink" title="二、Grid 网格布局"></a>二、<code>Grid</code> 网格布局</h2><blockquote>
<p>转载<a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html">阮一峰CSS Grid 网格布局教程</a>，写的很不错，牛啊！</p>
<p>这篇文章也可做为参考  <a href="https://www.cnblogs.com/jcxfighting/p/10711210.html">传送门</a></p>
</blockquote>
<p>网格布局（Grid）是最强大的 CSS 布局方案。</p>
<p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。</p>
<p><img data-src="grid0.png"></p>
<p>上图这样的布局，就是 Grid 布局的拿手好戏。</p>
<p>Grid 布局与 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex 布局</a>有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p>
<p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p>
<h2 id="三、浮动布局"><a href="#三、浮动布局" class="headerlink" title="三、浮动布局"></a>三、浮动布局</h2><blockquote>
<p>这是一篇有逻辑的学习记录</p>
</blockquote>
<p>div是块级元素，在页面中独占一行，自上而下排列，也就是传说中的流</p>
<blockquote>
<p>无论多么复杂的布局，其基本出发点均是：<strong>“如何在一行显示多个div元素”。</strong> 显然标准流已经无法满足需求，这就要用到浮动。</p>
</blockquote>
<p><strong>浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次。</strong></p>
<p><strong>浮动之后的位置</strong>：假如元素A和元素B均浮动，则A和B在同一行；若仅B浮动，则B的顶端对齐A的底端。</p>
<p><strong>浮动之后的顺序</strong>：<strong>靠近页面边缘的一端是前，远离页面边缘的一端是后。</strong> </p>
<p><img data-src="float-1.png"></p>
<p><strong>清除浮动</strong>：<strong>清除浮动可以理解为打破横向排列</strong>（元素浮动之前，也就是在标准流中，是竖向排列的，而浮动之后可以理解为横向排列）<span style="color:red;">对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。</span></p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><span class="line">语法：        </span><br><span class="line">    clear : <span class="literal">none</span> | <span class="literal">left</span> | <span class="literal">right</span> | <span class="literal">both</span>    </span><br><span class="line">取值：</span><br><span class="line">    <span class="literal">none</span>  :  默认值。允许两边都可以有浮动对象    </span><br><span class="line">    <span class="literal">left</span>  :  不允许左边有浮动对象    </span><br><span class="line">    <span class="literal">right</span> :  不允许右边有浮动对象    </span><br><span class="line">    <span class="literal">both</span>  :  不允许有浮动对象</span><br></pre></td></tr></table></figure>

<p><span style="color:red;">最后补充一点</span>，正如下面<strong>圣杯布局的<code>float</code>实现方式</strong>一样，当同一行元素由于行宽不足而主动排列在下一行的时候，可以通过设置<strong>负外边距<code>Margin</code>**，使其回到上一行，在</strong>利用<code>position</code>对位置进行微调**。</p>
<h2 id="四、圣杯布局"><a href="#四、圣杯布局" class="headerlink" title="四、圣杯布局"></a>四、圣杯布局</h2><p>所谓的<code>圣杯布局</code>就是左右两边大小固定不变，中间宽度自适应。我们可以用<code>浮动</code>、<code>定位</code>以及<code>flex</code>这三种方式来实现</p>
<p> 一般这种布局方式适用于各种移动端顶部搜索部分，这是最常见的，如京东手机版主页面顶部搜索：</p>
<p><img data-src="shengbei.png"></p>
<blockquote>
<p>可以看到左边有个菜单按钮，中间是搜索框，右边是登录两个文字，左右大小是固定的，而中间部分则是随着手机屏幕尺寸的大小而自适应</p>
</blockquote>
<h3 id="第一种方法-flex实现"><a href="#第一种方法-flex实现" class="headerlink" title="第一种方法 flex实现"></a>第一种方法 <code>flex</code>实现</h3><blockquote>
<p>需要理解<code>flex</code>的用法</p>
<p> <code>*</code>  <code>vh</code> 为相对于视口的高度。视口被均分为100单位的vh</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;container&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span>头部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;left&#x27;</span>&gt;</span>左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;center&#x27;</span>&gt;</span>中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;right&#x27;</span>&gt;</span>右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span>底部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.container</span>&#123;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">        <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">        <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">header</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">section</span>&#123;</span><br><span class="line">        <span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">background</span>: pink;</span><br><span class="line">        <span class="attribute">display</span>: flex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">footer</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.left</span>&#123;</span><br><span class="line">        <span class="attribute">background</span>: red;</span><br><span class="line">        <span class="attribute">flex</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.center</span>&#123;</span><br><span class="line">        <span class="attribute">flex</span>:<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">background</span>: blue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.right</span>&#123;</span><br><span class="line">        <span class="attribute">flex</span>:<span class="number">0</span> <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">        <span class="attribute">background</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><img data-src="shengbei-flex.png"></p>
<h3 id="第二种-position实现"><a href="#第二种-position实现" class="headerlink" title="第二种  position实现"></a>第二种  <code>position</code>实现</h3><blockquote>
<p><strong>思路</strong>：给容器设置左右内<code>padding</code>，让中间部分占满所有剩余空间，左右设置<code>absolute</code>使其左右分布</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>z中间<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.main</span> <span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">400px</span>);</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: pink</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: yellow ;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: blue ;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>:<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="shengbei-position.png"></p>
<h3 id="第三种方法-float实现"><a href="#第三种方法-float实现" class="headerlink" title="第三种方法 float实现"></a>第三种方法 <code>float</code>实现</h3><p><strong>经典实现方式：</strong></p>
<blockquote>
<p>应遵循以下要点</p>
<ul>
<li>两侧宽度固定，中间宽度自适应</li>
<li>中间部分在DOM结构上优先，以便先行渲染</li>
<li>允许三列中的任意一列成为最高列</li>
<li>只需要使用一个额外的<code>&lt;div&gt;</code>标签</li>
</ul>
</blockquote>
<p>有一个跟完美解释  <code>圣杯布局</code>  的文章：<a href="https://www.cnblogs.com/niujifei/p/11269093.html">传送门</a></p>
<h4 id="HTML结构"><a href="#HTML结构" class="headerlink" title="HTML结构"></a>HTML结构</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span>#header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center &quot;</span>&gt;</span>#center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>#left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>#right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>#footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="CSS结构"><a href="#CSS结构" class="headerlink" title="CSS结构"></a>CSS结构</h4><p><strong>1. 假设左侧的固定宽度为200px，右侧的固定宽度为150px，则首先在<code>container</code>上设置：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">200px</span>; </span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为左右两列预留出相应的空间，得到如下示意图：</p>
<p><img data-src="shengbei-float-1.png"></p>
<p><strong>2. 随后分别为三列设置宽度与浮动，同时对<code>footer</code>设置清除浮动：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">.container div&#123;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">    width: 100%;</span><br><span class="line">    background-color: #85D989;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background-color: pink;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    width: 150px;</span><br><span class="line">    background-color: blueviolet;</span><br><span class="line">&#125;</span><br><span class="line">.footer&#123;</span><br><span class="line">    clear: both;</span><br><span class="line">    background-color: darkslategray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img data-src="shengbei-float-2.png"></p>
<blockquote>
<p>注意：根据浮动的特性，由于<code>center</code>的宽度为100%，即占据了第一行的所有空间，所以<code>left</code>和<code>right</code>被“挤”到了第二行    </p>
</blockquote>
<h5 id="此处上下为核心关键"><a href="#此处上下为核心关键" class="headerlink" title="此处上下为核心关键"></a><strong>此处上下为核心关键</strong></h5><p><strong>3. 接下来的工作是将<code>left</code>放置到之前预留出的位置上，这里使用  <code>负外边距</code>  ：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><img data-src="shengbei-float-3.png"></p>
<p><strong>4. 随后还需要使用定位(position)方法：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用<code>position: relative</code>和<code>right: 200px</code>将<code>left</code>的位置在原有位置基础上左移200px，以完成<code>left</code>的放置：</p>
<p><img data-src="shengbei-float-4.png"></p>
<p><strong>5. 最终效果</strong></p>
<p><img data-src="shengbei-float-5.png"></p>
<p>至此，布局效果完成。不过还需要考虑最后一步，那就是<strong>页面的最小宽度</strong>：要想保证该布局效果正常显示，由于两侧都具有固定的宽度，所以需要给定页面一个最小的宽度，</p>
<p>但这并不只是简单的200+150=350px。回想之前<code>left</code>使用了<code>position: relative</code>，所以就意味着在<code>center</code>开始的区域，还存在着一个<code>left</code>的宽度。所以页面的最小宽度应该设置为200+150+200=550px：</p>
<h4 id="完整代码结构"><a href="#完整代码结构" class="headerlink" title="完整代码结构"></a>完整代码结构</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line">    *&#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#FFF9E9</span>;</span></span><br><span class="line">        font-size: 45px;</span><br><span class="line">    &#125;</span><br><span class="line">    div&#123;</span><br><span class="line">        text-align: center;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">       padding-left: 200px; </span><br><span class="line">       padding-right: 150px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> <span class="selector-tag">div</span>&#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.center</span>&#123;</span></span><br><span class="line">        width: 100%;</span><br><span class="line"><span class="css">        <span class="selector-tag">background-color</span>: <span class="selector-id">#85D989</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        background-color: pink;</span><br><span class="line">        margin-left: -100%;</span><br><span class="line">        position: relative;</span><br><span class="line">        right: 200px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">        width: 150px;</span><br><span class="line">        background-color: blueviolet;</span><br><span class="line">        margin-left: -150px;</span><br><span class="line">        position: relative;</span><br><span class="line">        left: 150px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.footer</span>&#123;</span></span><br><span class="line">        clear: both;</span><br><span class="line">        background-color: darkslategray;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.header</span>&#123;</span></span><br><span class="line">        background-color: darkslategray;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span>#header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;center &quot;</span>&gt;</span>#center<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>#left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>#right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span>#footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="五、双飞翼布局"><a href="#五、双飞翼布局" class="headerlink" title="五、双飞翼布局"></a>五、双飞翼布局</h2><blockquote>
<p>参考自<a href="https://www.jianshu.com/p/81ef7e7094e8">圣杯布局和双飞翼布局的理解与思考</a>，博主写的很有逻辑</p>
</blockquote>
<h3 id="DOM结构"><a href="#DOM结构" class="headerlink" title="DOM结构"></a>DOM结构</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;left&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;right&quot;</span> <span class="attr">class</span>=<span class="string">&quot;column&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>双飞翼布局的DOM结构与圣杯布局的区别是用<code>container</code>仅包裹住<code>center</code>，另外将<code>.column</code>类从<code>center</code>移至<code>container</code>上。</p>
<h3 id="CSS代码"><a href="#CSS代码" class="headerlink" title="CSS代码"></a>CSS代码</h3><p>按照与圣杯布局相同的思路，首先设置各列的宽度与浮动，并且为左右两列预留出空间，以及为<code>footer</code>设置浮动清除：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.column</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="shuangfeiyi-1.png"></p>
<p>以上代码将<code>container</code>,<code>left</code>,<code>right</code>设置为<code>float: left</code>，而在<code>container</code>内部，<code>center</code>由于没有设置浮动，所以其宽度默认为<code>container</code>的100%宽度，通过对其设置<code>margin-left</code>和<code>margin-right</code>为左右两列预留出了空间。</p>
<p>将<code>left</code>、<code>right</code>放置到预留位置</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>; </span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>; </span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后计算最小页面宽度：由于双飞翼布局没有用到<code>position:relative</code>进行定位，所以最小页面宽度应该为200+150=350px。但是当页面宽度缩小到350px附近时，会挤占中间栏的宽度，使得其内容被右侧栏覆盖</p>
<p>因此在设置最小页面宽度时，应该适当增加一些宽度以供中间栏使用（假设为150px），则有：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>布局整体代码为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.column</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>; </span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">150px</span>; </span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h3><p>通过对圣杯布局和双飞翼布局的介绍可以看出，圣杯布局在DOM结构上显得更加直观和自然，且在日常开发过程中，更容易形成这样的DOM结构（通常<code>&lt;aside&gt;</code>和<code>&lt;article&gt;</code>/<code>&lt;section&gt;</code>一起被嵌套在<code>&lt;main&gt;</code>中）；而双飞翼布局在实现上由于不需要使用定位，所以更加简洁，且允许的页面最小宽度通常比圣杯布局更小。</p>
<p>其实通过思考不难发现，两者在代码实现上都额外引入了一个<code>&lt;div&gt;</code>标签，其目的都是为了既能保证中间栏产生浮动（浮动后还<strong>必须</strong>显式设置宽度），又能限制自身宽度为两侧栏留出空间。</p>
<h2 id="六、水平居中"><a href="#六、水平居中" class="headerlink" title="六、水平居中"></a>六、水平居中</h2><h3 id="五种基础实现方式"><a href="#五种基础实现方式" class="headerlink" title="五种基础实现方式"></a>五种基础实现方式</h3><h4 id="1-text-align"><a href="#1-text-align" class="headerlink" title="1. text-align"></a>1. <code>text-align</code></h4><p>text-align 是入门最常用的属性，根据字面意思是文本对齐用的。</p>
<p>只需在父级标签上设置即可，虽然内部的子元素不管是块级元素 or 非块级元素都可以使用，但需注意块级元素会占用整行的宽度，文本是在这个宽度中作水平居中。</p>
<h4 id="2-定宽-margin-auto"><a href="#2-定宽-margin-auto" class="headerlink" title="2. 定宽 margin auto"></a>2. 定宽 <code>margin auto</code></h4><p>这也是常见的水平居中方式，通过设置子元素的 margin 属性来控制距离父元素的距离。</p>
<p><strong>需要注意：</strong>子元素如果是块级元素，就最好设置宽度，不然就会占满于父元素，在通过 text-align 文本居中对齐就没有意义了。对于非块级元素必须要设置宽度。</p>
<h4 id="3-flex-方式"><a href="#3-flex-方式" class="headerlink" title="3. flex 方式"></a>3. flex 方式</h4><p>通过设置浮动布局来实现居中，这是相对上两种方法某种程度上最简单的实现，因为在其基础上可以做更多布局的扩展，不用担心破坏布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">center</span>;</span><br></pre></td></tr></table></figure>

<h4 id="4-position-浮动-不建议"><a href="#4-position-浮动-不建议" class="headerlink" title="4. position + 浮动(不建议)"></a>4. position + 浮动(不建议)</h4><blockquote>
<p>现在这两种是比较有趣的定位方式，实际场景不建议使用，我是不愿意别人这样写，脑袋还要转个弯，来理解这样布局的计算方式</p>
</blockquote>
<p>如果元素是块级元素，通过 float 浮动属性，将它的宽度“抹去”。然后通过对于上级元素的相对定位通过错位修正的方式来居中。</p>
<p>让父元素的左侧从中间开始定位，子元素再根据自己的实际宽度往左偏移一半达到水平居中的目的。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过浮动让元素失去宽度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative;left: 50%;float: left;&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 相对父级元素，反方向修正 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position:relative; left:-50%; float: left;&quot;</span>&gt;</span></span><br><span class="line">            居中</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-position-transform-不建议"><a href="#5-position-transform-不建议" class="headerlink" title="5. position + transform (不建议)"></a>5. position + transform (不建议)</h4><p>思路同上，不同的是这次设置子元素为绝对定位，并距离左侧偏离一半，最后通过 <strong>transform</strong> 根据元素的实际宽度往左再偏移一半，达到居中效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative;&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 相对父级元素，反方向修正 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position:absolute; left:50%; </span></span></span><br><span class="line"><span class="tag"><span class="string">                                 transform: translateX(-50%);&quot;</span>&gt;</span></span><br><span class="line">            居中</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML基本问题</title>
    <url>/2020/08/28/HTML-Bacics/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>总结了关于<code>HTML</code>的基本问题</p>
<p>–  <code>HTML</code> 新特性</p>
<p>–  浏览器标准模式和怪异模式</p>
<p>–  <code>HTML</code>和<code>XHTML</code>的区别</p>
<p>–  使用<code>data-*</code></p>
<p>–  <code>HTML</code>模板引擎</p>
</blockquote>
<a id="more"></a>

<h2 id="一、HTML新特性"><a href="#一、HTML新特性" class="headerlink" title="一、HTML新特性"></a>一、HTML新特性</h2><blockquote>
<p>参考自<a href="https://www.cnblogs.com/gaosirs/p/10756524.html">该文章</a></p>
</blockquote>
<h3 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h3><p>语义化标签 为页面提供了更好的<strong>页面结构</strong>。</p>
<table>
<thead>
<tr>
<th align="center">描述</th>
<th align="center">属性</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>&lt;header&gt;&lt;/header&gt;</code></td>
<td align="center">定义文档的头部区域</td>
</tr>
<tr>
<td align="center"><code>&lt;footer&gt;&lt;/footer&gt;</code></td>
<td align="center">定义文档的尾部区域</td>
</tr>
<tr>
<td align="center"><code>&lt;nav&gt;&lt;/nav&gt;</code></td>
<td align="center">定义文档的导航区域</td>
</tr>
<tr>
<td align="center"><code>&lt;section&gt;&lt;/section&gt;</code></td>
<td align="center">定义文档的段落</td>
</tr>
<tr>
<td align="center"><code>&lt;article&gt;&lt;/article&gt;</code></td>
<td align="center">定义页面独立的内容区域</td>
</tr>
<tr>
<td align="center"><code>&lt;aside&gt;&lt;/aside&gt;</code></td>
<td align="center">定义页面侧边栏内容</td>
</tr>
<tr>
<td align="center"><code>&lt;command&gt;&lt;/command&gt;</code></td>
<td align="center">定义命令按钮</td>
</tr>
<tr>
<td align="center"><code>&lt;details&gt;&lt;/details&gt;</code></td>
<td align="center">标签包含 details 元素的标题</td>
</tr>
<tr>
<td align="center"><code>&lt;dialog&gt;&lt;/dialog&gt;</code></td>
<td align="center">定义对话框</td>
</tr>
</tbody></table>
<h3 id="2-增强型表单"><a href="#2-增强型表单" class="headerlink" title="2. 增强型表单"></a>2. 增强型表单</h3><p>HTML5 提供了多个新的<strong>表单输入类型</strong>。</p>
<table>
<thead>
<tr>
<th>输入类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>主要用于选取颜色</td>
</tr>
<tr>
<td>date</td>
<td>从一个日期选择器选择一个日期</td>
</tr>
<tr>
<td>datetime</td>
<td>选择一个日期（UTC 时间）</td>
</tr>
<tr>
<td>datetime-local</td>
<td>选择一个日期和时间 (无时区)</td>
</tr>
<tr>
<td>email</td>
<td>包含 e-mail 地址的输入域</td>
</tr>
<tr>
<td>month</td>
<td>选择一个月份</td>
</tr>
<tr>
<td>number</td>
<td>数值的输入域</td>
</tr>
<tr>
<td>range</td>
<td>一定范围内数字值的输入域</td>
</tr>
<tr>
<td>search</td>
<td>用于搜索域</td>
</tr>
<tr>
<td>tel</td>
<td>定义输入电话号码字段</td>
</tr>
<tr>
<td>time</td>
<td>选择一个时间</td>
</tr>
<tr>
<td>url</td>
<td>URL 地址的输入域</td>
</tr>
<tr>
<td>week</td>
<td>选择周和年</td>
</tr>
</tbody></table>
<p> 同时，还增加了<strong>新的表单属性</strong>：</p>
<ol>
<li><p>placehoder 属性，简短的提示在用户输入值前会显示在输入域上。即我们常见的输入框默认提示，在用户输入后消失。</p>
</li>
<li><p>required  属性，是一个 boolean 属性。要求填写的输入域不能为空</p>
</li>
<li><p>pattern 属性，描述了一个正则表达式用于验证<code>&lt;input&gt;</code> 元素的值。</p>
</li>
<li><p>min 和 max 属性，设置元素最小值与最大值。</p>
</li>
<li><p>step 属性，为输入域规定合法的数字间隔。</p>
</li>
<li><p>height 和 width 属性，用于 image 类型的 <code>&lt;input&gt;</code> 标签的图像高度和宽度。</p>
</li>
<li><p>autofocus 属性，是一个 boolean 属性。规定在页面加载时，域自动地获得焦点。</p>
</li>
<li><p>multiple 属性 ，是一个 boolean 属性。规定<code>&lt;input&gt;</code> 元素中可选择多个值。　　</p>
</li>
</ol>
<h3 id="3-音频和视频"><a href="#3-音频和视频" class="headerlink" title="3. 音频和视频"></a>3. 音频和视频</h3><p>HTML5 提供了 <strong>音频和视频</strong> 。</p>
<p>音频：<code>&lt;audio&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;xxx.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;xxx.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">您的浏览器不支持 audio 元素。</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>视频：<code>&lt;video&gt;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;xxx.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;xxx.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/ogg&quot;</span>&gt;</span></span><br><span class="line">您的浏览器不支持Video标签。</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-canvas-绘图"><a href="#4-canvas-绘图" class="headerlink" title="4. canvas 绘图"></a>4. canvas 绘图</h3><blockquote>
<p>供欣赏的<code>canvas</code><a href="https://www.html5tricks.com/tag/html5-canvas/">作品</a></p>
<p>jQuery/HTML5/CSS3<a href="http://www.htmleaf.com/html5/html5-canvas/">资料库</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.jianshu.com/p/7593eb9e53c2">Canvas教程</a></p>
<p><a href="https://www.w3school.com.cn/html5/html_5_canvas.asp">W3School教程</a></p>
<p><a href="https://www.cnblogs.com/gengzhen/p/11915071.html">Canvas绘图基础</a></p>
</blockquote>
<h3 id="5-SVG-绘图"><a href="#5-SVG-绘图" class="headerlink" title="5. SVG 绘图"></a>5. SVG 绘图</h3><blockquote>
<p>嵌入和使用SVG:</p>
<p><a href="https://segmentfault.com/a/1190000010942431">HTML中嵌入SVG图片的N种方式</a></p>
<p><a href="https://www.w3school.com.cn/svg/svg_inhtml.asp">HTML 页面中的 SVG</a></p>
<p><a href="https://www.jianshu.com/p/132b58273e27">HTML5之SVG的使用</a></p>
</blockquote>
<h4 id="SVG-与-Canvas两者间的区别"><a href="#SVG-与-Canvas两者间的区别" class="headerlink" title="SVG 与 Canvas两者间的区别"></a>SVG 与 Canvas两者间的区别</h4><p>SVG 是一种使用 XML 描述 2D 图形的语言。</p>
<p>Canvas 通过 JavaScript 来绘制 2D 图形。</p>
<p>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器。</p>
<p>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p>
<p>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p>
<h3 id="6-地理定位（Geolocation）"><a href="#6-地理定位（Geolocation）" class="headerlink" title="6. 地理定位（Geolocation）"></a>6. 地理定位（Geolocation）</h3><p>HTML5 Geolocation（地理定位）用于定位用户的位置。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.navigator</span><span class="selector-class">.geolocation</span> &#123;</span><br><span class="line">    <span class="attribute">getCurrentPosition</span>:  fn  用于获取当前的位置数据</span><br><span class="line">    watchPosition: fn  监视用户位置的改变</span><br><span class="line">    clearWatch: fn  清除定位监视</span><br><span class="line">&#125;　　　</span><br></pre></td></tr></table></figure>

<p>获取用户定位信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">navigator.geolocation.getCurrentPosition(</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">pos</span>)</span>&#123;</span><br><span class="line">　　　　<span class="built_in">console</span>.log(<span class="string">&#x27;用户定位数据获取成功&#x27;</span>)</span><br><span class="line">　　　　<span class="comment">//console.log(arguments);</span></span><br><span class="line">　　　　<span class="built_in">console</span>.log(<span class="string">&#x27;定位时间：&#x27;</span>,pos.timestamp)</span><br><span class="line">　　　　<span class="built_in">console</span>.log(<span class="string">&#x27;经度：&#x27;</span>,pos.coords.longitude)</span><br><span class="line">　　　　<span class="built_in">console</span>.log(<span class="string">&#x27;纬度：&#x27;</span>,pos.coords.latitude)</span><br><span class="line">　　　　<span class="built_in">console</span>.log(<span class="string">&#x27;海拔：&#x27;</span>,pos.coords.altitude)</span><br><span class="line">　　　　<span class="built_in">console</span>.log(<span class="string">&#x27;速度：&#x27;</span>,pos.coords.speed)</span><br><span class="line"></span><br><span class="line">&#125;,    <span class="comment">//定位成功的回调</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123; </span><br><span class="line">　　　　<span class="built_in">console</span>.log(<span class="string">&#x27;用户定位数据获取失败&#x27;</span>)</span><br><span class="line">　　　　<span class="comment">//console.log(arguments);</span></span><br><span class="line"></span><br><span class="line">&#125;        <span class="comment">//定位失败的回调</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="7-拖放API"><a href="#7-拖放API" class="headerlink" title="7. 拖放API"></a>7. 拖放API</h3><p>在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。</p>
<blockquote>
<p>转载来自<a href="https://www.cnblogs.com/ijjyo/p/4300717.html">很不错的拖放API解释…</a></p>
</blockquote>
<h4 id="7-1-HTML拖放实例"><a href="#7-1-HTML拖放实例" class="headerlink" title="7.1 HTML拖放实例"></a>7.1 HTML拖放实例</h4><p>​    下面的例子是一个简单的拖放实例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">allowDrop</span>(<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line">                ev.preventDefault();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                ev.dataTransfer.setData(<span class="string">&quot;Text&quot;</span>, ev.target.id);</span></span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line">                ev.preventDefault();</span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> data = ev.dataTransfer.getData(<span class="string">&quot;Text&quot;</span>);</span></span><br><span class="line"><span class="javascript">                ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">ondrop</span>=<span class="string">&quot;drop(event)&quot;</span> <span class="attr">ondragover</span>=<span class="string">&quot;allowDrop(event)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 500px;height: 500px;background-color: #FBB929;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;drag1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.baidu.com/img/baidu_jgylogo3.gif&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attr">ondragstart</span>=<span class="string">&quot;drag(event)&quot;</span> <span class="attr">width</span>=<span class="string">&quot;336&quot;</span> <span class="attr">height</span>=<span class="string">&quot;69&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="7-1-1-设置元素为可拖放"><a href="#7-1-1-设置元素为可拖放" class="headerlink" title="7.1.1 设置元素为可拖放"></a>7.1.1 设置元素为可拖放</h5><p>首先，为了使元素可拖动，把 draggable 属性设置为 true ：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="7-1-2-拖动什么-ondragstart-和-setData"><a href="#7-1-2-拖动什么-ondragstart-和-setData" class="headerlink" title="7.1.2 拖动什么 - ondragstart 和 setData()"></a>7.1.2 拖动什么 - ondragstart 和 setData()</h5><p>然后，规定当元素被拖动时，会发生什么。</p>
<p>在上面的例子中，ondragstart 属性调用了一个函数，drag(<em>event</em>)，它规定了被拖动的数据。</p>
<p>dataTransfer.setData() 方法设置被拖数据的数据类型和值：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> drag(ev)&#123;</span><br><span class="line">    ev.dataTransfer.set<span class="constructor">Data(<span class="string">&quot;Text&quot;</span>,<span class="params">ev</span>.<span class="params">target</span>.<span class="params">id</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，数据类型是 “Text”，值是可拖动元素的 id (“drag1”)。</p>
<h5 id="7-1-3-放到何处-ondragover"><a href="#7-1-3-放到何处-ondragover" class="headerlink" title="7.1.3 放到何处 - ondragover"></a>7.1.3 放到何处 - ondragover</h5><p>ondragover 事件规定在何处放置被拖动的数据。</p>
<p>默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。</p>
<p>这要通过调用 ondragover 事件的 <em>event</em>.preventDefault() 方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">event</span>.preventDefault()</span><br></pre></td></tr></table></figure>

<h5 id="7-1-4-进行放置-ondrop"><a href="#7-1-4-进行放置-ondrop" class="headerlink" title="7.1.4 进行放置 - ondrop"></a>7.1.4 进行放置 - ondrop</h5><p>当放置被拖数据时，会发生 drop 事件。</p>
<p>在上面的例子中，ondrop 属性调用了一个函数，drop(<em>event</em>)：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> drop(ev)</span><br><span class="line">&#123;</span><br><span class="line">ev.prevent<span class="constructor">Default()</span>;</span><br><span class="line">var data=ev.dataTransfer.get<span class="constructor">Data(<span class="string">&quot;Text&quot;</span>)</span>;</span><br><span class="line">ev.target.append<span class="constructor">Child(<span class="params">document</span>.<span class="params">getElementById</span>(<span class="params">data</span>)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）</li>
<li>通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。</li>
<li>被拖数据是被拖元素的 id (“drag1”)</li>
<li>把被拖元素追加到放置元素（目标元素）中</li>
</ul>
<h4 id="7-2-拖放-Drag-和-Drop-各属性生命周期"><a href="#7-2-拖放-Drag-和-Drop-各属性生命周期" class="headerlink" title="7.2 拖放(Drag 和 Drop)各属性生命周期"></a>7.2 拖放(Drag 和 Drop)各属性生命周期</h4><table>
<thead>
<tr>
<th>拖动生命周期</th>
<th>属性</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>拖动开始</td>
<td>ondragstart</td>
<td>script</td>
<td>在拖动操作开始时执行脚本（对象是被拖拽元素）</td>
</tr>
<tr>
<td>拖动过程中</td>
<td>ondrag</td>
<td>script</td>
<td>只要脚本在被拖动就允许脚本（对象是被拖拽元素）</td>
</tr>
<tr>
<td>拖动过程中</td>
<td>ondragenter</td>
<td>script</td>
<td>当元素被拖动到一个合法的放置目标时，执行脚本（对象是目标元素）</td>
</tr>
<tr>
<td>拖动过程中</td>
<td>ondragover</td>
<td>script</td>
<td>只要元素正在合法的放置目标上拖动时，就执行脚本（对象是目标元素）</td>
</tr>
<tr>
<td>拖动过程中</td>
<td>ondragleave</td>
<td>script</td>
<td>当元素离开合法的放置目标时（对象是目标元素）</td>
</tr>
<tr>
<td>拖动结束</td>
<td>ondrop</td>
<td>script</td>
<td>将被拖拽元素放在目标元素内时运行脚本（对象是目标元素）</td>
</tr>
<tr>
<td>拖动结束</td>
<td>ondragend</td>
<td>script</td>
<td>在拖动操作结束时运行脚本（对象是被拖拽元素）</td>
</tr>
</tbody></table>
<p><strong>写在哪呢？</strong></p>
<p>其实参照上表“描述”中括号内的提示即可知道，不过为了能更直观的了解到，特呈上代码：</p>
<p><strong>被拖放元素</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;span <span class="attribute">draggable</span>=<span class="string">&quot;true&quot;</span> <span class="attribute">id</span>=<span class="string">&quot;Span1&quot;</span> </span><br><span class="line">    <span class="attribute">ondragstart</span>=<span class="string">&quot;fooDragStart(this, event)&quot;</span> </span><br><span class="line">    <span class="attribute">ondrag</span>=<span class="string">&quot;fooDrag(this, event)&quot;</span> </span><br><span class="line">    <span class="attribute">ondragend</span>=<span class="string">&quot;fooDragEnd(this, event)&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong>目标元素</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>  <span class="built_in">id</span>=<span class="string">&quot;div1&quot;</span> ondrop=<span class="string">&quot;fooDrop(this, event)&quot;</span></span><br><span class="line">                ondragenter=<span class="string">&quot;fooDragEnter(this, event)&quot;</span> </span><br><span class="line">                ondragleave=<span class="string">&quot;fooDragLeave(this, event)&quot;</span></span><br><span class="line">                ondragover=<span class="string">&quot;fooDragOver(this,event)&quot;</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-3-执行顺序"><a href="#7-3-执行顺序" class="headerlink" title="7.3 执行顺序"></a>7.3 执行顺序</h4><p>下面，我将展示将一张图片放入div中的整个script执行过程：</p>
<p><strong>执行元素介绍</strong></p>
<p><img data-src="pic1.jpg"></p>
<p><strong>执行结果</strong></p>
<ul>
<li>成功将图片拖入div中</li>
</ul>
<p><img data-src="pic2.jpg"></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">on</span>DragStart，当元素被拖动到一个合法的放置目标时，执行脚本（对象是目标元素）</span><br><span class="line"><span class="keyword">on</span>Drag，只要脚本在被拖动就允许脚本</span><br><span class="line"><span class="keyword">on</span>Drag，只要脚本在被拖动就允许脚本</span><br><span class="line"><span class="keyword">on</span>DragEnter，在拖动操作开始时执行脚本</span><br><span class="line"><span class="keyword">on</span>DragOver，只要元素正在合法的放置目标上拖动时，就执行脚本（对象是目标元素）</span><br><span class="line"><span class="keyword">on</span>Drag，只要脚本在被拖动就允许脚本</span><br><span class="line"><span class="keyword">on</span>DragOver，只要元素正在合法的放置目标上拖动时，就执行脚本（对象是目标元素）</span><br><span class="line"><span class="keyword">on</span>Drop，在拖动操作结束时运行脚本-------------------------------------</span><br><span class="line"><span class="keyword">on</span>DragEnd，在拖动操作结束时运行脚本</span><br></pre></td></tr></table></figure>

<ul>
<li>已拖放，可最终未放入div中</li>
</ul>
<p><img data-src="pic3.jpg"></p>
<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line"><span class="keyword">on</span>DragStart，当元素被拖动到一个合法的放置目标时，执行脚本（对象是目标元素）</span><br><span class="line"><span class="keyword">on</span>Drag，只要脚本在被拖动就允许脚本</span><br><span class="line"><span class="keyword">on</span>Drag，只要脚本在被拖动就允许脚本</span><br><span class="line"><span class="keyword">on</span>DragEnter，在拖动操作开始时执行脚本</span><br><span class="line"><span class="keyword">on</span>DragOver，只要元素正在合法的放置目标上拖动时，就执行脚本（对象是目标元素）</span><br><span class="line"><span class="keyword">on</span>Drag，只要脚本在被拖动就允许脚本</span><br><span class="line"><span class="keyword">on</span>DragOver，只要元素正在合法的放置目标上拖动时，就执行脚本（对象是目标元素）</span><br><span class="line"><span class="keyword">on</span>Drag，只要脚本在被拖动就允许脚本</span><br><span class="line"><span class="keyword">on</span>DragLeave，当元素离开合法的放置目标时（对象是目标元素）---------------------</span><br><span class="line"><span class="keyword">on</span>Drag，只要脚本在被拖动就允许脚本</span><br><span class="line"><span class="keyword">on</span>Drag，只要脚本在被拖动就允许脚本</span><br><span class="line"><span class="keyword">on</span>DragEnd，在拖动操作结束时运行脚本</span><br></pre></td></tr></table></figure>

<p>由上两个执行顺序的Log能看出：</p>
<blockquote>
<ol>
<li>只有将“被拖拽元素”放入“目标元素”才会执行“onDrop”属性的方法；</li>
<li>“onDrag”的事件只要鼠标按住并且拖动就会持续不断的执行；</li>
<li>“onDragOver”的事件是只要鼠标按住、拖动“被拖拽元素”在“目标元素”上滑过就会持续不断的执行；</li>
<li>“onDragEnd”的事件无论如何，只要按住的鼠标放开了，就会执行</li>
</ol>
</blockquote>
<h4 id="7-4-深入"><a href="#7-4-深入" class="headerlink" title="7.4 深入"></a>7.4 深入</h4><p>一些深入的比如“<code>文件的拖放</code>”、“<code>从浏览器拖放到桌面</code>”以及“<code>从桌面拖放到浏览器</code>”等</p>
<h4 id="7-5-扩展"><a href="#7-5-扩展" class="headerlink" title="7.5 扩展"></a>7.5 扩展</h4><h5 id="7-5-1-MIME类型"><a href="#7-5-1-MIME类型" class="headerlink" title="7.5.1 MIME类型"></a>7.5.1 MIME类型</h5><blockquote>
<p>  ·text/plain：文本文字</p>
<p>  ·text/html：HTML文字</p>
<p>  ·text/xml：XML文字</p>
<p>  ·text/uri-list：URL列表，每个URL为一行</p>
</blockquote>
<h5 id="7-5-2-JS的dataTransfer对象"><a href="#7-5-2-JS的dataTransfer对象" class="headerlink" title="7.5.2 JS的dataTransfer对象"></a>7.5.2 JS的dataTransfer对象</h5><p>​    提供对于预定义的剪贴板格式的访问,以便在拖拽中使用。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>dropEffect</td>
<td>设置或返回拖放目标上允许发生的拖放行为和要显示的光标类型</td>
<td>copy 复制样式被显示link 链接样式被显示move 移动样式被显示none 默认,没有鼠标样式被定义</td>
</tr>
<tr>
<td>effectAllowed</td>
<td>设置或返回被拖动元素允许发生的拖动行为与该对象的源元素。</td>
<td>copy 选项被复制link 选项被dataTransfer作为link方式保存move 当放置时,对象被移动至目标对象copylink 选项是被复制还是被作为link方式保存关键在于目标对象linkmove 选项是被作为link方式保存还是被移动关键在于目标对象all 所有效果都被支持none 不支持任何效果uninitialized 默认不能通过这个属性传递任何值</td>
</tr>
<tr>
<td>types</td>
<td>存入数据的种类，字符串的伪数组</td>
<td></td>
</tr>
<tr>
<td>clearData()</td>
<td>清除DataTransfer对象中存放的数据，如果省略参数format，则清楚全部数据</td>
<td></td>
</tr>
<tr>
<td>setData(format,data)</td>
<td>将指定格式的数据赋值给dataTransfer对象</td>
<td>参数format定义数据的格式也就是数据的类型，data为待赋值的数据</td>
</tr>
<tr>
<td>getData(format,data)</td>
<td>从dataTransfer对象中获取指定格式的数据</td>
<td>format代表数据格式，data为数据。</td>
</tr>
<tr>
<td>setDragImage(Element image，long x,long y)</td>
<td>用img元素来设置拖放图标(部分浏览器中可以用canvas等其他元素来设置)</td>
<td>element设置自定义图标，x设置图标与鼠标在水平方向上的距离，y设置图标与鼠标在垂直方向上的距离。</td>
</tr>
</tbody></table>
<p>​    effectAllowed定义了在源对象上的操作,可定义在ondragstart事件中。 </p>
<p>​    dropEffect定义了在目标对象上的操作,可定义在ondrop,ondragenter,ondragover事件中。 </p>
<p>​    effectAllowed可以定义all操作,但是dropEffect可以定义copy操作。</p>
<h3 id="8-Web-Storage"><a href="#8-Web-Storage" class="headerlink" title="8 Web Storage"></a>8 Web Storage</h3><p>使用HTML5可以在本地存储用户的浏览数据。</p>
<p>客户端存储数据的两个对象为：</p>
<p><strong>localStorage ：</strong>没有时间限制的数据存储</p>
<p><strong>sessionStorage ：</strong> 针对一个 session 的数据存储, 当用户关闭浏览器窗口后，数据会被删除。</p>
<p>不管是 <strong>localStorage</strong>，还是 <strong>sessionStorage</strong>，可使用的API都相同，常用的有如下几个（以localStorage为例）：</p>
<p>　　1、保存数据：localStorage.setItem(key,value);</p>
<p>　　2、读取数据：localStorage.getItem(key);</p>
<p>　　3、删除单个数据：localStorage.removeItem(key);</p>
<p>　　4、删除所有数据：localStorage.clear();</p>
<p>　　5、得到某个索引的key：localStorage.key(index);</p>
<h3 id="9-WebSocket"><a href="#9-WebSocket" class="headerlink" title="9. WebSocket"></a>9. WebSocket</h3><blockquote>
<p>可参考 <a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">阮一峰日志</a> 深入学习</p>
<p>其中用到的<a href="https://jsbin.com/muqamiqimu/edit?js,console">演示平台</a> <code>jsbin.com</code></p>
<p>以及其使用<a href="https://www.cnblogs.com/rammstein/p/4042842.html">教程</a></p>
</blockquote>
<p><strong>WebSocket</strong> 是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p>
<blockquote>
<p><a href="https://baike.baidu.com/item/RS-422">RS-422</a>标准就是<a href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5/310007">全双工</a>通信标准。全双工（Full Duplex）是 在微处理器与外围设备之间采用发送线和接受线各自独立的方法，可以使数据在两个方向上同时进行传送操作。指在发送数据的同时也能够接收数据，两者同步进行，这好像我们平时打电话一样，说话的同时也能够听到对方的声音。网卡一般都支持全双工。</p>
<p><a href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5%E4%BB%A5%E5%A4%AA%E7%BD%91">全双工以太网</a>使用两条电缆线，而不是像<a href="https://baike.baidu.com/item/%E5%8D%8A%E5%8F%8C%E5%B7%A5/309852">半双工</a>方式那样使用一对电缆线。全双工方式在发送设备的发送方和接收设备的接收方之间采取点到点的连接，这意味着在全双工的传送方式下，可以得到更高的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E9%80%9F%E5%BA%A6">数据传输速度</a>。</p>
</blockquote>
<p>在WebSocket22通过 <strong>send()</strong> 方法来向服务器发送数据，并通过 <strong>onmessage</strong> 事件来接收服务器返回的数据。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>W3Cschool教程(w3cschool.cn)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">         <span class="function"><span class="keyword">function</span> <span class="title">WebSocketTest</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (<span class="string">&quot;WebSocket&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span></span><br><span class="line"><span class="javascript">               alert(<span class="string">&quot;您的浏览器支持 WebSocket!&quot;</span>);</span></span><br><span class="line">               </span><br><span class="line"><span class="javascript">               <span class="comment">// 打开一个 web socket</span></span></span><br><span class="line"><span class="javascript">               <span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:9998/echo&quot;</span>);</span></span><br><span class="line">                </span><br><span class="line"><span class="javascript">               ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                  <span class="comment">// Web Socket 已连接上，使用 send() 方法发送数据</span></span></span><br><span class="line"><span class="javascript">                  ws.send(<span class="string">&quot;发送数据&quot;</span>);</span></span><br><span class="line"><span class="javascript">                  alert(<span class="string">&quot;数据发送中...&quot;</span>);</span></span><br><span class="line">               &#125;;</span><br><span class="line">                </span><br><span class="line"><span class="javascript">               ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">                  <span class="keyword">var</span> received_msg = evt.data;</span></span><br><span class="line"><span class="javascript">                  alert(<span class="string">&quot;数据已接收...&quot;</span>);</span></span><br><span class="line">               &#125;;</span><br><span class="line">                </span><br><span class="line"><span class="javascript">               ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span></span><br><span class="line"><span class="javascript">                  <span class="comment">// 关闭 websocket</span></span></span><br><span class="line"><span class="javascript">                  alert(<span class="string">&quot;连接已关闭...&quot;</span>); </span></span><br><span class="line">               &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line"><span class="javascript">            <span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="comment">// 浏览器不支持 WebSocket</span></span></span><br><span class="line"><span class="javascript">               alert(<span class="string">&quot;您的浏览器不支持 WebSocket!&quot;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sse&quot;</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:WebSocketTest()&quot;</span>&gt;</span>运行 WebSocket<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="二、浏览器标准模式和怪异模式"><a href="#二、浏览器标准模式和怪异模式" class="headerlink" title="二、浏览器标准模式和怪异模式"></a>二、浏览器标准模式和怪异模式</h2><blockquote>
<p>转自<a href="https://www.jianshu.com/p/dcab7cde8c04">简书</a></p>
</blockquote>
<h3 id="标准模式和怪异模式的来由"><a href="#标准模式和怪异模式的来由" class="headerlink" title="标准模式和怪异模式的来由"></a>标准模式和怪异模式的来由</h3><p>在HTML与CSS的标准化未完成之前，各个浏览器对于HTML和CSS的解析有各自不同的实现，而有很多旧的网页都是按照这些非标准的实现去设计的。在HTML与CSS标准确定之后，浏览器一方面要按照标准去实现对HTML与CSS的支持，另一方面又要保证对非标准的旧网页设计的后向兼容性。因此，现代的浏览器一般都有两种渲染模式：<strong>标准模式</strong>和<strong>怪异模式</strong>。在<strong>标准模式</strong>下，浏览器按照HTML与CSS标准对文档进行解析和渲染；而在<strong>怪异模式</strong>下，浏览器则按照旧有的非标准的实现方式对文档进行解析和渲染。这样的话，对于旧有的网页，浏览器启动怪异模式，就能够使得旧网页正常显示；对于新的网页，则可以启动标准模式，使得新网页能够使用HTML与CSS的标准特性。</p>
<h3 id="浏览器如何确定使用哪种渲染模式"><a href="#浏览器如何确定使用哪种渲染模式" class="headerlink" title="浏览器如何确定使用哪种渲染模式"></a>浏览器如何确定使用哪种渲染模式</h3><p>知道了这两种渲染模式的来由，那剩下的问题就是浏览器如何能够确定应该使用哪种模式了。其实归根结底就是，浏览器如何能将旧网页与新网页区分开来。<br> 平常编写网页的时候，一般都会见到HTML文档的头部会有文档类型声明：<code>DOCTYPE</code>。当浏览器遇到正确的文档声明时，浏览器就会启动标准模式，按照制定的文档类型标准解析和渲染文档。而对于旧有的网页，由于网页编写的当时标准还没有确定，所以一般是不会有文档类型声明的。所以，对于没有文档类型声明或者文档类型声明不正确的文档，浏览器就会认为它是一个旧的HTML文档，就会使用怪异模式解析和渲染该文档。关于<code>DOCTYPE</code>的更详细说明，请戳这里 <a href="https://www.jb51.net/web/34217.html">DOCTYPE声明作用及用法详解</a>。</p>
<h3 id="标准模式与怪异模式的两个常见区别"><a href="#标准模式与怪异模式的两个常见区别" class="headerlink" title="标准模式与怪异模式的两个常见区别"></a>标准模式与怪异模式的两个常见区别</h3><ul>
<li><strong>盒模型的处理差异：</strong>标准CSS盒模型的宽度和高度等于内容区的高度和宽度，不包含内边距和边框，而IE6之前的浏览器实现的盒模型的宽高计算方式是包含内边距和边框的。因此，对于IE，怪异模式和标准模式下的盒模型宽高计算方式是不一样的；</li>
<li><strong>行内元素的垂直对齐：</strong>很多早期的浏览器对齐图片至包含它们的盒子的下边框，虽然CSS的规范要求它们被对齐至盒内文本的基线。标准模式下，基于Gecko的浏览器将会对齐至基线，而在quirks模式下它们会对齐至底部。最直接的例子就是图片的显示。在标准模式下，图片并不是与父元素的下边框对齐的，如果仔细观察，你会发现图片与父元素下边框之间存在一点小空隙。那是因为标准模式下，图片是基线对齐的。而怪异模式下，则不存在这个问题。具体请看这篇文章 <a href="https://www.zhangxinxu.com/wordpress/2015/08/css-deep-understand-vertical-align-and-line-height/?shrink=1">CSS深入理解vertical-align和line-height的基友关系</a>。</li>
</ul>
<h2 id="三、HTML与XHTML的区别"><a href="#三、HTML与XHTML的区别" class="headerlink" title="三、HTML与XHTML的区别"></a>三、HTML与XHTML的区别</h2><blockquote>
<p><code>HTML</code>(文本标记语言)是英文HyperText Markup Language的简称，用于创建网页的标准标记语言，html并不是编程语言，HTML 运行在浏览器上由浏览器来解析翻译给网站访客，它是建设网站的基础。Html5代表了下一代html的发展，html5功能已经很强大。</p>
<p><code>XHTML</code>(可扩展标识语言)是The Extensible Markup Language的简写,XHTML 1.0在2000年1月26日成为W3C的推荐标准。XHTML1.0是源自W3C的最新的HTML标准，是Web的语言，是M站软件幵发必不可少的Web构件之一，每一个Web开发者都需要对它熟练掌握。</p>
</blockquote>
<p><strong>功能区别：</strong></p>
<ul>
<li>HTML对于各大浏览器兼容性较差(pc端浏览器、手机端浏览器、PAD)，对于网页页面编写技巧要求比较高，现在web前端开发的静态网页，一般都是html4.0，HTML5就另当别论了。</li>
<li>XHTML可以很好处理各大浏览器的兼容(pc端浏览器、手机端浏览器、PAD)，看起来与HTML有些相象但是和HTML有不少的区别，XHTML的语法较为严谨，习惯松散结构的HTML编写者刚开始接触XHTML有些不习惯。XHTML结合了部分XML的强大功能及大多数HTML的简单特性。</li>
</ul>
<p><strong>书写习惯区别</strong></p>
<ul>
<li>HTML标签不区分大小写XHTML所有标签都必须小写。</li>
<li>XHTML标签必须成双成对.</li>
<li>html对标签顺序要求不严格，XHTML标签顺序必须正确</li>
</ul>
<h2 id="四、使用data"><a href="#四、使用data" class="headerlink" title="四、使用data-*"></a>四、使用data-*</h2><ul>
<li>data-* 属性用于存储页面或应用程序的私有自定义数据。</li>
<li>data-* 属性赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力。</li>
<li>存储的（自定义）数据能够被页面的 JavaScript 中利用，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。</li>
</ul>
<p>data-* 属性包括两部分：</p>
<p>   <strong>语法  &lt;*element* data-*=”*somevalue*”&gt;</strong></p>
<ul>
<li>属性名不应该包含任何大写字母，并且在前缀 “data-“ 之后必须有至少一个字符</li>
<li>属性值可以是任意字符串</li>
</ul>
<blockquote>
<p>注释：用户代理会完全忽略前缀为 “data-“ 的自定义属性。</p>
</blockquote>
<p><strong>Example</strong>:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showDetails</span>(<span class="params">animal</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> animalType = animal.getAttribute(<span class="string">&quot;data-animal-type&quot;</span>);</span></span><br><span class="line"><span class="javascript">alert(animal.innerHTML + <span class="string">&quot;是一种&quot;</span> + animalType + <span class="string">&quot;。&quot;</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>物种<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>点击某个物种来查看其类别：<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">onclick</span>=<span class="string">&quot;showDetails(this)&quot;</span> <span class="attr">id</span>=<span class="string">&quot;owl&quot;</span> <span class="attr">data-animal-type</span>=<span class="string">&quot;鸟类&quot;</span>&gt;</span>喜鹊<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">onclick</span>=<span class="string">&quot;showDetails(this)&quot;</span> <span class="attr">id</span>=<span class="string">&quot;salmon&quot;</span> <span class="attr">data-animal-type</span>=<span class="string">&quot;鱼类&quot;</span>&gt;</span>金枪鱼<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">onclick</span>=<span class="string">&quot;showDetails(this)&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tarantula&quot;</span> <span class="attr">data-animal-type</span>=<span class="string">&quot;蜘蛛&quot;</span>&gt;</span>蝇虎<span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>优势</strong></p>
<ul>
<li>自定义属性，可以被js很好的操作</li>
<li>H5的新属性</li>
<li>通过js的element.dataset.<em>或jQuery的data(‘</em>‘)拿到，*可以为url等字符</li>
<li>框架的数据绑定，例如<code>data-ng-if=&quot;cs==1&quot;</code></li>
</ul>
<p><strong>使用</strong></p>
<p> data-toggle 这种以 <strong>data-</strong> 开头的格式放在元素上表示元素携带的数据，如：</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line">&lt;``img` `id``=``<span class="string">&quot;img&quot;</span>` `src``=``<span class="string">&quot;small.jpg&quot;</span>` `data-bigimg``=``<span class="string">&quot;big.jpg&quot;</span>` `/&gt;</span><br></pre></td></tr></table></figure>

<p>JQuery的 <strong>data()</strong> 方法可以直接操作，如：</p>
<figure class="highlight julia"><table><tr><td class="code"><pre><span class="line">//获取：<span class="string">``</span>var<span class="string">` `</span>bigImage = $(<span class="string">``</span><span class="string">&quot;#img&quot;</span><span class="string">``</span>).data(<span class="string">``</span><span class="string">&quot;bigimg&quot;</span><span class="string">``</span>);<span class="string">``</span>//注意，这里不用加 data-</span><br><span class="line">//设置：<span class="string">``</span>$(<span class="string">``</span><span class="string">&quot;#img&quot;</span><span class="string">``</span>).data(<span class="string">``</span><span class="string">&quot;bigimg&quot;</span><span class="string">``</span>,<span class="string">``</span><span class="string">&quot;newBig.jpg&quot;</span><span class="string">``</span>);<span class="string">``</span>//注意，这里也不用加 data-</span><br></pre></td></tr></table></figure>

<p>用这种 <code>$(&quot;[data-bigimg]&quot;)</code> 的方式可以选择所有具有 <code>data-bigimg</code> 这个属性的元素。</p>
<p>也可以直接通过<code>$(&quot;#img&quot;).attr(&quot;data-bigimg&quot;);</code> 来获取和设置</p>
<h2 id="五、HTML模板引擎"><a href="#五、HTML模板引擎" class="headerlink" title="五、HTML模板引擎"></a>五、HTML模板引擎</h2><blockquote>
<p>模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，用于网站的模板引擎就会生成一个标准的<a href="https://baike.baidu.com/item/HTML/97049">HTML</a>文档。</p>
</blockquote>
<blockquote>
<p>其他待补充</p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML标签</title>
    <url>/2020/08/31/HTML-tags/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>总结了一下关于HTML标签的内容</p>
<p>–  <code>HTML5</code>废弃标签</p>
<p>–  <code>HTML5</code>新增语义化标签</p>
<p>–  <code>&lt;a&gt;</code>标签</p>
<p>–  <code>&lt;table&gt;</code>标签</p>
<p>–  <code>HTML</code>语义化</p>
</blockquote>
<a id="more"></a>

<h2 id="一、Html5废弃标签"><a href="#一、Html5废弃标签" class="headerlink" title="一、Html5废弃标签"></a>一、Html5废弃标签</h2><h3 id="第一类：表现性元素"><a href="#第一类：表现性元素" class="headerlink" title="第一类：表现性元素"></a>第一类：表现性元素</h3><ul>
<li>basefont</li>
<li>big</li>
<li>center</li>
<li>font</li>
<li>s</li>
<li>strike</li>
<li>tt</li>
<li>u</li>
</ul>
<p>建议用语义正确的元素代替他们，并使用CSS来确保渲染后的效果</p>
<h3 id="第二类：框架类元素"><a href="#第二类：框架类元素" class="headerlink" title="第二类：框架类元素"></a>第二类：框架类元素</h3><p>因框架有很多可用性及可访问性问题，HTML5规范将以下元素移除。</p>
<ul>
<li>frame</li>
<li>frameset</li>
<li>noframes</li>
</ul>
<p>但html5支持iframe。</p>
<h3 id="第三类：属性类"><a href="#第三类：属性类" class="headerlink" title="第三类：属性类"></a>第三类：属性类</h3><p>很多表现性的属性也被新规范移除，如下：</p>
<ul>
<li>align</li>
<li>body标签上的link、vlink、alink、text属性</li>
<li>bgcolor</li>
<li>height和width</li>
<li>iframe元素上的scrolling属性</li>
<li>valign</li>
<li>hspace和vspace</li>
<li>table标签上的cellpadding、cellspacing和border属性</li>
<li>header标签上的profile属性</li>
<li>链接标签a上的target属性</li>
<li>img和iframe元素的longdesc属性</li>
</ul>
<h3 id="第四类：其他"><a href="#第四类：其他" class="headerlink" title="第四类：其他"></a>第四类：其他</h3><ul>
<li>abbr取代acronym（用于表示缩写）</li>
<li>object取代了applet</li>
<li>ul取代了dir</li>
</ul>
<blockquote>
<p>另附上直观的：<a href="http://demo.yanue.net/HTML5element/">html5元素周期表</a></p>
</blockquote>
<h2 id="二、HTML5新增的语义化标签"><a href="#二、HTML5新增的语义化标签" class="headerlink" title="二、HTML5新增的语义化标签"></a>二、HTML5新增的语义化标签</h2><p>主要有：<code> &lt;article&gt;、&lt;section&gt;、&lt;nav&gt;、&lt;aside&gt;、&lt;header&gt;、&lt;footer&gt;、&lt;time&gt;</code>等等…</p>
<p><img data-src="pic1.png"></p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构</li>
<li>比<code>&lt;div&gt;</code>标签有更加丰富的含义，方便开发与维护</li>
<li>方便搜索引擎能识别页面结构，有利于<code>SEO</code></li>
<li>方便其他设备解析（如移动设备、盲人阅读器等）</li>
<li>有利于合作，遵守W3C标准</li>
</ul>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>尽可能少的使用无语义的标签div和span</li>
<li>在语义不明显时，既可以使用div或者p时，尽量用p，因为p在默认情况下有上下间距，对兼容特殊终端有利</li>
<li>不要使用纯样式标签，如：b、font、u等，改用css设置</li>
<li>需要强调的文本，可以包含在strong或者em标签中</li>
<li>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td</li>
<li>表单域要用fieldset标签包起来，并用legend标签说明表单的用途</li>
<li>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性</li>
</ul>
<h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><h4 id="1-header与hgroup"><a href="#1-header与hgroup" class="headerlink" title="1. header与hgroup"></a>1. <code>header</code>与<code>hgroup</code></h4><p>放在页面或布局的顶部，一般放置导航栏或标题，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>**信息科技有限公司<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一个文档中可以包含一对或者一对以上的<code>&lt;header&gt;</code>标签。<br> 标签的位置是次要的，不一定非要显示在页面的上方，我们可以为任何需要的区块标签添加<code>&lt;header&gt;</code>元素，例如下面将要讲解的<code>&lt;article&gt;</code>、<code>&lt;section&gt;</code>等标签。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一篇介绍HTML 5语义化标签和更简洁的结构<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>HTML 5<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hgroup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果有连续多个h1-h6标签就用hgroup</li>
<li>如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签</li>
</ul>
<h4 id="2-nav"><a href="#2-nav" class="headerlink" title="2. nav"></a>2. nav</h4><p>表示页面的导航，也可以在<code>&lt;header&gt;</code>标签中使用，还可以显示在侧边栏中。一个页面之中可以有多个<code>&lt;nav&gt;</code>标签。<br> 为了方便搜索引擎解析，最好是将主要的链接放在nav中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>**信息科技有限公司<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;example.html&quot;</span>&gt;</span>客户案例<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;service_one.html&quot;</span>&gt;</span>技术服务<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span>          </span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;aboutus_one.html&quot;</span>&gt;</span>关于我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;connection.html&quot;</span>&gt;</span>联系我们<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-aside"><a href="#3-aside" class="headerlink" title="3. aside"></a>3. aside</h4><p>所包含的内容不是页面的主要内容、具有独立性，是对页面的补充。<br><code> &lt;aside&gt;</code>一般使用在页面、文章的侧边栏、广告、友情链接等区域。</p>
<h4 id="4-footer"><a href="#4-footer" class="headerlink" title="4. footer"></a>4. footer</h4><p>一般被放置在页面或者页面中某个区块的底部，包含版权信息、联系方式等信息。一个页面也可以有多个footer</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">small</span>&gt;</span></span><br><span class="line">        版权所有 © 2016-2017 **信息科技有限公司</span><br><span class="line">    <span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="5-article"><a href="#5-article" class="headerlink" title="5. article"></a>5. article</h4><p><code>&lt;article&gt;</code>元素应该使用在相对比较独立、完整的的内容区块，所以我们可以在一篇博客、一个论坛帖子、一篇新闻报道或者一个用户评论中使用<code>&lt;article&gt;</code>元素。article可以互相嵌套。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span>&gt;</span>HTML5学习之语义化标签<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>....正文.....<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">footer</span>&gt;</span>版权所有*伪版必究<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="6-section"><a href="#6-section" class="headerlink" title="6. section"></a>6. section</h4><p>一组或者一节内容。</p>
<p><strong><code>&lt;div&gt;</code>、<code>&lt;section&gt;</code>、<code>&lt;article&gt;</code>三者的比较：</strong></p>
<p><code>&lt;div&gt;</code>：应用广泛，任意一个区域<br><code>&lt;section&gt;</code>：包含的内容是一个明确的主题，通常有标题区域<br><code>&lt;article&gt;</code>：如果我们的页面中需要一个单独的模块来实现一个单独的功能，就用<code>&lt;article&gt;</code>，其他的时候都用<code>&lt;section&gt;</code></p>
<h4 id="7-time"><a href="#7-time" class="headerlink" title="7. time"></a>7. time</h4><p>可以带格式的时间标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">time</span> <span class="attr">datetime</span>=<span class="string">&quot;2017-07-03&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="8-mark"><a href="#8-mark" class="headerlink" title="8. mark"></a>8. mark</h4><p>高亮</p>
<h4 id="9-address"><a href="#9-address" class="headerlink" title="9. address"></a>9. address</h4><p>address代表区块容器，必须是作为联系信息出现，邮编地址、邮件地址等等,一般出现在footer。</p>
<h2 id="三、-lt-a-gt-标签"><a href="#三、-lt-a-gt-标签" class="headerlink" title="三、&lt;a&gt;标签"></a>三、<code>&lt;a&gt;</code>标签</h2><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(0)&quot;</span> <span class="attr">click</span>=<span class="string">&quot;function()</span></span></span><span class="template-variable">&#123;&#125;</span><span class="xml"><span class="tag"><span class="string">&quot;</span> /&gt;</span>=</span></span><br></pre></td></tr></table></figure>

<h3 id="1-a-标签样式"><a href="#1-a-标签样式" class="headerlink" title="1. a 标签样式"></a>1. a 标签样式</h3><p> 一组专门的预定义的类称为伪类用于处理超链接的状态，超链接的文字的状态可以通过伪类选择器+样式类进行控制  <code>&lt;a class=&quot;mycls&quot; &gt;&lt;/a&gt;</code></p>
<ul>
<li><p>所有状态下的链接 <code>.mycls&#123;color:red&#125;</code></p>
</li>
<li><p><code>a:link</code> 未访问的连接<code> .mycls a:link&#123;color:blue&#125;</code></p>
</li>
<li><p><code>a:visited</code> 已访问的链接<code>.mycls a:visited&#123;color: visited&#125;</code></p>
</li>
<li><p><code>a:active</code>  激活时（链接获取焦点）链接的颜色<code> .mycls a:active&#123;color:blue&#125;</code></p>
</li>
</ul>
<p>一般情况下 a:hiver和a:visited的颜色是一种的，这4个状态的过程是： <code>a:link -&gt;a:hover-&gt;a:active-&gt;a:visited</code><br>另外，a：active不能设置有无下划线（总是有的）</p>
<pre><code> &lt;style&gt;
    a &#123;font-size:16px&#125; 
    a:link &#123;color: blue; text-decoration:none;&#125; //未访问：蓝色、无下划线 
    a:active:&#123;color: red; &#125; //激活：红色 
    a:visited &#123;color:purple;text-decoration:none;&#125; //已访问：purple、无下划线 
    a:hover &#123;color: red; text-decoration:underline;&#125; //鼠标移近：红色、下划线 
  &lt;/style&gt;</code></pre>
<h3 id="2-target的属性"><a href="#2-target的属性" class="headerlink" title="2. target的属性"></a>2. target的属性</h3><p><code>&lt;a&gt;</code>标签的target属性规定在何处打开链接文档<br>如下面这行表示在新的窗口中打开文档<br><code> &lt;a href=&quot;http://www.baidu.com&quot; target=&quot;_blank&quot;&gt; visit w3school &lt;/a&gt;</code></p>
<p>可选值：<code>_blank</code>、<code>_parent</code>、<code>_self</code>、<code>_top</code>、<code>*framename*</code></p>
<p><strong>_blank</strong>        浏览器总在一个新打开，未命名的窗口中载入目标文档 </p>
<p><strong>_self</strong>        这个目标的值对所有没有指定目标的<code>&lt;a&gt;</code>标签是默认目标。它使得目标文档载入并显示在相同的框架或者窗口中作为源文档。这个目标是多余的且不必要的，除非和文档标题<code>&lt;base&gt;</code>标签中的target属性一起使用    </p>
<p><strong>_parent</strong>        在父框架集中打开被链接的文档</p>
<p><strong>_top</strong>              在整个窗口打开被链接文档</p>
<p><strong>framename</strong>   在指定的框架中打开被链接文档</p>
<h3 id="3-name属性"><a href="#3-name属性" class="headerlink" title="3. name属性"></a>3. name属性</h3><p><code>name</code>属性规定锚(anchor)的名称，可以使用<code>name</code>属性创建html页面中的书签，书签不会以任何独特方式显示，它对读者可以是不可见的。<br>当使用<code>命名锚</code>(named anchors)时，我们可以创建直接跳转至该命名锚(比如页面中某个小节)的链接,这样使用者就无需不停滚动页面来寻找需要的信息了。<br><strong>命名语法</strong><br><code>&lt;a name=&quot;label&quot;&gt;锚(显示在页面上的文本)&lt;/a&gt;</code></p>
<ul>
<li>锚名称可以是任何名字</li>
<li>可以使用id属性来代替name属性，命名锚同样有效</li>
</ul>
<p><strong>例子</strong><br>  1)我们在html文档中对锚进行命名(创建一个书签)<br>  <code>&lt;a name=&quot;tips&quot;&gt;基本的注意事项 - 有用的提示&lt;/a&gt;</code><br>  2）在同一个文档中创建指向该锚的链接<br>  <code>&lt;a href=&quot;tips&quot;&gt;有用的提示&lt;/a&gt;</code><br>  3)也可以在其他页面中创建指向，该锚的链接<br>  <code>&lt;a href=&quot;http://mypro#trip&quot;&gt;有用的提示&lt;a&gt;</code></p>
<h3 id="4-标签事件"><a href="#4-标签事件" class="headerlink" title="4. 标签事件"></a>4. 标签事件</h3><p>将<code>&lt;a&gt;</code>标签的<code>href</code>属性值设置为”#”，并设置<code>onclick</code>属性。<br>在这种处理方式下，用户可以很明显地看出哪些文字是超链接。<br>在单击该超链接时，也可以执行onclick属性值中的JavaScript语句，并且不会跳转网页。</p>
<blockquote>
<p>但是，由于href的属性值为”#”，浏览器会自动跳 转到当前网页的顶部。<br>如果当前网页内容比较多，浏览器窗口出现下拉滚动条时，可以很明显地看到跳转，而这种跳转往往不是网页设计者的本意。</p>
</blockquote>
<p>在没有为<code>&lt;a&gt;</code>标签设置onclick属性时，如果单击了该超链接，浏览器会加载href属性中的URL。<br>如果href属性值并不是一 个URL，而是一个JavaScript语句的话，那么浏览器就会执行该语句。<br>因此，可以直接将JavaScript语句写在<code>&lt;a&gt;</code>标签的 href属性值中，让href属性代替onclick属性。</p>
<p><strong>在这种处理方式下，既可以响应click事件，又可以不让网页跳转。</strong></p>
<p><strong>注意</strong>：在 a 标签的属性值中添加JavaScript语句之前，必须要先使用”javascript:”语句来声明href属性值中的语句为<code>javaScript</code>语句，否则浏览器就会将href属性值中的JavaScript语句当成URL进行加载。<br><code>&lt;a  href=&quot;javascript:showFlag()&quot;&gt;ssgao&lt;/a&gt;  </code>   执行showFlag()方法<br><code>&lt;a  href=&quot;&quot; onclick=&quot;showFlag();&quot;&gt;ssgao&lt;/a&gt;</code>    执行showFlag()方法，并会跳转到href指向的页面—-&gt;当<code>href=&quot;&quot;</code>刷新当前页面<br><code>&lt;a  href=&quot;&quot;&gt;ssgao&lt;/a&gt;</code>  刷新当前页面<br><code>&lt;a  href=&quot;#&quot; onclick=&quot;showFlag();&quot;&gt;ssgao&lt;/a&gt;</code>   执行showFlag()方法，并会跳转到页面顶部<br><code>&lt;a href=&quot;#&quot; onclick=&quot;javascript:方法;return false;&quot;&gt;提交&lt;/a&gt;</code><br><code>&lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;javascript:方法;return false;&quot;&gt;提交&lt;/a&gt;</code><br>javascript:void(0)就不会向上跳了<br>还有一个方法是 #this<br><code>a href=&quot;#this&quot; onclick=&quot;javascript:方法&quot;</code></p>
<h3 id="5-回到顶部或底部"><a href="#5-回到顶部或底部" class="headerlink" title="5. 回到顶部或底部"></a>5. 回到顶部或底部</h3><h4 id="使用JS"><a href="#使用JS" class="headerlink" title="使用JS"></a>使用JS</h4><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;#带有滚动条的元素&quot;</span>).animate(&#123;<span class="attr">scrollTop</span>:<span class="number">0</span>&#125;,<span class="string">&#x27;fase&#x27;</span>); <span class="comment">//带有动画</span></span><br><span class="line">$(<span class="string">&quot;#带有滚动条的元素&quot;</span>).scrollTop(<span class="number">0</span>)；<span class="comment">//不带动画</span></span><br><span class="line">scrollTop 距离滚动元素顶部的位置</span><br></pre></td></tr></table></figure>

<h4 id="使用a标签的name属性-锚记"><a href="#使用a标签的name属性-锚记" class="headerlink" title="使用a标签的name属性(锚记)"></a>使用a标签的name属性(锚记)</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;a <span class="attribute">name</span>=<span class="string">&quot;top&quot;</span>&gt;top&lt;/a&gt;</span><br><span class="line">&lt;a <span class="attribute">href</span>=<span class="string">&quot;#top&quot;</span>&gt; 点击此处跳转到<span class="attribute">name</span>=top的a标签的位置    </span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_charset.asp">charset</a></td>
<td align="left"><em>char_encoding</em></td>
<td align="left"><span style="color:red;">HTML5 中不支持。</span>规定被链接文档的字符集。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_coords.asp">coords</a></td>
<td align="left"><em>coordinates</em></td>
<td align="left"><span style="color:red;">HTML5 中不支持。</span>规定链接的坐标。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_download.asp">download</a></td>
<td align="left"><em>filename</em></td>
<td align="left">规定被下载的超链接目标。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_href.asp">href</a></td>
<td align="left"><em>URL</em></td>
<td align="left">规定链接指向的页面的 URL。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_hreflang.asp">hreflang</a></td>
<td align="left"><em>language_code</em></td>
<td align="left">规定被链接文档的语言。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_media.asp">media</a></td>
<td align="left"><em>media_query</em></td>
<td align="left">规定被链接文档是为何种媒介/设备优化的。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_name.asp">name</a></td>
<td align="left"><em>section_name</em></td>
<td align="left"><span style="color:red;">HTML5 中不支持。</span>规定锚的名称。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_rel.asp">rel</a></td>
<td align="left"><em>text</em></td>
<td align="left">规定当前文档与被链接文档之间的关系。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_rev.asp">rev</a></td>
<td align="left"><em>text</em></td>
<td align="left"><span style="color:red;">HTML5 中不支持。</span>规定被链接文档与当前文档之间的关系。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_shape.asp">shape</a></td>
<td align="left">defaultrectcirclepoly</td>
<td align="left"><span style="color:red;">HTML5 中不支持。</span>规定链接的形状。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_target.asp">target</a></td>
<td align="left">_blank_parent_self_top<em>framename</em></td>
<td align="left">规定在何处打开链接文档。</td>
</tr>
<tr>
<td align="left"><a href="https://www.w3school.com.cn/tags/att_a_type.asp">type</a></td>
<td align="left"><em>MIME type</em></td>
<td align="left">规定被链接文档的的 MIME 类型。</td>
</tr>
</tbody></table>
<h2 id="四、HTML-lt-table-gt-标签功能"><a href="#四、HTML-lt-table-gt-标签功能" class="headerlink" title="四、HTML&lt;table&gt;标签功能"></a>四、HTML<code>&lt;table&gt;</code>标签功能</h2><p>绘制表格使用；如果是做后台管理的用户列表等类似 Excel 功能，这个标签是最佳的选择</p>
<h3 id="1-table基础"><a href="#1-table基础" class="headerlink" title="1. table基础"></a>1. <code>table</code>基础</h3><ul>
<li><code>&lt;table&gt;</code> 标签定义 HTML 表格</li>
<li>一个 HTML 表格包括 <code>&lt;table&gt;</code> 元素，一个或多个 <code>&lt;tr&gt;</code>、<code>&lt;th&gt;</code> 以及 <code>&lt;td&gt;</code> 元素。</li>
<li><code>&lt;tr&gt;</code> 元素定义表格行</li>
<li><code>&lt;th&gt;</code> 元素定义表头</li>
<li><code>&lt;td&gt;</code> 元素定义表格单元</li>
</ul>
<p><strong>更复杂的 HTML 表格也可能包括</strong></p>
<ul>
<li><code>&lt;caption&gt;</code></li>
<li><code>&lt;col&gt;</code></li>
<li><code>&lt;colgroup&gt;</code></li>
<li><code>&lt;thead&gt;</code></li>
<li><code>&lt;tfoot&gt;</code></li>
<li><code>&lt;tbody&gt;</code></li>
</ul>
<p><strong>HTML <code>&lt;table&gt; </code>标签用法</strong></p>
<p>一个简单的 HTML 表格，包含两列两行：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>网站名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>网址<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<p>虽然现在 DIV+CSS 布局非常流行，是取代 table 布局的好选择；</p>
<p>但是遇到 table 相关的东西，还是使用<code>table</code>标签更佳，请根据实际场景进行选择</p>
<hr>
<p><strong>HTML4 与 HTML5 之间的差异</strong></p>
<p>在 HTML5 中，仅支持 “border” 属性，并且只允许使用值 “1” 或 “”。</p>
<h3 id="2-表格样式案例"><a href="#2-表格样式案例" class="headerlink" title="2. 表格样式案例"></a>2. 表格样式案例</h3><h4 id="2-1-单像素CSS表格"><a href="#2-1-单像素CSS表格" class="headerlink" title="2.1 单像素CSS表格"></a>2.1 单像素CSS表格</h4><p><img data-src="table-1.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS goes in the document HEAD or added to your external stylesheet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.gridtable</span> &#123;</span></span><br><span class="line">    font-family: verdana,arial,sans-serif;</span><br><span class="line"><span class="css">    <span class="selector-tag">font-size</span><span class="selector-pseudo">:11px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>:<span class="selector-id">#333333</span>;</span></span><br><span class="line">    border-width: 1px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#666666</span>;</span></span><br><span class="line">    border-collapse: collapse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.gridtable</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line">    border-width: 1px;</span><br><span class="line">    padding: 8px;</span><br><span class="line">    border-style: solid;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#666666</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#dedede</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.gridtable</span> <span class="selector-tag">td</span> &#123;</span></span><br><span class="line">    border-width: 1px;</span><br><span class="line">    padding: 8px;</span><br><span class="line">    border-style: solid;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#666666</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#ffffff</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- Table goes in the document BODY --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;gridtable&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 1<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 2<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 1A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 1B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 1C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 2A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 2B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 2C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-带背景图的CSS样式表格"><a href="#2-2-带背景图的CSS样式表格" class="headerlink" title="2.2 带背景图的CSS样式表格"></a>2.2 带背景图的CSS样式表格</h4><p><img data-src="table-2.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS goes in the document HEAD or added to your external stylesheet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.imagetable</span> &#123;</span></span><br><span class="line">    font-family: verdana,arial,sans-serif;</span><br><span class="line"><span class="css">    <span class="selector-tag">font-size</span><span class="selector-pseudo">:11px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>:<span class="selector-id">#333333</span>;</span></span><br><span class="line">    border-width: 1px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#999999</span>;</span></span><br><span class="line">    border-collapse: collapse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.imagetable</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line">    background:#b5cfd2 url(&#x27;cell-blue.jpg&#x27;);</span><br><span class="line">    border-width: 1px;</span><br><span class="line">    padding: 8px;</span><br><span class="line">    border-style: solid;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#999999</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.imagetable</span> <span class="selector-tag">td</span> &#123;</span></span><br><span class="line">    background:#dcddc0 url(&#x27;cell-grey.jpg&#x27;);</span><br><span class="line">    border-width: 1px;</span><br><span class="line">    padding: 8px;</span><br><span class="line">    border-style: solid;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#999999</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- Table goes in the document BODY --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;imagetable&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 1<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 2<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 1A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 1B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 1C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 2A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 2B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 2C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-自动换整行颜色的CSS样式表格（需要用到JS）"><a href="#2-3-自动换整行颜色的CSS样式表格（需要用到JS）" class="headerlink" title="2.3 自动换整行颜色的CSS样式表格（需要用到JS）"></a>2.3 自动换整行颜色的CSS样式表格（需要用到JS）</h4><p><img data-src="table-3.png"></p>
<p>这个CSS表格会自动切换每一行的颜色，这种呈现方式，在我们编辑一个数据庞大的表格时，非常好用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Javascript goes in the document HEAD --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">altRows</span>(<span class="params">id</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span>(<span class="built_in">document</span>.getElementsByTagName)&#123; </span></span><br><span class="line">         </span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> table = <span class="built_in">document</span>.getElementById(id); </span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> rows = table.getElementsByTagName(<span class="string">&quot;tr&quot;</span>);</span></span><br><span class="line">          </span><br><span class="line">        for(i = 0; i &lt; rows.length; i++)&#123;         </span><br><span class="line">            if(i % 2 == 0)&#123;</span><br><span class="line"><span class="javascript">                rows[i].className = <span class="string">&quot;evenrowcolor&quot;</span>;</span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                rows[i].className = <span class="string">&quot;oddrowcolor&quot;</span>;</span></span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    altRows(<span class="string">&#x27;alternatecolor&#x27;</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- CSS goes in the document HEAD or added to your external stylesheet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.altrowstable</span> &#123;</span></span><br><span class="line">    font-family: verdana,arial,sans-serif;</span><br><span class="line"><span class="css">    <span class="selector-tag">font-size</span><span class="selector-pseudo">:11px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>:<span class="selector-id">#333333</span>;</span></span><br><span class="line">    border-width: 1px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#a9c6c9</span>;</span></span><br><span class="line">    border-collapse: collapse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.altrowstable</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line">    border-width: 1px;</span><br><span class="line">    padding: 8px;</span><br><span class="line">    border-style: solid;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#a9c6c9</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.altrowstable</span> <span class="selector-tag">td</span> &#123;</span></span><br><span class="line">    border-width: 1px;</span><br><span class="line">    padding: 8px;</span><br><span class="line">    border-style: solid;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#a9c6c9</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.oddrowcolor</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>:<span class="selector-id">#d4e3e5</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.evenrowcolor</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>:<span class="selector-id">#c3dde0</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- Table goes in the document BODY --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;altrowstable&quot;</span> <span class="attr">id</span>=<span class="string">&quot;alternatecolor&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 1<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 2<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 1A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 1B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 1C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 2A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 2B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 2C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 3A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 3B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 3C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 4A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 4B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 4C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 5A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 5B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Text 5C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!--  The table code can be found here: http://www.textfixer/resources/css-tables.php#css-table03 --&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-鼠标悬停高亮的CSS样式表格-需要JS"><a href="#2-4-鼠标悬停高亮的CSS样式表格-需要JS" class="headerlink" title="2.4 鼠标悬停高亮的CSS样式表格 (需要JS)"></a>2.4 鼠标悬停高亮的CSS样式表格 (需要JS)</h4><p><img data-src="table-4.png"></p>
<p>纯CSS显示表格高亮在IE中显示有问题，所以这边使用了JS来做高亮。</p>
<p><strong>注意</strong>：不要定义格子的背景色。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- CSS goes in the document HEAD or added to your external stylesheet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.hovertable</span> &#123;</span></span><br><span class="line">    font-family: verdana,arial,sans-serif;</span><br><span class="line"><span class="css">    <span class="selector-tag">font-size</span><span class="selector-pseudo">:11px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>:<span class="selector-id">#333333</span>;</span></span><br><span class="line">    border-width: 1px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#999999</span>;</span></span><br><span class="line">    border-collapse: collapse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.hovertable</span> <span class="selector-tag">th</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>:<span class="selector-id">#c3dde0</span>;</span></span><br><span class="line">    border-width: 1px;</span><br><span class="line">    padding: 8px;</span><br><span class="line">    border-style: solid;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#a9c6c9</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.hovertable</span> <span class="selector-tag">tr</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>:<span class="selector-id">#d4e3e5</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-tag">table</span><span class="selector-class">.hovertable</span> <span class="selector-tag">td</span> &#123;</span></span><br><span class="line">    border-width: 1px;</span><br><span class="line">    padding: 8px;</span><br><span class="line">    border-style: solid;</span><br><span class="line"><span class="css">    <span class="selector-tag">border-color</span>: <span class="selector-id">#a9c6c9</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">&lt;!-- Table goes in the document BODY --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;hovertable&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 1<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 2<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>Info Header 3<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">onmouseover</span>=<span class="string">&quot;this.style.backgroundColor=&#x27;#ffff66&#x27;;&quot;</span> <span class="attr">onmouseout</span>=<span class="string">&quot;this.style.backgroundColor=&#x27;#d4e3e5&#x27;;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 1A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 1B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 1C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">onmouseover</span>=<span class="string">&quot;this.style.backgroundColor=&#x27;#ffff66&#x27;;&quot;</span> <span class="attr">onmouseout</span>=<span class="string">&quot;this.style.backgroundColor=&#x27;#d4e3e5&#x27;;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 2A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 2B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 2C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">onmouseover</span>=<span class="string">&quot;this.style.backgroundColor=&#x27;#ffff66&#x27;;&quot;</span> <span class="attr">onmouseout</span>=<span class="string">&quot;this.style.backgroundColor=&#x27;#d4e3e5&#x27;;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 3A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 3B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 3C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">onmouseover</span>=<span class="string">&quot;this.style.backgroundColor=&#x27;#ffff66&#x27;;&quot;</span> <span class="attr">onmouseout</span>=<span class="string">&quot;this.style.backgroundColor=&#x27;#d4e3e5&#x27;;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 4A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 4B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 4C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">onmouseover</span>=<span class="string">&quot;this.style.backgroundColor=&#x27;#ffff66&#x27;;&quot;</span> <span class="attr">onmouseout</span>=<span class="string">&quot;this.style.backgroundColor=&#x27;#d4e3e5&#x27;;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 5A<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 5B<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Item 5C<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="五、HTML-语义化"><a href="#五、HTML-语义化" class="headerlink" title="五、HTML 语义化"></a>五、HTML 语义化</h2><h3 id="1-什么是HTML语义化标签"><a href="#1-什么是HTML语义化标签" class="headerlink" title="1. 什么是HTML语义化标签"></a>1. 什么是HTML语义化标签</h3><p>语义化的标签，说明让标签有自己的含义。</p>
<p><code>&lt;p&gt;一行文字&lt;/p&gt;</code></p>
<p><code>&lt;span&gt;一行文字&lt;/span&gt;</code></p>
<p>如上代码，p 标签与 span 标签都区别之一就是，p 标签的含义是：段落。而 span 标签责没有独特的含义。</p>
<h3 id="2-语义化标签的特点"><a href="#2-语义化标签的特点" class="headerlink" title="2. 语义化标签的特点"></a>2. 语义化标签的特点</h3><ul>
<li><p>代码结构清晰，方便阅读，有利于团队合作开发。</p>
</li>
<li><p>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以语义的方式来渲染网页。</p>
</li>
<li><p>有利于搜索引擎优化（SEO）。</p>
</li>
<li><p>便于团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p>
</li>
</ul>
<h3 id="3-常见的语义化标签"><a href="#3-常见的语义化标签" class="headerlink" title="3. 常见的语义化标签"></a>3. 常见的语义化标签</h3><p>因此我们在写页面结构时，应尽量使用有 语义的HTML 标签</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>：页面主体内容。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hn</span>&gt;</span>：h1~h6，分级标题，`<span class="tag">&lt;<span class="name">h1</span>&gt;</span>` 与 `<span class="tag">&lt;<span class="name">title</span>&gt;</span>` 协调有利于搜索引擎优化。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>：无序列表。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>：有序列表。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>：页眉通常包括网站标志、主导航、全站链接以及搜索框。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>：标记导航，仅对文档中重要的链接群使用。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span>：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span>：定义外部的内容，其中的内容独立于文档的其余部分。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>：定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span>：定义其所处内容之外的内容。如侧栏、文章的一组链接、广告、友情链接、相关产品列表等。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>：页脚，只有当父级是body时，才是整个页面的页脚。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>：呈现小号字体效果，指定细则，输入免责声明、注解、署名、版权。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>：和 em 标签一样，用于强调文本，但它强调的程度更强一些。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>：将其中的文本表示为强调的内容，表现为斜体。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mark</span>&gt;</span>：使用黄色突出显示部分文本。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span>：规定独立的流内容（图像、图表、照片、代码等等）（默认有40px左右margin）。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>：定义 figure 元素的标题，应该被置于 figure 元素的第一个或最后一个子元素的位置。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">cite</span>&gt;</span>：表示所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">blockquoto</span>&gt;</span>：定义块引用，块引用拥有它们自己的空间。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">q</span>&gt;</span>：短的引述（跨浏览器问题，尽量避免使用）。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">time</span>&gt;</span>：datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">abbr</span>&gt;</span>：简称或缩写。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dfn</span>&gt;</span>：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span>：移除的内容。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span>：添加的内容。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>：标记代码。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span>&gt;</span>：定义已知范围或分数值内的标量测量。（Internet Explorer 不支持 meter 标签）</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">progress</span>&gt;</span>：定义运行中的进度（进程）。</span><br></pre></td></tr></table></figure>



<blockquote>
<p>参考<a href="http://yanue.net/">半叶寒羽</a> » <a href="http://yanue.net/post-106.html">HTML5废弃的标签及属性</a></p>
</blockquote>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML渲染</title>
    <url>/2020/08/29/HTML-render/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>下面，总结了关于页面渲染的相关内容</p>
<p>–  <code>HTML</code>渲染或者说 <code>JavaScript</code>页面渲染原理</p>
<p>–  渲染优化方案</p>
</blockquote>
<a id="more"></a>

<h2 id="一、HTML渲染过程"><a href="#一、HTML渲染过程" class="headerlink" title="一、HTML渲染过程"></a>一、HTML渲染过程</h2><h3 id="1-HTML解析过程"><a href="#1-HTML解析过程" class="headerlink" title="1. HTML解析过程"></a>1. HTML解析过程</h3><ol>
<li><p><strong>构建DOM树</strong>：将HTML构建成一个DOM树，也就是构建节点，把所有的节点都构建出来</p>
</li>
<li><p><strong>构建CSSOM树</strong>：解析css去构建CSSOM树</p>
</li>
<li><p><strong>根据DOM树和CSSOM树构建render树</strong>：DOM树和CSSOM树已经构建完毕，浏览器会根据这两个来构造render树，浏览器就知道了有哪些节点、各个节点的CSS定义以及他们的从属关系</p>
</li>
<li><p><strong>布局</strong>：有了render树就开始布局Layout，开始计算各个节点的位置和样式</p>
</li>
<li><p><strong>绘制</strong>：遍历render树，在页面上绘制每个节点</p>
</li>
<li><p><strong><em>重排reflow</em></strong>：当render树绘制完成之后，比如JavaScript改变样式或添加节点，这时候render树就需要重新计算</p>
</li>
<li><p><strong><em>重绘repaint</em></strong>：既然重排了，最后当然得重新绘制页面。</p>
</li>
</ol>
<h3 id="2-浏览器渲染页面详解"><a href="#2-浏览器渲染页面详解" class="headerlink" title="2. 浏览器渲染页面详解"></a>2. 浏览器渲染页面详解</h3><blockquote>
<p>找了一篇已经很全的文章，所以不继续造轮子了，接下来分享一下<a href="https://segmentfault.com/a/1190000010298038">这篇文章</a>，同时感谢原作者</p>
</blockquote>
<p>由一道面试题引发的思考：</p>
<p><strong>从用户输入浏览器输入url到页面最后呈现 有哪些过程？</strong><br><em>一道很常规的题目，考的是基本网络原理，和浏览器加载css，js过程。</em></p>
<p><strong><em>答案大致如下：</em></strong></p>
<blockquote>
<ol>
<li><p>用户输入URL地址</p>
</li>
<li><p>浏览器解析URL解析出主机名</p>
</li>
<li><p>浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）</p>
</li>
<li><p>浏览器将端口号从URL中解析出来</p>
</li>
<li><p>浏览器建立一条与目标Web服务器的TCP连接（三次握手）</p>
</li>
<li><p>浏览器向服务器发送一条HTTP请求报文</p>
</li>
<li><p>服务器向浏览器返回一条HTTP响应报文</p>
</li>
<li><p>关闭连接 浏览器解析文档</p>
</li>
<li><p>如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕</p>
</li>
</ol>
</blockquote>
<p><strong>通过研究，了解一些基本常识的原理：</strong></p>
<ol>
<li>为什么要将js放到页脚部分</li>
<li>引入样式的几种方式的权重</li>
<li>css属性书写顺序建议</li>
<li>何种类型的DOM操作是耗费性能的</li>
</ol>
<h4 id="2-1-浏览器渲染主要流程"><a href="#2-1-浏览器渲染主要流程" class="headerlink" title="2.1 浏览器渲染主要流程"></a>2.1 浏览器渲染主要流程</h4><p>不同的浏览器内核不同，所以渲染过程不太一样。</p>
<p><code>WebKit 主流程</code></p>
<p><img data-src="pic1.png"></p>
<p><code>Mozilla</code> 的 <code>Gecko</code> 呈现引擎主流程</p>
<p><img data-src="pic2.png"></p>
<p>由上面两张图可以看出，虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。</p>
<p><code>Gecko</code> 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。<br>WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。</p>
<p>对于元素的放置，<code>WebKit</code> 使用的术语是“布局”，而 <code>Gecko</code> 称之为“重排”。</p>
<p>对于连接 DOM 节点和可视化信息从而创    建呈现树的过程，<code>WebKit</code> 使用的术语是“附加”。</p>
<p><strong>所以可以分析出基本过程：</strong></p>
<ol>
<li>HTML解析出DOM Tree</li>
<li>CSS解析出Style Rules</li>
<li>将二者关联生成Render Tree</li>
<li>Layout 根据Render Tree计算每个节点的信息</li>
<li>Painting 根据计算好的信息绘制整个页面</li>
</ol>
<h4 id="2-2-HTML-解析"><a href="#2-2-HTML-解析" class="headerlink" title="2.2 HTML 解析"></a>2.2 HTML 解析</h4><p><code>HTML Parser</code>的任务是将HTML标记解析成<code>DOM Tree</code><br>这个解析可以参考React解析DOM的过程，但是这里面有很多别的规则和操作，比如容错机制，识别<code>&lt;/br&gt;</code>和<code>&lt;br&gt;</code>等等。<br>感兴趣的可以参考 <a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">《How Browser Work》</a>，<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">中文翻译</a><br>举个例子：一段HTML</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>经过解析之后的DOM Tree差不多就是</p>
<p><img data-src="pic3.png"></p>
<p>将文本的HTML文档，提炼出关键信息，嵌套层级的树形结构，便于计算拓展。这就是HTML Parser的作用。</p>
<h4 id="2-3-CSS解析"><a href="#2-3-CSS解析" class="headerlink" title="2.3 CSS解析"></a>2.3 CSS解析</h4><p><code>CSS Parser</code>将CSS解析成<code>Style Rules</code>，<code>Style Rules</code>也叫<code>CSSOM（CSS Object Model）</code>。<br><code>StyleRules</code>也是一个树形结构，根据CSS文件整理出来的类似<code>DOM Tree</code>的树形结构：</p>
<p><img data-src="pic4.png"></p>
<p>与<code>HTML Parser</code>相似，<code>CSS Parser</code>作用就是将很多个CSS文件中的样式合并解析出具有树形结构Style Rules。</p>
<h4 id="2-4-脚本处理"><a href="#2-4-脚本处理" class="headerlink" title="2.4 脚本处理"></a>2.4 脚本处理</h4><p>浏览器解析文档，当遇到<code>&lt;script&gt;</code>标签的时候，会立即解析脚本，停止解析文档（因为JS可能会改动DOM和CSS，所以继续解析会造成浪费）。<br>如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在script标签上增加属性 <code>defer</code>或者<code>async</code>。<br>脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到<code>DOM Tree</code>和<code>Style Rules</code>上。</p>
<h4 id="2-5-呈现树（Render-Tree）"><a href="#2-5-呈现树（Render-Tree）" class="headerlink" title="2.5 呈现树（Render Tree）"></a>2.5 呈现树（Render Tree）</h4><p><code>Render Tree</code>的构建其实就是<code>DOM Tree</code>和<code>CSSOM</code> <strong>Attach</strong>的过程。</p>
<p>呈现树是和 DOM 元素相对应的，但并非一一对应。Render Tree实际上就是一个计算好样式，与HTML对应的（包括哪些显示，那些不显示）的Tree。</p>
<blockquote>
<p>在 WebKit 中，解析样式和创建呈现树的过程称为“附加”。每个 DOM 节点都有一个<code>“attach”</code>方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点<code>“attach”</code>方法。</p>
</blockquote>
<p><img data-src="pic5.png"></p>
<h4 id="2-6-样式计算"><a href="#2-6-样式计算" class="headerlink" title="2.6 样式计算"></a>2.6 样式计算</h4><p>样式计算是个很复杂的问题。DOM中的一个元素可以对应样式表中的多个元素。样式表包括了所有样式：浏览器默认样式表，自定义样式表，inline样式元素，<strong>HTML可视化属性如：width=100。后者将转化以匹配CSS样式。</strong></p>
<blockquote>
<p>WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：</p>
<ol>
<li>这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）</li>
<li>任何元素都没有 ID</li>
<li>标记名称应匹配</li>
<li>类属性应匹配</li>
<li>映射属性的集合必须是完全相同的</li>
<li>链接状态必须匹配</li>
<li>焦点状态必须匹配</li>
<li>任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配</li>
<li>元素中不能有任何 inline 样式属性</li>
<li>不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。</li>
</ol>
</blockquote>
<p>为了简化样式计算，Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。</p>
<p><img data-src="pic6.png"></p>
<p>样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。<br>例如，<strong>如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位</strong>。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。<br>所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。</p>
<p>*<strong>举个例子</strong> 一段HTML代码：*</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=&quot;<span class="symbol">err</span>&quot; <span class="symbol">id</span>=&quot;<span class="symbol">div1</span>&quot;&gt;</span><br><span class="line">      &lt;<span class="symbol">p</span>&gt;</span><br><span class="line">        <span class="symbol">this</span> <span class="symbol">is</span> <span class="symbol">a</span> &lt;<span class="symbol">span</span> <span class="symbol">class</span>=&quot;<span class="symbol">big</span>&quot;&gt; <span class="symbol">big</span> <span class="symbol">error</span> &lt;/<span class="symbol">span</span>&gt;</span><br><span class="line">        <span class="symbol">this</span> <span class="symbol">is</span> <span class="symbol">also</span> <span class="symbol">a</span></span><br><span class="line">        &lt;<span class="symbol">span</span> <span class="symbol">class</span>=&quot;<span class="symbol">big</span>&quot;&gt; <span class="symbol">very</span>  <span class="symbol">big</span>  <span class="symbol">error</span>&lt;/<span class="symbol">span</span>&gt; <span class="symbol">error</span></span><br><span class="line">      &lt;/<span class="symbol">p</span>&gt;</span><br><span class="line">    &lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">div</span> <span class="symbol">class</span>=&quot;<span class="symbol">err</span>&quot; <span class="symbol">id</span>=&quot;<span class="symbol">div2</span>&quot;&gt;<span class="symbol">another</span> <span class="symbol">error</span>&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">  &lt;/<span class="symbol">body</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">html</span>&gt;</span><br></pre></td></tr></table></figure>

<p>对应CSS规则如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">1. <span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>;<span class="attribute">color</span>:black&#125;</span><br><span class="line">2. <span class="selector-class">.err</span> &#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line">3. <span class="selector-class">.big</span> &#123;<span class="attribute">margin-top</span>:<span class="number">3px</span>&#125;</span><br><span class="line">4. <span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">4px</span>&#125;</span><br><span class="line">5. <span class="selector-id">#div1</span> &#123;<span class="attribute">color</span>:blue&#125;</span><br><span class="line">6. <span class="selector-id">#div2</span> &#123;<span class="attribute">color</span>:green&#125;</span><br></pre></td></tr></table></figure>

<p>则CSS形成的规则树如下图所示（节点的标记方式为“节点名 : 指向的规则序号”）</p>
<p><img data-src="pic7.png"></p>
<blockquote>
<p>下面的内容有点绕，但是很有逻辑</p>
</blockquote>
<p>假设我们解析 HTML 时遇到了第二个 <code>&lt;div&gt;</code> 标记，我们需要为此节点创建样式上下文，并填充其样式结构。<br>经过规则匹配，我们发现该 <code>&lt;div&gt;</code>的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。<br>我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。</p>
<p>现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (F) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 B 节点）上找到该结构。</p>
<p>我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 <code>RGB</code> 等）并在此节点上缓存经过计算的结构。</p>
<p>第二个<code>&lt;span&gt;</code>元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。</p>
<p>对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）<br>所以生成的上下文树如下：</p>
<p><img data-src="pic8.png"></p>
<h4 id="2-7-以正确的层叠顺序应用规则"><a href="#2-7-以正确的层叠顺序应用规则" class="headerlink" title="2.7 以正确的层叠顺序应用规则"></a>2.7 以正确的层叠顺序应用规则</h4><p>样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。<br>如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。</p>
<p>一些例子：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="comment">*             &#123;&#125;  /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span></span><br><span class="line"><span class="keyword">li</span>            &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span></span><br><span class="line"><span class="keyword">li</span>:first-<span class="keyword">line</span> &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></span><br><span class="line">ul <span class="keyword">li</span>         &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></span><br><span class="line">ul ol+<span class="keyword">li</span>      &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span></span><br><span class="line">h1 + *[rel=up]&#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span></span><br><span class="line">ul ol <span class="keyword">li</span>.red  &#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span></span><br><span class="line"><span class="keyword">li</span>.red.level  &#123;&#125;  <span class="comment">/* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span></span><br><span class="line">#x34y         &#123;&#125;  <span class="comment">/* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span></span><br><span class="line">style=<span class="string">&quot;&quot;</span>          <span class="comment">/* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span></span><br></pre></td></tr></table></figure>

<p>利用上面的方法，基本可以快速确定不同选择器的优先级。</p>
<h4 id="2-8-布局Layout"><a href="#2-8-布局Layout" class="headerlink" title="2.8 布局Layout"></a>2.8 布局Layout</h4><p>创建渲染树后，下一步就是<code>布局（Layout）</code>,或者叫<code>回流（reflow,relayout）</code>，这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为<code>回流</code>，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。</p>
<p><strong>对渲染树的布局可以分为全局和局部的</strong></p>
<ul>
<li>全局即对整个渲染树进行重新布局，如<u>当我们改变了窗口尺寸或方向</u>或者是<u>修改了根元素的尺寸或者字体大小</u>等；</li>
<li>而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。</li>
</ul>
<p>大多数web应用对DOM的操作都是比较频繁，这意味着经常需要对DOM进行布局和回流，而如果仅仅是一些小改变，就触发整个渲染树的回流，这显然是不好的，为了避免这种情况，浏览器使用了<code>脏位系统</code>，只有一个渲染对象改变了或者某渲染对象及其子渲染对象脏位值为”dirty”时，说明需要回流。</p>
<blockquote>
<p>表示需要布局的脏位值有两种：</p>
<ul>
<li>“dirty”–自身改变，需要回流</li>
<li>“children are dirty”–子节点改变，需要回流</li>
</ul>
</blockquote>
<p>布局是一个从上到下，从外到内进行的递归过程，从根渲染对象，即对应着HTML文档根元素，然后下一级渲染对象，如对应着元素，如此层层递归，依次计算每一个渲染对象的几何信息（位置和尺寸）。</p>
<p><strong>每一个渲染对象的布局流程基本如：</strong></p>
<ol>
<li><p>计算渲染对象的宽度（width）；</p>
</li>
<li><p>遍历此渲染对象的所有子级，依次：</p>
<p>2.1设置子级渲染对象的坐标</p>
<p>2.2判断是否需要触发子渲染对象的布局或回流方法，计算子渲染对象的高度（height）</p>
</li>
<li><p>设置此渲染对象的高度：根据子渲染对象的累积高，margin和padding的高度设置其高度；</p>
</li>
<li><p>设置此渲染对象脏位值为false。</p>
</li>
</ol>
<h4 id="2-9-绘制（Painting）"><a href="#2-9-绘制（Painting）" class="headerlink" title="2.9 绘制（Painting）"></a>2.9 绘制（Painting）</h4><p>在绘制阶段，系统会遍历呈现树，并调用呈现器的<code>“paint”</code>方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。</p>
<p>CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：</p>
<ol>
<li>背景颜色</li>
<li>背景图片</li>
<li>边框</li>
<li>子代</li>
<li>轮廓</li>
</ol>
<p>这里还要说两个概念，一个是<code>Reflow</code>，另一个是<code>Repaint</code>。这两个不是一回事。<br><strong>Repaint</strong> ——屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。<br><strong>Reflow</strong> 元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是Reflow，或是Layout。（HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫reflow）reflow 会从<code>&lt;html&gt;</code>这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。</p>
<blockquote>
<p>Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的。</p>
</blockquote>
<p> 所以，下面这些动作有很大可能会是成本比较高的。</p>
<ul>
<li>当你增加、删除、修改DOM结点时，会导致Reflow或Repaint</li>
<li>当你移动DOM的位置，或是搞个动画的时候。</li>
<li>当你修改CSS样式的时候。</li>
<li>当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。</li>
<li>当你修改网页的默认字体时。</li>
<li>注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。</li>
</ul>
<p>基本上来说，reflow有如下的几个原因：</p>
<ul>
<li>Initial。网页初始化的时候。</li>
<li>Incremental。一些Javascript在操作DOM Tree时。</li>
<li>Resize。其些元件的尺寸变了。</li>
<li>StyleChange。如果CSS的属性发生变化了。</li>
<li>Dirty。几个Incremental的reflow发生在同一个frame的子树上。</li>
</ul>
<p>看几个例子：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>); <span class="regexp">//</span> repaint</span><br><span class="line">$(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;margin&#x27;</span>, <span class="string">&#x27;2px&#x27;</span>); <span class="regexp">//</span> reflow, repaint</span><br><span class="line"></span><br><span class="line">var bstyle = document.body.style; <span class="regexp">//</span> cache</span><br><span class="line"></span><br><span class="line">bstyle.padding = <span class="string">&quot;20px&quot;</span>; <span class="regexp">//</span> reflow, repaint</span><br><span class="line">bstyle.border = <span class="string">&quot;10px solid red&quot;</span>; <span class="regexp">//</span>  再一次的 reflow 和 repaint</span><br><span class="line"></span><br><span class="line">bstyle.color = <span class="string">&quot;blue&quot;</span>; <span class="regexp">//</span> repaint</span><br><span class="line">bstyle.backgroundColor = <span class="string">&quot;#fad&quot;</span>; <span class="regexp">//</span> repaint</span><br><span class="line"></span><br><span class="line">bstyle.fontSize = <span class="string">&quot;2em&quot;</span>; <span class="regexp">//</span> reflow, repaint</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> new DOM element - reflow, repaint</span><br><span class="line">document.body.appendChild(document.createTextNode(<span class="string">&#x27;dude!&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就reflow或repaint一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。</p>
<p>但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些DOM值：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">offsetTop, offsetLeft, offsetWidth, offsetHeight</span><br><span class="line">scrollTop<span class="regexp">/Left/</span>Width/Height</span><br><span class="line">clientTop<span class="regexp">/Left/</span>Width/Height</span><br><span class="line">IE中的 getComputedStyle(), 或 currentStyle</span><br></pre></td></tr></table></figure>

<p>因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样一样会flush出去一些样式的改变，从而造成频繁的reflow/repaint。</p>
<h4 id="2-10-Chrome调试工具查看页面渲染顺序"><a href="#2-10-Chrome调试工具查看页面渲染顺序" class="headerlink" title="2.10 Chrome调试工具查看页面渲染顺序"></a>2.10 Chrome调试工具查看页面渲染顺序</h4><p>页面的渲染详细过程可以通过chrome开发者工具中的timeline查看</p>
<p><img data-src="pic9.png"></p>
<ol>
<li>发起请求；</li>
<li>解析HTML；</li>
<li>解析样式；</li>
<li>执行JavaScript；</li>
<li>布局；</li>
<li>绘制</li>
</ol>
<h2 id="二、页面渲染优化"><a href="#二、页面渲染优化" class="headerlink" title="二、页面渲染优化"></a>二、页面渲染优化</h2><p>浏览器对上文介绍的关键渲染路径进行了很多优化，针对每一次变化产生尽量少的操作，还有优化判断重新绘制或布局的方式等等。<br>在改变文档根元素的字体颜色等视觉性信息时，会触发整个文档的重绘，而改变某元素的字体颜色则只触发特定元素的重绘；改变元素的位置信息会同时触发此元素（可能还包括其兄弟元素或子级元素）的布局和重绘。某些重大改变，如更改文档根元素的字体尺寸，则会触发整个文档的重新布局和重绘，据此及上文所述，推荐以下优化和实践：</p>
<ol>
<li>HTML文档结构层次尽量少，最好不深于六层；</li>
<li>脚本尽量后放，放最后即可；</li>
<li>少量首屏样式内联放在标签内；</li>
<li>样式结构层次尽量简单；</li>
<li>在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发<code>回流</code>；</li>
<li>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</li>
<li>动画尽量使用在绝对定位或固定定位的元素上；</li>
<li>隐藏在屏幕外，或在页面滚动时，尽量停止动画；</li>
<li>尽量缓存DOM查找，查找器尽量简洁；</li>
<li>涉及多域名的网站，可以开启域名预解析</li>
</ol>
<p><strong>补充</strong></p>
<p>HTML整个解析过程看起来很简单，但是我们要知道解析过程中css、Js和DOM的加载顺序。我们都知道HTML是自上往下解析的，在解析过程中：</p>
<p>1、如果遇到link和style，那就就会去下载这些外部的css资源，但是css跟DOM的构建是并行的，就是说不会阻塞DOM树的构建。</p>
<p>2、如果遇到script，那么页面就会把控制权交给JavaScript，直到脚本加载完毕或者是执行完毕。</p>
<p>3、页面的渲染是依靠render树，也就是说如果css没有加载完成，页面也不会渲染显示。</p>
<p>4、JavaScript执行过程中有可能需要改变样式，所以css加载也会阻塞JavaScript的加载。</p>
<p>5、JavaScript执行过程中如果操作DOM，但是DOM树又是在JavaScript之后才能构建，就会报错，找不到节点。</p>
<p>这就是HTML的渲染过程，因为DOM和css并行构建，我们会把css用外部引入，可以更快的构建DOM，因为JavaScript会阻塞DOM和css构建，且操作DOM一定要在DOM构建完成，我们选择把script放在最下面。如果我们过多的在render渲染完成后改变render，那么重排和重绘就会一直被动重发执行，这也会造成渲染速度变慢。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浏览器渲染问题每一步都涉及到很多底层知识，每一步都有对应的算法。<br>文章中间很多语句都是直接复制的原文，自己的语言概况还是不及原文精彩。</p>
<p><strong>可参考原文链接</strong></p>
<p><a href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">《How Browser Work》</a></p>
<p><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p>
<p><a href="http://imweb.io/topic/56841c864c44bcc56092e3fa">浏览器渲染原理</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/25279069">浏览器 渲染,绘制流程及性能优化</a></p>
<p><a href="http://caibaojian.com/css-reflow-repaint.html">优化CSS重排重绘与浏览器性能</a></p>
<p><a href="http://web.jobbole.com/90961/">浅析前端页面渲染机制</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Next-Supplement</title>
    <url>/2020/08/20/Hexo-Next-Supplement/</url>
    <content><![CDATA[<h1 id="Hexo后续补充"><a href="#Hexo后续补充" class="headerlink" title="Hexo后续补充"></a>Hexo后续补充</h1><blockquote>
<p>本篇对 <a href="https://hammerzer.github.io/2020/08/18/The%20Starting%20Point%20of%20Blogs/">The-Starting-Point-of-Blogs</a> 进行一些补充</p>
</blockquote>
<a id="more"></a>

<h2 id="一、推送处理"><a href="#一、推送处理" class="headerlink" title="一、推送处理"></a>一、推送处理</h2><h3 id="1-静态资源压缩"><a href="#1-静态资源压缩" class="headerlink" title="1. 静态资源压缩"></a>1. 静态资源压缩</h3><blockquote>
<p>存在问题未解决</p>
</blockquote>
<p>在站点目录下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ npm install gulp -g</span><br></pre></td></tr></table></figure>

<p>安装gulp插件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install gulp-minify-css --save</span><br><span class="line">npm install gulp-uglify --save</span><br><span class="line">npm install gulp-htmlmin --save</span><br><span class="line">npm install gulp-htmlclean --save</span><br><span class="line">npm install gulp-imagemin --save</span><br></pre></td></tr></table></figure>

<p>在 <code>Hexo</code> 站点下添加 <code>gulpfile.js</code>文件，文件内容如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">var gulp = require(&#x27;gulp&#x27;);</span><br><span class="line">var minifycss = require(&#x27;gulp-minify-css&#x27;);</span><br><span class="line">var uglify = require(&#x27;gulp-uglify&#x27;);</span><br><span class="line">var htmlmin = require(&#x27;gulp-htmlmin&#x27;);</span><br><span class="line">var htmlclean = require(&#x27;gulp-htmlclean&#x27;);</span><br><span class="line">var imagemin = require(&#x27;gulp-imagemin&#x27;);</span><br><span class="line">// 压缩css文件</span><br><span class="line">gulp.task(&#x27;minify-css&#x27;, function() &#123;</span><br><span class="line">  return gulp.src(&#x27;./public/**/*.css&#x27;)</span><br><span class="line">  .pipe(minifycss())</span><br><span class="line">  .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩html文件</span><br><span class="line">gulp.task(&#x27;minify-html&#x27;, function() &#123;</span><br><span class="line">  return gulp.src(&#x27;./public/**/*.html&#x27;)</span><br><span class="line">  .pipe(htmlclean())</span><br><span class="line">  .pipe(htmlmin(&#123;</span><br><span class="line">    removeComments: true,</span><br><span class="line">    minifyJS: true,</span><br><span class="line">    minifyCSS: true,</span><br><span class="line">    minifyURLs: true,</span><br><span class="line">  &#125;))</span><br><span class="line">  .pipe(gulp.dest(&#x27;./public&#x27;))</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩js文件</span><br><span class="line">gulp.task(&#x27;minify-js&#x27;, function() &#123;</span><br><span class="line">    return gulp.src([&#x27;./public/**/.js&#x27;,&#x27;!./public/js/**/*min.js&#x27;])</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩 public/demo 目录内图片</span><br><span class="line">gulp.task(&#x27;minify-images&#x27;, function() &#123;</span><br><span class="line">    gulp.src(&#x27;./public/demo/**/*.*&#x27;)</span><br><span class="line">        .pipe(imagemin(&#123;</span><br><span class="line">           optimizationLevel: 5, //类型：Number  默认：3  取值范围：0-7（优化等级）</span><br><span class="line">           progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片</span><br><span class="line">           interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br><span class="line">           multipass: false, //类型：Boolean 默认：false 多次优化svg直到完全优化</span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(&#x27;./public/uploads&#x27;));</span><br><span class="line">&#125;);</span><br><span class="line">// 默认任务</span><br><span class="line">gulp.task(&#x27;default&#x27;, [</span><br><span class="line">  &#x27;minify-html&#x27;,&#x27;minify-css&#x27;,&#x27;minify-js&#x27;,&#x27;minify-images&#x27;</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<p>只需要每次在执行 <code>generate</code> 命令后执行 <code>gulp</code> 就可以实现对静态资源的压缩，压缩完成后执行 <code>deploy</code> 命令同步到服务器：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">gulp</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Tip</code>   可以把上面的三条命令编写进package.json的script，就可一键三连啦！</p>
</blockquote>
<h3 id="2-本地站点推送到GitHub上"><a href="#2-本地站点推送到GitHub上" class="headerlink" title="2. 本地站点推送到GitHub上"></a>2. 本地站点推送到GitHub上</h3><p>在站点更目录下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>在 <code>Hexo</code> 站点的 <code>_config.yml</code> 中配置 <code>deploy</code>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #your github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">$ hexo clean</span><br><span class="line">$ hexo d --g</span><br></pre></td></tr></table></figure>

<p>hexo g # 生成本地 public 静态文件, hexo d # 部署到 Github 上, 也可以缩写成：hexo g –d 。</p>
<h4 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h4 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h4><figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h4 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h4 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h4><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo deploy</span><br></pre></td></tr></table></figure>

<h2 id="二、站点功能"><a href="#二、站点功能" class="headerlink" title="二、站点功能"></a>二、站点功能</h2><h3 id="1-文章加密访问"><a href="#1-文章加密访问" class="headerlink" title="1. 文章加密访问"></a>1. 文章加密访问</h3><p>打开 <code>themes/next/layout/_partials/head.swig</code>文件,在 <code>&#123;% if theme.pace %&#125;` 标签下的 `&#123;% endif %&#125;</code> 之前插入代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    (function()&#123;</span><br><span class="line">        if(&#x27;&#123;&#123; page.password &#125;&#125;&#x27;)&#123;</span><br><span class="line">            if (prompt(&#x27;请输入文章密码&#x27;) !== &#x27;&#123;&#123; page.password &#125;&#125;&#x27;)&#123;</span><br><span class="line">                alert(&#x27;密码错误&#x27;);</span><br><span class="line">                history.back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在文章上应用：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 2017观看影视</span><br><span class="line">date: 2017-09-25 16:10:03</span><br><span class="line">type:</span><br><span class="line">top:</span><br><span class="line">comments:</span><br><span class="line">categories: [影音, 影视]</span><br><span class="line">tags: [影音, 电影, 电视剧, 动画]</span><br><span class="line">password: 123456</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="2-添加热度"><a href="#2-添加热度" class="headerlink" title="2. 添加热度"></a>2. 添加热度</h3><ul>
<li><p>进入<a href="https://links.jianshu.com/go?to=https://leancloud.cn/">LeanCloud官网</a>，进行账号注册。登录后，进入控制台，创建应用，应用名为<code>Hexo</code></p>
</li>
<li><p>创建应用后，点击存储，创建<strong>Class</strong>，<strong>Class</strong>命名为<strong>Counter</strong>，并限制写入</p>
</li>
<li><p>查看<strong>AppID</strong>和<strong>AppKey</strong></p>
</li>
<li><p>打开<code>Blog/themes/next/layout/_macro/post.swig</code>，<code>command+F</code>搜索<code>leancloud-visitors-count</code>，在图片位置加入<code>&lt;span&gt;℃&lt;/span&gt;</code></p>
<p><img data-src="pic1.png"></p>
</li>
<li><p>编辑主题配置文件，<code>command+f</code>搜索<code>leancloud_visitors</code>，将其值设为：<code>ture</code>，将<strong>AppID</strong>和<strong>AppKey</strong>粘贴到相应位置：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class="line">leancloud_visitors:</span><br><span class="line">  <span class="built_in">enable</span>: ture</span><br><span class="line">  app_id: app_id</span><br><span class="line">  app_key: app_key</span><br></pre></td></tr></table></figure>

<h3 id="3-添加免登陆评论系统"><a href="#3-添加免登陆评论系统" class="headerlink" title="3. 添加免登陆评论系统"></a>3. 添加免登陆评论系统</h3><blockquote>
<p>参考自该<a href="https://blog.csdn.net/jiunian_2761/article/details/97388997">博文</a></p>
</blockquote>
<h4 id="3-1-为什么选择Valine"><a href="#3-1-为什么选择Valine" class="headerlink" title="3.1 为什么选择Valine"></a>3.1 为什么选择Valine</h4><p>在笔者进行评论系统选择时，我觉得我的需求就是方便，简洁，最重要一点是要支持<code>Markdown</code> ，对比之下，最终选定了这款Valine，当然，如果你不喜欢这样简洁的，可以参考 <a href="https://www.zhihu.com/question/267598518">Hexo（NexT 主题）评论系统哪个好？</a></p>
<h4 id="3-2-第一步，注册LeanClound-获取APP-ID-和-APP-Key"><a href="#3-2-第一步，注册LeanClound-获取APP-ID-和-APP-Key" class="headerlink" title="3.2  第一步，注册LeanClound,获取APP ID 和 APP Key"></a>3.2  第一步，注册LeanClound,获取APP ID 和 APP Key</h4><ul>
<li><p>Valine 是基于 <a href="https://leancloud.cn/">LeanCloud</a> 作为数据存储的，所以需要注册一个账号</p>
</li>
<li><p>注册完成后，我们找到<code>创建``应用</code></p>
<p><img data-src="pic2.png"></p>
</li>
<li><p>在这里填写你的应用名称,名称可以自己定义，然后下面选择<code>开发版</code> 点击<code>创建</code></p>
</li>
<li><p>然后点击应用进入设置，在设置页，我们首先点击存储，查看是否有<code>Comment</code>和 <code>Counter</code>，没有则创建，权限设为无限制。</p>
<p><img data-src="pic3.png"></p>
<p><img data-src="pic4.png"></p>
</li>
<li><p>然后点击设置 &gt; 安全中心 ,将除了数据存储的服务全部关闭</p>
</li>
<li><p>最后点击应用 Key 取得我们 <code>AppKey</code> 和 <code>App id</code></p>
</li>
</ul>
<h4 id="3-3-在Hexo-Next主题中配置"><a href="#3-3-在Hexo-Next主题中配置" class="headerlink" title="3.3. 在Hexo Next主题中配置"></a>3.3. 在Hexo Next主题中配置</h4><ul>
<li><p>首先打开 <a href="https://www.jsdelivr.com/package/npm/valine">https://www.jsdelivr.com/package/npm/valine</a> 获取最新的 valine.min.js 的cdn地址</p>
</li>
<li><p>然后我们修改主题配置文件，配置CDN：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># valine  </span></span><br><span class="line"><span class="meta"># See: https://github.com/xCss/Valine  </span></span><br><span class="line"><span class="meta"># Example:  </span></span><br><span class="line"><span class="meta"># valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js  </span></span><br><span class="line"><span class="meta"># valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.4/Valine.min.js  valine: https://cdn.jsdelivr.net/npm/valine@1.3.9/dist/Valine.min.js</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再打开配置Valine功能：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine </span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn </span></span><br><span class="line"><span class="comment"># More info available at https://valine.js.org </span></span><br><span class="line"><span class="attr">valine:</span> <span class="comment"># 功能开关  </span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version  </span></span><br><span class="line">    <span class="attr">appid:</span>  <span class="comment"># Your leancloud application appid #LeanClound获得的appid  </span></span><br><span class="line">    <span class="attr">appkey:</span>  <span class="comment"># Your leancloud application appkey #LeanClound获得的appkey </span></span><br><span class="line">    <span class="attr">notify:</span> <span class="literal">false</span> <span class="comment"># Mail notifier. See: https://github.com/xCss/Valine/wiki # 邮件提醒  </span></span><br><span class="line">    <span class="attr">verify:</span> <span class="literal">false</span> <span class="comment"># Verification code   </span></span><br><span class="line">    <span class="attr">placeholder:</span> <span class="string">欢迎畅所欲言</span> <span class="comment"># Comment box placeholder  </span></span><br><span class="line">    <span class="attr">avatar:</span> <span class="string">mm</span> <span class="comment"># Gravatar style #默认头像设置  </span></span><br><span class="line">    <span class="attr">guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># Custom comment header  </span></span><br><span class="line">    <span class="attr">pageSize:</span> <span class="number">10</span> <span class="comment"># Pagination size  </span></span><br><span class="line">    <span class="attr">language:</span> <span class="string">zh-cn</span> <span class="comment"># Language, available values: en, zh-cn # 语言，设为zh-cn  # 是否开启当前文章阅读量统计  </span></span><br><span class="line">    <span class="attr">visitor:</span> <span class="literal">false</span> <span class="comment"># leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors&#x27; for counter compatibility. Article reading statistic https://valine.js.org/visitor.html  </span></span><br><span class="line">    <span class="attr">comment_count:</span> <span class="literal">true</span> <span class="comment"># If false, comment count will only be displayed in post page, not in home page </span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="3-4-指定文章（页面）评论功能是否开启"><a href="#3-4-指定文章（页面）评论功能是否开启" class="headerlink" title="3.4 指定文章（页面）评论功能是否开启"></a>3.4 指定文章（页面）评论功能是否开启</h4><p>  在 Hexo 博客中，评论的功能是在所有页面都默认开启的，但是有的时候我们在页面上不需要显示评论功能，例如分类，标记页面我们并不需要评论功能。</p>
<p>  我们可以在 Front-matter 中通过<code>comments</code>属性设置true或false控制该页面或者是文章的评论功能是否打开，如我设置标签页面的评论功能关闭：</p>
  <figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: <span class="number">2019</span><span class="number">-07</span><span class="number">-18</span> <span class="number">15</span>:<span class="number">16</span>:<span class="number">50</span></span><br><span class="line">type: <span class="string">&quot;tags&quot;</span></span><br><span class="line">comments: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-自定义头像"><a href="#3-5-自定义头像" class="headerlink" title="3.5 自定义头像"></a>3.5 自定义头像</h4><blockquote>
<p><a href="https://valine.js.org/avatar.html">valine官方文档</a></p>
</blockquote>
<blockquote>
<p>Valine 目前使用的是<a href="http://cn.gravatar.com/">Gravatar</a> 作为评论列表头像。</p>
<p>请自行登录或注册<a href="http://cn.gravatar.com/">Gravatar</a>，然后修改自己的头像。</p>
<p>评论的时候，留下在<a href="http://cn.gravatar.com/">Gravatar</a>注册时所使用的邮箱即可。</p>
</blockquote>
<p>默认值为:</p>
<p><img data-src="pic5.png"></p>
<h3 id="4-给博客添加网站地图sitemap"><a href="#4-给博客添加网站地图sitemap" class="headerlink" title="4. 给博客添加网站地图sitemap"></a>4. 给博客添加网站地图<code>sitemap</code></h3><blockquote>
<p>未实现</p>
</blockquote>
<blockquote>
<p>搜索引擎每天让蜘蛛在网站爬行来抓取页面，网站地图的作用就是给主动给蜘蛛喂数据</p>
</blockquote>
<p>网站地图位于网站根目录下，有<code>sitemap.html</code>和<code>sitemap.xml</code>两种格式。百度搜索引擎及多数搜索引擎使用html格式，谷歌使用xml格式。两步完成网站地图自动生成功能。</p>
<p>**安装<code>网站地图生成插件**</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install </span>hexo-generator-<span class="keyword">baidu-sitemap </span>--save</span><br></pre></td></tr></table></figure>

<p>重新启动hexo，系统会在<code>public</code>根目录下生成<code>sitemap.xml</code>文件。</p>
<p>具体收录参考<a href="https://www.cnblogs.com/brady-wang/p/8493346.html">此处</a></p>
<h2 id="三、常见问题"><a href="#三、常见问题" class="headerlink" title="三、常见问题"></a>三、常见问题</h2><h3 id="1-hexo开发环境迁移"><a href="#1-hexo开发环境迁移" class="headerlink" title="1. hexo开发环境迁移"></a>1. hexo开发环境迁移</h3><blockquote>
<p>参考自 <a href="https://www.cnblogs.com/study-everyday/p/8902136.html">该博主</a></p>
</blockquote>
<h4 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h4><p>安装 Git 客户端</p>
<p>安装 node JS</p>
<h4 id="1-2-在-github-官网添加新电脑产生的密钥"><a href="#1-2-在-github-官网添加新电脑产生的密钥" class="headerlink" title="1.2 在 github 官网添加新电脑产生的密钥"></a>1.2 在 github 官网添加新电脑产生的密钥</h4><h4 id="1-3-源文件拷贝"><a href="#1-3-源文件拷贝" class="headerlink" title="1.3 源文件拷贝"></a>1.3 源文件拷贝</h4><p>将你原来电脑上个人博客目录下必要文件拷到你的新电脑上（比如F:/Blog目录下），注意无需拷全部，只拷如下几个目录：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">_config.yml</span><br><span class="line"><span class="keyword">package</span>.json </span><br><span class="line">scaffolds/ </span><br><span class="line"><span class="keyword">source</span>/ </span><br><span class="line">themes/</span><br></pre></td></tr></table></figure>

<h4 id="1-4-安装-hexo"><a href="#1-4-安装-hexo" class="headerlink" title="1.4 安装 hexo"></a>1.4 安装 hexo</h4><p>在 cmd 下输入下面指令安装 hexo：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install hexo-<span class="keyword">cli</span> -g</span><br></pre></td></tr></table></figure>

<h4 id="1-5-进入-F-Blog-目录（你拷贝到新电脑的目录），输入下面指令安装相关模块"><a href="#1-5-进入-F-Blog-目录（你拷贝到新电脑的目录），输入下面指令安装相关模块" class="headerlink" title="1.5 进入 F:/Blog 目录（你拷贝到新电脑的目录），输入下面指令安装相关模块"></a>1.5 进入 F:/Blog 目录（你拷贝到新电脑的目录），输入下面指令安装相关模块</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save  // 文章部署到 git 的模块</span></span><br><span class="line">（下面为选择安装）</span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-feed <span class="comment">--save  // 建立 RSS 订阅</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save // 建立站点地图</span></span><br></pre></td></tr></table></figure>

<h4 id="1-6-测试"><a href="#1-6-测试" class="headerlink" title="1.6 测试"></a>1.6 测试</h4><p>这时候使用 <code>hexo s</code> 基本可以看到你新添加的文章了。</p>
<h4 id="1-7-部署发布文章"><a href="#1-7-部署发布文章" class="headerlink" title="1.7 部署发布文章"></a>1.7 部署发布文章</h4><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">hexo clean   <span class="regexp">//</span> 清除缓存 网页正常情况下可以忽略此条命令</span><br><span class="line">hexo g       <span class="regexp">//</span> 生成静态网页</span><br><span class="line">hexo d       <span class="regexp">//</span> 开始部署</span><br></pre></td></tr></table></figure>

<h4 id="1-8-Github-添加-SSH-Keys"><a href="#1-8-Github-添加-SSH-Keys" class="headerlink" title="1.8 Github 添加 SSH Keys"></a><a name="mark-one">1.8 Github 添加 SSH Keys</a></h4><blockquote>
<p>推荐该博主 <a href="https://www.himmy.cn/2019/07/06/github%E6%B7%BB%E5%8A%A0ssh-key/">GitHub添加SSH key</a></p>
</blockquote>
<h5 id="1-8-1-打开Git-Bash命令行窗口"><a href="#1-8-1-打开Git-Bash命令行窗口" class="headerlink" title="1.8.1 打开Git Bash命令行窗口"></a>1.8.1 打开Git Bash命令行窗口</h5><h5 id="1-8-2-检查是否已有SSH"><a href="#1-8-2-检查是否已有SSH" class="headerlink" title="1.8.2 检查是否已有SSH"></a>1.8.2 检查是否已有SSH</h5><p>如果没有，会返回如下信息，继续第三步创建SSH</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">$ cd ~/.ssh</span><br><span class="line">bash: cd: <span class="regexp">/c/U</span>sers<span class="regexp">/Him/</span>.ssh: No such <span class="keyword">file</span> or directory</span><br></pre></td></tr></table></figure>

<p>如果本地已经有创建SSH，会返回如下信息，表示本地已经有创建过SSH了，跳过第三步，直接看第四步</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="variable">$</span> <span class="built_in">ls</span></span><br><span class="line">id_rsa  id_rsa.pub  known_hosts</span><br></pre></td></tr></table></figure>

<h5 id="1-8-3-创建SSH-key"><a href="#1-8-3-创建SSH-key" class="headerlink" title="1.8.3 创建SSH key"></a>1.8.3 创建SSH key</h5><p>最后一个参数替换成你自己的GitHub注册邮箱</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa key <span class="built_in">pair</span>.</span><br></pre></td></tr></table></figure>

<p>接下来会提示你输入生成的key存放的路径，不设置直接回车的话会默认创建在C:/Users/你的用户账号/.ssh文件夹下</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">Enter <span class="keyword">file</span> in which to save the key (<span class="regexp">/c/U</span>sers<span class="regexp">/Him/</span>.ssh/id_rsa):</span><br><span class="line">Created directory <span class="string">&#x27;/c/Users/userpath/.ssh&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>再接下来会提示你输入密码，这个密码是用来每次提交的时候输入确认，可以不设置，直接回车两次</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">Enter</span> <span class="string">passphrase</span> <span class="string">(empty</span> <span class="string">for</span> <span class="literal">no</span> <span class="string">passphrase):</span></span><br><span class="line"><span class="attr">Enter same passphrase again:</span></span><br></pre></td></tr></table></figure>

<p>最后成功后会看到类似如下的输出，表示成功生成SSH key了，可以到C:/Users/你的用户账号/.ssh文件夹下看下</p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">Your identification has been saved in /c/Users/Him/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /c/Users/Him/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:RwvBINgH8CEt2KniltmykeyDsOseUYcwMzehFeyT86s 1225723686<span class="meta">@qq.com</span></span><br><span class="line">The key&#x27;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|<span class="string"> o+%OO+o.        </span>|</span><br><span class="line">|<span class="string">..=+%*+ ..       </span>|</span><br><span class="line">|<span class="string"> ..+o+o.. .      </span>|</span><br><span class="line">|<span class="string">o.  o=.  o .     </span>|</span><br><span class="line">|<span class="string">o oolalala S o      </span>|</span><br><span class="line">|<span class="string"> +.+.. . .       </span>|</span><br><span class="line">|<span class="string">. .o    .        </span>|</span><br><span class="line">|<span class="string">  . .  .         </span>|</span><br><span class="line">|<span class="string">   . E.          </span>|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure>

<h5 id="1-8-4-添加SSH-key到GitHub"><a href="#1-8-4-添加SSH-key到GitHub" class="headerlink" title="1.8.4 添加SSH key到GitHub"></a>1.8.4 添加SSH key到GitHub</h5><p>首先复制.ssh文件夹下id_rsa.pub文件的内容，可以直接用文本编辑器打开复制，也可以用如下命令行复制</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">$ clip &lt; ~<span class="regexp">/.ssh/i</span>d_rsa.pub</span><br></pre></td></tr></table></figure>

<p>然后进入<a href="https://github.com/settings/keys%E8%AE%BE%E7%BD%AE%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E7%99%BB%E5%BD%95%E8%A6%81%E5%85%88%E7%99%BB%E5%BD%95">https://github.com/settings/keys设置，如果没有登录要先登录</a></p>
<p>或者登录后依次点击右上角Settings，然后再点击SSH and GPG keys</p>
<p>输入<code>title</code> 和 <code>key</code></p>
<p>最后点击Add SSH key按钮保存</p>
<h5 id="1-8-5-测试SSH连接"><a href="#1-8-5-测试SSH连接" class="headerlink" title="1.8.5 测试SSH连接"></a>1.8.5 测试SSH连接</h5><p>输入如下命令</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh -T git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure>

<p>会得到如下输出，询问是否确认连接，输入yes回车确认</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">The</span> authenticity of host &#x27;github.com (<span class="number">13.229.188.59</span>)&#x27; can&#x27;t be established.</span><br><span class="line"><span class="attribute">RSA</span> key fingerprint is SHA<span class="number">256</span>:nThbg<span class="number">6</span>kXUpJWGl<span class="number">7</span>mykeyCspRomTxdCARLviKw<span class="number">6</span>E<span class="number">5</span>SY<span class="number">8</span>.</span><br><span class="line"><span class="attribute">Are</span> you sure you want to continue connecting (yes/no)? yes</span><br></pre></td></tr></table></figure>

<p>最后连接成功会看到如下输出</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line"><span class="literal">Warning</span>: Permanently added <span class="symbol">&#x27;github</span>.com,<span class="number">13.229</span>.<span class="number">188.59</span>&#x27; (RSA) <span class="keyword">to</span> the list <span class="keyword">of</span> known hosts.</span><br><span class="line">Hi ghxiaoxiao! You<span class="symbol">&#x27;ve</span> successfully authenticated, but GitHub does <span class="keyword">not</span> provide shell <span class="keyword">access</span>.</span><br></pre></td></tr></table></figure>

<p>迁移完毕over</p>
<h3 id="2-gitee双线部署提高访问速度"><a href="#2-gitee双线部署提高访问速度" class="headerlink" title="2. gitee双线部署提高访问速度"></a>2. gitee双线部署提高访问速度</h3><h4 id="2-1-注册账号"><a href="#2-1-注册账号" class="headerlink" title="2.1 注册账号"></a>2.1 注册账号</h4><h4 id="2-2-创建仓库"><a href="#2-2-创建仓库" class="headerlink" title="2.2 创建仓库"></a>2.2 创建仓库</h4><p>创建一个与你的Gitee控件地址同名的空项目</p>
<blockquote>
<p>比如我的Gitee空间地址为<a href="https://gitee.com/Hammerzer%EF%BC%8C%E9%82%A3%E4%B9%88%E5%88%9B%E5%BB%BA%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%90%8D%E4%B8%BAHammerzer%EF%BC%8C">https://gitee.com/Hammerzer，那么创建的项目名为Hammerzer，</a></p>
<p>可能需要强制修改仓库名</p>
</blockquote>
<p>最终博客部署后的访问地址为<a href="https://hammerzer.gitee.io/">https://hammerzer.gitee.io</a></p>
<blockquote>
<p><strong>注意</strong>：如果创建仓库名称与空间地址不同，则需要访问 如<a href="https://hammerzer.gitee.io/hammer,%E5%90%8C%E6%97%B6%E4%B9%9F%E4%BC%9A%E5%AF%BC%E8%87%B4%60gitee">https://hammerzer.gitee.io/hammer,同时也会导致`gitee</a> page`无法显示css、js</p>
</blockquote>
<h4 id="2-3-修改配置"><a href="#2-3-修改配置" class="headerlink" title="2.3 修改配置"></a>2.3 修改配置</h4><p>复制上一步创建的项目的地址，也就是仓库的<code>SSH地址</code>，类似于<code>git@gitee.com:hhhh/hhhh.git</code></p>
<p>然后在Hexo配置文件_config.yml中找到deploy配置项，添加如下配置</p>
<blockquote>
<p>可多线部署，如下书写（单线部署可不写 <code>github</code>/<code>gitee</code>/<code>coding</code>）</p>
<p>记得冒号后有空格</p>
</blockquote>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: </span><br><span class="line">      <span class="attribute">gitee</span>: git<span class="variable">@gitee</span>.<span class="attribute">hhhcom</span>:/hhh.git</span><br><span class="line">      <span class="attribute">github</span>: </span><br><span class="line">      <span class="attribute">coding</span>:</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>

<h4 id="2-4-添加SSH"><a href="#2-4-添加SSH" class="headerlink" title="2.4 添加SSH"></a>2.4 添加SSH</h4><p>在Gitee添加自己电脑的ssh key，这样每次更新代码到Gitee就不用再输入密码了</p>
<p>获取电脑的SSH可以参考   <a href="#mark-one">常见问题-1-1.8</a></p>
<p>然后在Gitee的设置页面找到安全设置–&gt;SSH公钥，用上一步获取的SSH创建一个新的公钥</p>
<blockquote>
<p>此处插播一条 little tip</p>
<p>上面的实现 <code>markdown</code>  自身链接跳转，下面给出所用代码：</p>
<p><code>&lt;a name=&quot;title&quot;&gt; &lt;/a&gt;</code></p>
<p><code>&lt;a href=&quot;#title&quot;&gt;&lt;/a&gt;</code></p>
</blockquote>
<h4 id="2-5-部署hexo"><a href="#2-5-部署hexo" class="headerlink" title="2.5 部署hexo"></a>2.5 部署hexo</h4><h4 id="2-6-开启Gitee-Pages服务"><a href="#2-6-开启Gitee-Pages服务" class="headerlink" title="2.6 开启Gitee Pages服务"></a>2.6 开启Gitee Pages服务</h4><ul>
<li>在项目主页找到服务，点击后可以看到Gitee Pages</li>
<li>点击跳转Gitee Pages服务页面，点击启动按钮开启服务</li>
<li>gitee pages会提示访问地址，然后就可以在浏览器输入<a href="https://hammerzer.gitee.io访问/">https://hammerzer.gitee.io访问</a></li>
</ul>
<h3 id="3-hexo双线部署在Gitee上出现的问题"><a href="#3-hexo双线部署在Gitee上出现的问题" class="headerlink" title="3. hexo双线部署在Gitee上出现的问题"></a>3. hexo双线部署在Gitee上出现的问题</h3><h4 id="3-1-在移动端出现点击事件失去默认行为"><a href="#3-1-在移动端出现点击事件失去默认行为" class="headerlink" title="3.1 在移动端出现点击事件失去默认行为"></a>3.1 在移动端出现点击事件失去默认行为</h4><blockquote>
<p>移动端区别于web端，有可能会默认阻止a标签默认行为，且在Web浏览器中调试时不会报错。</p>
<p>因此，只要换一种导航方式，即可。代码如下</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> href=<span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;href.length;i++)&#123;</span><br><span class="line">    href[i].ontouchend=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.location.href=<span class="built_in">this</span>.getAttribute(<span class="string">&quot;href&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-解决-gitee-page-无法自动更新"><a href="#3-2-解决-gitee-page-无法自动更新" class="headerlink" title="3.2 解决 gitee page 无法自动更新"></a>3.2 解决 gitee page 无法自动更新</h4><blockquote>
<p>参考简书<a href="https://www.jianshu.com/p/6460df84a099">该博文</a></p>
</blockquote>
<blockquote>
<p>gitee page 只有付费版才能自动更新，免费版只能手动点击 “设置” 中的更新按钮</p>
</blockquote>
<p><strong>自动化解决方案</strong>：使用 puppeteer 操作浏览器进行更新按钮点击</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处安装版本为 1.8.0</span></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">giteeUpdate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        <span class="comment">// 此处可以使用 false 有头模式进行调试, 调试完注释即可</span></span><br><span class="line">          headless: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://gitee.com/login&#x27;</span>);</span><br><span class="line">    <span class="comment">// 1. 选中账号控件</span></span><br><span class="line">    <span class="keyword">let</span> accountElements = <span class="keyword">await</span> page.$x(<span class="string">&#x27;//*[@id=&quot;user_login&quot;]&#x27;</span>) <span class="comment">// 此处使用 xpath 寻找控件，下同</span></span><br><span class="line">    <span class="comment">// 2. 填入账号</span></span><br><span class="line">    <span class="keyword">await</span> accountElements[<span class="number">0</span>].type(<span class="string">&#x27;你的 gitee 账户&#x27;</span>)</span><br><span class="line">    <span class="comment">// 3. 选中密码控件</span></span><br><span class="line">    <span class="keyword">let</span> pwdElements = <span class="keyword">await</span> page.$x(<span class="string">&#x27;//*[@id=&quot;user_password&quot;]&#x27;</span>)</span><br><span class="line">    <span class="comment">// 4. 填入密码</span></span><br><span class="line">    <span class="keyword">await</span> pwdElements[<span class="number">0</span>].type(<span class="string">&#x27;你的 gitee 密码&#x27;</span>)</span><br><span class="line">    <span class="comment">// 5. 点击登录</span></span><br><span class="line">    <span class="keyword">let</span> loginButtons = <span class="keyword">await</span> page.$x(<span class="string">&#x27;//*[@id=&quot;new_user&quot;]/div[2]/div/div/div[4]/input&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> loginButtons[<span class="number">0</span>].click()</span><br><span class="line">    <span class="comment">// 6. 等待登录成功</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">&#x27;你的 gitee page 更新按钮页面&#x27;</span>); <span class="comment">// 比如： https://gitee.com/yang0033/hexo-blog/pages</span></span><br><span class="line">    <span class="comment">// 7.1. 监听步骤 7 中触发的确认弹框，并点击确认</span></span><br><span class="line">    <span class="keyword">await</span> page.on(<span class="string">&#x27;dialog&#x27;</span>, <span class="keyword">async</span> dialog =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;确认更新&#x27;</span>)</span><br><span class="line">        dialog.accept();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 7. 点击更新按钮，并弹出确认弹窗</span></span><br><span class="line">    <span class="keyword">let</span> updateButtons = <span class="keyword">await</span> page.$x(<span class="string">&#x27;//*[@id=&quot;pages-branch&quot;]/div[7]&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> updateButtons[<span class="number">0</span>].click()</span><br><span class="line">    <span class="comment">// 8. 轮询并确认是否更新完毕</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>)</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 8.1 获取更新状态标签</span></span><br><span class="line">            deploying = <span class="keyword">await</span> page.$x(<span class="string">&#x27;//*[@id=&quot;pages_deploying&quot;]&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> (deploying.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;更新中...&#x27;</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">&#x27;更新完毕&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">500</span>);</span><br><span class="line">    <span class="comment">// 10.更新完毕，关闭浏览器</span></span><br><span class="line">    browser.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">giteeUpdate();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尝试未成功，待更新</p>
</blockquote>
<h4 id="3-3-出现跨域请求失败503"><a href="#3-3-出现跨域请求失败503" class="headerlink" title="3.3 出现跨域请求失败503"></a>3.3 出现跨域请求失败503</h4><p>这种情况如果出现，修改网址为https，即可解决</p>
<h3 id="4-继静态压缩glup无果之后的替代"><a href="#4-继静态压缩glup无果之后的替代" class="headerlink" title="4. 继静态压缩glup无果之后的替代"></a>4. 继静态压缩glup无果之后的替代</h3><blockquote>
<p>参考该博主  <a href="https://blog.csdn.net/lewky_liu/article/details/82432003">Hexo瞎折腾系列</a></p>
</blockquote>
<h4 id="4-1-静态压缩的目的和手段"><a href="#4-1-静态压缩的目的和手段" class="headerlink" title="4.1 静态压缩的目的和手段"></a>4.1 静态压缩的目的和手段</h4><p>那么怎么提高hexo这个静态博客的页面加载速度呢？可以从以下的几个方面去入手： </p>
<ul>
<li>将js文件尽可能放置到body的闭合标签之前，因为在加载或者引入js文件时是阻塞式的，如果我们在页面的最开始就引入这些js文件，而这些文件又比较大，会造成页面在渲染时长时间处于白屏状态。</li>
<li>尽量避免去引用访问速度非常低下的cdn或者图片，可以改用访问速度更快的cdn，或者将难以迅速加载的图片保存到自己的站点目录下，以免在加载图片时耗费了大量的时间，最后还加载不出来。</li>
<li>对页面的静态资源进行压缩，包括css、js和html等文件。我们自己添加的css和js文件为了可读性，往往会有很多换行和空格，这些对于浏览器来说并没什么卵用，甚至还会降低渲染页面的速度。至于html文件，由于Markdown转成html的bug，会导致页面存在大量的空白，如果你查看下页面的源代码，就会发现这些大量的空白符，十分难看。这也会造成页面渲染的性能问题。</li>
</ul>
<h4 id="4-2-hexo的压缩静态资源插件"><a href="#4-2-hexo的压缩静态资源插件" class="headerlink" title="4.2 hexo的压缩静态资源插件"></a>4.2 hexo的压缩静态资源插件</h4><p>网上有很多相关的博文，常规的做法是使用<code>gulp</code>来进行压缩，<code>gulp</code>是<code>Node.js</code>下的自动构建工具，通过一列的task执行步骤进行自动流程化处理。</p>
<p>使用这种方法会比较麻烦，每次压缩时还需要输入额外的命令，比较繁琐，个人不是很喜欢，有兴趣的可以去自己了解下<a href="https://segmentfault.com/a/1190000009544924#articleHeader8">相关的东西</a>。这篇教程里很多详细的说明，里边有说到gulp的使用，绝对的精品文章。</p>
<p>这里我选择的是由rozbo大佬开发的<code>hexo-neat</code>压缩插件，配置简单，无需额外命令，你只要使用原本的调试三连或者部署三连就可以自动帮你完成静态资源的压缩！</p>
<h4 id="4-3-如何使用hexo-neat"><a href="#4-3-如何使用hexo-neat" class="headerlink" title="4.3 如何使用hexo-neat"></a>4.3 如何使用hexo-neat</h4><blockquote>
<p><strong>在站点根目录下安装</strong>hexo-neat</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-neat --save1</span><br></pre></td></tr></table></figure>

<h4 id="4-4-为站点配置文件添加相关配置"><a href="#4-4-为站点配置文件添加相关配置" class="headerlink" title="4.4 为站点配置文件添加相关配置"></a>4.4 为站点配置文件添加相关配置</h4><p>下边是我自己站点的相关配置，直接添加到站点配置文件<code>_config.yml</code>的末尾就可以。可以安装自己的需求去自定义配置，不过有些注意事项，可以参考我后文的踩坑记录。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># hexo-neat</span><br><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css  </span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#x27;**/*.min.css&#x27;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &#x27;**/*.min.js&#x27;</span><br><span class="line">    - &#x27;**/jquery.fancybox.pack.js&#x27;</span><br><span class="line">    - &#x27;**/index.js&#x27;  </span><br></pre></td></tr></table></figure>

<h4 id="4-5-hexo-neat插件踩坑记录"><a href="#4-5-hexo-neat插件踩坑记录" class="headerlink" title="4.5 hexo-neat插件踩坑记录"></a>4.5 hexo-neat插件踩坑记录</h4><p>由于在使用hexo-neat插件时，可以在命令窗口中看到各个文件的压缩率，于是我就开始捣鼓跳过哪些文件可以让效率更高。在鼓捣了一段时间之后，记录下使用该插件的一些注意事项，避免日后重蹈覆辙，也希望能对各位看官有所帮助。</p>
<h5 id="4-5-1-跳过压缩文件的正确配置方式"><a href="#4-5-1-跳过压缩文件的正确配置方式" class="headerlink" title="4.5.1 跳过压缩文件的正确配置方式"></a>4.5.1 跳过压缩文件的正确配置方式</h5><p>如果按照官方插件的文档说明来配置<code>exclude</code>，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#x27;**/*.min.css&#x27;1234</span><br></pre></td></tr></table></figure>

<h5 id="4-5-2-压缩html时不要跳过-md文件"><a href="#4-5-2-压缩html时不要跳过-md文件" class="headerlink" title="4.5.2 压缩html时不要跳过.md文件"></a>4.5.2 压缩html时不要跳过<code>.md</code>文件</h5><p><code>.md</code>文件就是我们写文章时的markdown文件，如果跳过压缩<code>.md</code>文件，而你又刚好在文章中使用到了NexT自带的tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。</p>
<p>当初为了找到这个原因花了我两个晚上的时间，简直是夜不能寐。</p>
<h5 id="4-5-3-压缩html时不要跳过-swig文件"><a href="#4-5-3-压缩html时不要跳过-swig文件" class="headerlink" title="4.5.3 压缩html时不要跳过.swig文件"></a>4.5.3 压缩html时不要跳过<code>.swig</code>文件</h5><p><code>.swig</code>文件是模板引擎文件，简单的说hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。</p>
<h3 id="5-使用自定义的CSS样式"><a href="#5-使用自定义的CSS样式" class="headerlink" title="5. 使用自定义的CSS样式"></a>5. 使用自定义的CSS样式</h3><blockquote>
<p>参考 博主 <a href="https://segmentfault.com/a/1190000003846777">该文章</a></p>
</blockquote>
<p>想自定义About页面，需要使用自定义的css样式因为markdown支持html标签，使用自定义的CSS样式还是不错的。</p>
<p>下面总结一下具体的使用过程：</p>
<h4 id="5-1-添加样式支持"><a href="#5-1-添加样式支持" class="headerlink" title="5.1 添加样式支持"></a>5.1 添加样式支持</h4><p>为规范化开发，这里需要添加子集的样式文件。<br>首先，在样式文件的<code>source</code>文件夹下找到<code>css</code>文件夹，打开<code>main.styl</code>文件，在最后添加：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>My Layer</span><br><span class="line"><span class="regexp">//</span>--------------------------------------------------</span><br><span class="line">@import <span class="string">&quot;_my/mycss&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-新建自定义样式"><a href="#5-2-新建自定义样式" class="headerlink" title="5.2 新建自定义样式"></a>5.2 新建自定义样式</h4><p>找到样式文件夹<code>css</code> 新建<code>_my</code>文件夹，在其中新建<code>mycss.styl</code>文件，之后就可以按照stylus的格式自定义样式了。</p>
<h4 id="5-3-解决-gitee-page-更新后css仍然不变"><a href="#5-3-解决-gitee-page-更新后css仍然不变" class="headerlink" title="5.3 解决 gitee page 更新后css仍然不变"></a>5.3 解决 gitee page 更新后css仍然不变</h4><p>强制刷新浏览器 <code>Shift+F5</code>，这么傻的错误我居然还犯</p>
<h3 id="6-插入思维导图"><a href="#6-插入思维导图" class="headerlink" title="6. 插入思维导图"></a>6. 插入思维导图</h3><blockquote>
<p>参考 <a href="https://www.jianshu.com/p/1c4657f33899">简书</a></p>
</blockquote>
<h4 id="6-1-在hexo根目录下安装"><a href="#6-1-在hexo根目录下安装" class="headerlink" title="6.1 在hexo根目录下安装"></a>6.1 在hexo根目录下安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-simple-mindmap</span><br></pre></td></tr></table></figure>

<h4 id="6-2-在Markdown中使用思维导图"><a href="#6-2-在Markdown中使用思维导图" class="headerlink" title="6.2 在Markdown中使用思维导图"></a>6.2 在<code>Markdown</code>中使用思维导图</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% pullquote mindmap mindmap-md %&#125;</span><br><span class="line">- Front End</span><br><span class="line">    - 任何方向</span><br><span class="line">        - 编程语言</span><br><span class="line">            - Java</span><br><span class="line">        - SQL</span><br><span class="line">        - Linux</span><br><span class="line">        - Git</span><br><span class="line">    - 技术</span><br><span class="line">        - Java Web</span><br><span class="line">        - 数据库</span><br><span class="line">        - Docker</span><br><span class="line">        - svn</span><br><span class="line">        - 消息队列(MQ)</span><br><span class="line">        - mycat</span><br><span class="line">        - 大数据</span><br><span class="line">            - Hadoop</span><br><span class="line">            - HBase</span><br><span class="line">    - 内功</span><br><span class="line">        - 计算机基础</span><br><span class="line">            - 计算机网络</span><br><span class="line">            - 计算机操作系统</span><br><span class="line">            - 编译原理</span><br><span class="line">            - 计算机组成原理</span><br><span class="line">        - 数据结构与算法</span><br><span class="line">        - 设计模式</span><br><span class="line">        - 性能优化</span><br><span class="line">        - 架构设计</span><br><span class="line">        - 软件工程</span><br><span class="line">    - 其他</span><br><span class="line">        - 英语</span><br><span class="line">        - 博客</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-4-存在的问题"><a href="#6-4-存在的问题" class="headerlink" title="6.4 存在的问题"></a>6.4 存在的问题</h4><p>搜集资料发现应该就这么操作就可以正确插入思维导图，然而我却遇到了很多问题。</p>
<h5 id="6-4-1-思维导图节点未被渲染"><a href="#6-4-1-思维导图节点未被渲染" class="headerlink" title="6.4.1 思维导图节点未被渲染"></a>6.4.1 思维导图节点未被渲染</h5><p>更新<code>gitee pages</code>服务之后，出现思维导图限制框，但思维导图的节点没有被渲染，仍然是以无序列表形式展现</p>
<p><code>console</code>报错未找到 <code>‘$’</code>，这么说应该是这个插件直接使用了<code>JQuery</code>但未引用</p>
<p><strong>解决办法一</strong>：直接把<code>jquery</code>下载到本地，放在<code>theme/source/js</code>下</p>
<p>然后再Markdown中引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>解决办法二</strong>：使用cdn，使用时应注意应该使用 <code>https</code>传输，否则像<code>chrome</code>会默认阻止连接 <code>jquery cdn</code></p>
<p>例如我是把下面的代码在 <code>themes/next/layout/_partials/head/head.swig</code>中全局引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-插入流程图"><a href="#7-插入流程图" class="headerlink" title="7. 插入流程图"></a>7. 插入流程图</h3><p>安装hexo-filter-flowchart<br><code>npm install --save hexo-filter-flowchart</code></p>
<p>具体的流程图<code>Markdown</code>语法，见<a href="https://hammerzer.gitee.io/2020/08/26/markdown/">另一篇</a></p>
<h3 id="8-插入时序图"><a href="#8-插入时序图" class="headerlink" title="8. 插入时序图"></a>8. 插入时序图</h3><blockquote>
<p><a href="https://www.dazhuanlan.com/2019/12/24/5e0209fc19074/">参考源</a></p>
</blockquote>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p><a href="https://github.com/bubkoo/hexo-filter-sequence">hexo-filter-sequence</a> 插件:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">npm install --<span class="keyword">save</span> hexo-filter-<span class="keyword">sequence</span></span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>站点配置文件 <code>_config.yml</code> 中增加如下配置:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">sequence:</span><br><span class="line">  webfon<span class="variable">t:</span> http<span class="variable">s:</span></span><br><span class="line">  raphae<span class="variable">l:</span> http<span class="variable">s:</span>//cdn.bootcss.<span class="keyword">com</span>/raphael/<span class="number">2.2</span>.<span class="number">7</span>/raphael.<span class="built_in">min</span>.js</span><br><span class="line">  underscore: http<span class="variable">s:</span>//cdn.bootcss.<span class="keyword">com</span>/underscore.js/<span class="number">1.8</span>.<span class="number">3</span>/underscore-<span class="built_in">min</span>.js</span><br><span class="line">  sequence: http<span class="variable">s:</span>//cdn.bootcss.<span class="keyword">com</span>/js-sequence-diagrams/<span class="number">1.0</span>.<span class="number">6</span>/sequence-diagram-<span class="built_in">min</span>.js</span><br><span class="line">  <span class="keyword">cs</span><span class="variable">s:</span> # optional, the url <span class="keyword">for</span> css, such <span class="keyword">as</span> hand drawn theme </span><br><span class="line">  option<span class="variable">s:</span> </span><br><span class="line">    theme: simple</span><br><span class="line">    css_clas<span class="variable">s:</span></span><br></pre></td></tr></table></figure>

<h4 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h4><p>源码修改后才能正常使用，进入插件目录作如下修改：</p>
<figure class="highlight roboconf"><table><tr><td class="code"><pre><span class="line">// index.js</span><br><span class="line">var assign = require(&#x27;deep-assign&#x27;);</span><br><span class="line">var renderer = require(&#x27;./lib/renderer&#x27;);</span><br><span class="line"></span><br><span class="line">hexo.config.sequence = assign(&#123;</span><br><span class="line">  <span class="attribute">webfont</span>: &#x27;https://cdn<span class="variable">.bootcss</span><span class="variable">.com</span>/webfont/1.6.28/webfontloader<span class="variable">.js</span>&#x27;,</span><br><span class="line">  raphael: &#x27;https://cdn<span class="variable">.bootcss</span><span class="variable">.com</span>/raphael/2.2.7/raphael<span class="variable">.min</span><span class="variable">.js</span>&#x27;,</span><br><span class="line">  underscore: &#x27;https://cdn<span class="variable">.bootcss</span><span class="variable">.com</span>/underscore<span class="variable">.js</span>/1.8.3/underscore-min<span class="variable">.js</span>&#x27;,</span><br><span class="line">  sequence: &#x27;https://cdn<span class="variable">.bootcss</span><span class="variable">.com</span>/js-sequence-diagrams/1.0.6/sequence-diagram-min<span class="variable">.js</span>&#x27;,</span><br><span class="line">  css: &#x27;&#x27;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    theme: &#x27;simple&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, hexo<span class="variable">.config</span><span class="variable">.sequence</span>);</span><br><span class="line"></span><br><span class="line"><span class="attribute">hexo.extend.filter.register(&#x27;before_post_render&#x27;, renderer.render, 9);</span></span><br><span class="line"><span class="attribute"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// lib/renderer.js, 25 行</span></span><br><span class="line"><span class="keyword">if</span> (sequences.length) &#123;</span><br><span class="line">      <span class="keyword">var</span> config = <span class="keyword">this</span>.config.sequence;</span><br><span class="line">      <span class="comment">// resources</span></span><br><span class="line">      <span class="keyword">data</span>.content += <span class="string">&#x27;&lt;script src=&quot;&#x27;</span> + config.webfont + <span class="string">&#x27;&quot;&gt;&lt;/script&gt;&#x27;</span>;</span><br><span class="line">      <span class="keyword">data</span>.content += <span class="string">&#x27;&lt;script src=&quot;&#x27;</span> + config.raphael + <span class="string">&#x27;&quot;&gt;&lt;/script&gt;&#x27;</span>;</span><br><span class="line">      <span class="keyword">data</span>.content += <span class="string">&#x27;&lt;script src=&quot;&#x27;</span> + config.underscore + <span class="string">&#x27;&quot;&gt;&lt;/script&gt;&#x27;</span>;</span><br><span class="line">      <span class="keyword">data</span>.content += <span class="string">&#x27;&lt;script src=&quot;&#x27;</span> + config.sequence + <span class="string">&#x27;&quot;&gt;&lt;/script&gt;&#x27;</span>;</span><br><span class="line">      ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-插入mermiad-甘特图"><a href="#9-插入mermiad-甘特图" class="headerlink" title="9. 插入mermiad 甘特图"></a>9. 插入mermiad 甘特图</h3><blockquote>
<p><a href="https://blog.csdn.net/qq_36347375/article/details/90478335">Hexo引入Mermaid流程图和MathJax数学公式</a></p>
<p>参考上面的文章，这是我见过的少有的没有坑的文章，点个👍</p>
</blockquote>
<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>在<code>blog</code>根目录<em>安装mermaid插件</em></p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install </span>hexo-filter-mermaid-<span class="keyword">diagrams </span>--save  *<span class="comment"># 安装mermaid插件*</span></span><br></pre></td></tr></table></figure>

<h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><ul>
<li>修改主题theme中的<code>_config.yml</code> 内的 <code>mermaid</code> 模块为 <code>true</code></li>
<li>其实可以deploy一下看看可行否，不行再继续（我在这一步就可以正确显示）：在根目录下的<code>_config.yml</code>中添加</li>
</ul>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># mermaid chart</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">mermaid:</span> <span class="meta">## mermaid url https:<span class="comment">//github.com/knsv/mermaid</span></span></span><br><span class="line"><span class="symbol">  enable:</span> true  <span class="meta"># default true</span></span><br><span class="line"><span class="symbol">  version:</span> <span class="string">&quot;7.1.2&quot;</span> <span class="meta"># default v7.1.2</span></span><br><span class="line"><span class="symbol">  options:</span>  <span class="meta"># find more api options from https:<span class="comment">//github.com/knsv/mermaid/blob/master/src/mermaidAPI.js</span></span></span><br><span class="line">    <span class="meta">#startOnload: true  <span class="comment">// default true</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>其实可以<code>deploy</code>一下看看可行否，不行再继续：编辑<code>blog/themes/next/layout/_partials/footer.swig</code>，在最后添加如下内容</li>
</ul>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml">&#123;% if theme.mermaid.enable %&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;https://unpkg.com/mermaid@</span></span></span><span class="template-variable">&#123;&#123; <span class="name">theme.mermaid.version</span> &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">/dist/mermaid.min.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    if (window.mermaid) &#123;</span></span><br><span class="line"><span class="xml">      mermaid.initialize(</span><span class="template-variable">&#123;&#123; <span class="name">JSON.stringify</span>(<span class="name">theme.mermaid.options</span>) &#125;&#125;</span><span class="xml">);</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<p><a href="http://www.guide2it.com/post/2019-03-10-1-make-flowcharts-with-mermaid-in-markdown/">多样的Mermaid流程图参考</a></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Tool &amp; Platform</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 常见问题汇总</title>
    <url>/2020/10/19/JS-little-questions/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>对开发过程中常见的与<code>JavaScript</code>相关的问题进行汇总</p>
<p>–  JS全局点击事件</p>
<p>–  在JS中引入外部JS</p>
<p>–  JS中的call、apply、bind方法</p>
<p>–  日期操作汇总</p>
<p>–  奇葩操作</p>
</blockquote>
<a id="more"></a>

<h2 id="一、JS全局点击事件"><a href="#一、JS全局点击事件" class="headerlink" title="一、JS全局点击事件"></a>一、JS全局点击事件</h2><p>在书写提示弹窗的时候，有可能去利用事件冒泡去捕获弹窗外的点击，然后去关闭该弹窗</p>
<blockquote>
<p>写在全局的点击事件</p>
</blockquote>
<p><img data-src="js-ques-1.png"></p>
<blockquote>
<p>弹窗部分代码</p>
</blockquote>
<p><img data-src="js-ques-2.png"></p>
<p>但是，写在全局的点击事件会造成很多麻烦，为后期迭代维护造成障碍。</p>
<p><strong>只需要将点击捕获事件放置到提示弹窗的遮罩层上即可</strong></p>
<p>另外，针对于写在全局的点击事件，也可以用阻止<u>事件冒泡的方式</u>去<strong>补窟窿</strong></p>
<h3 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h3><h4 id="①原生方法阻止事件穿透"><a href="#①原生方法阻止事件穿透" class="headerlink" title="①原生方法阻止事件穿透"></a>①原生方法阻止事件穿透</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div @click=<span class="string">&quot;testout($event)&gt;</span></span><br><span class="line"><span class="string">    &lt;div @click=&quot;</span>testin($event)<span class="string">&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">.......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">testin(event) &#123;</span></span><br><span class="line"><span class="string">    ......</span></span><br><span class="line"><span class="string">    event.stopPropagation();</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h4 id="②-stop修饰符"><a href="#②-stop修饰符" class="headerlink" title="②.stop修饰符"></a>②<code>.stop</code>修饰符</h4><p>下面的例子中，将会先弹出“noclick”,再弹出“dodo”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div v-on:click&#x3D;&quot;dodo&quot;&gt;</span><br><span class="line">        &lt;button v-on:click&#x3D;&quot;doThis&quot;&gt;阻止单击事件继续传播&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            name: &quot;Vue.js&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            doThis: function () &#123;</span><br><span class="line">                alert(&quot;noclick&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            dodo: function () &#123;</span><br><span class="line">                alert(&quot;dodo&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>修改为</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">&quot;dodo&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>阻止单击事件继续传播<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>只弹出“noclick”</p>
<h2 id="二、在JS中引入外部JS"><a href="#二、在JS中引入外部JS" class="headerlink" title="二、在JS中引入外部JS"></a>二、在JS中引入外部JS</h2><p>在js文件中引入（调用）另一个js文件的三种方法</p>
<p><strong>方法一，在调用文件的顶部加入下例代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScript</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&quot;&lt;script language=javascript src=&quot;</span>+url+<span class="string">&quot;&gt;&lt;/script&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：有时你引用的文件还可能需要引用其他的js,我们需要将需要的那个js文件也以同样的方法引用进来。</p>
<p><strong>方法二，在js中写如下代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScript</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.setAttribute(<span class="string">&#x27;type&#x27;</span>,<span class="string">&#x27;text/javascript&#x27;</span>);</span><br><span class="line">    script.setAttribute(<span class="string">&#x27;src&#x27;</span>,url);</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用document.createElement(”script”)生成了一个script的标签，设置其 type属性为text/javascript。</p>
<p><strong>方法三，利用es6中export和import实现模块化</strong></p>
<p>一个js文件代表一个js模块 。ES6引入外部模块分两种情况：</p>
<p><strong>1.导入外部的变量或函数等；</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;firstName, lastName&#125; <span class="keyword">from</span> <span class="string">&#x27;./test&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>2.导入外部的模块，并立即执行</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./test&#x27;</span></span><br><span class="line"><span class="comment">//执行test.js，但不导入任何变量</span></span><br></pre></td></tr></table></figure>

<h2 id="三、JS中的call、apply、bind方法"><a href="#三、JS中的call、apply、bind方法" class="headerlink" title="三、JS中的call、apply、bind方法"></a>三、JS中的call、apply、bind方法</h2><blockquote>
<p>转载自 <a href="https://www.cnblogs.com/moqiutao/p/7371988.html">博客园</a></p>
</blockquote>
<p>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</p>
<h3 id="apply与call"><a href="#apply与call" class="headerlink" title="apply与call"></a>apply与call</h3><p>在 javascript 中，<strong>call 和 apply 都是为了改变某个函数运行时的上下文（context）而存在的</strong>，换句话说，就是为了改变函数体内部 this 的指向。</p>
<p>JavaScript 的一大特点是，函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruits</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">fruits.prototype = &#123;</span><br><span class="line">    color: <span class="string">&quot;red&quot;</span>,</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;My color is &quot;</span> + <span class="built_in">this</span>.color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> fruits;</span><br><span class="line">apple.say();    <span class="comment">//My color is red</span></span><br></pre></td></tr></table></figure>

<p>但是如果我们有一个对象banana= {color : “yellow”} ,我们不想对它重新定义 say 方法，那么我们可以通过 call 或 apply 用 apple 的 say 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">banana = &#123;</span><br><span class="line">    color: <span class="string">&quot;yellow&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">apple.say.call(banana);     <span class="comment">//My color is yellow</span></span><br><span class="line">apple.say.apply(banana);    <span class="comment">//My color is yellow</span></span><br></pre></td></tr></table></figure>

<p>所以，可以看出 call 和 apply 是为了动态改变 this 而出现的，当一个 object 没有某个方法（本栗子中banana没有say方法），但是其他的有（js本栗子中apple有say方法），我们可以借助call或apply用其它对象的方法来操作。</p>
<h3 id="apply与call-区别"><a href="#apply与call-区别" class="headerlink" title="apply与call 区别"></a>apply与call 区别</h3><p>对于 apply、call 二者而言，<strong>作用完全一样，只是接受参数的方式不太一样</strong>。例如，有一个函数定义如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2</span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>就可以通过如下方式来调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">func.call(<span class="built_in">this</span>, arg1, arg2);</span><br><span class="line">func.apply(<span class="built_in">this</span>, [arg1, arg2])</span><br></pre></td></tr></table></figure>

<p>其中 this 是你想指定的上下文，他可以是任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。　　</p>
<h3 id="apply与call-实例"><a href="#apply与call-实例" class="headerlink" title="apply与call 实例"></a>apply与call 实例</h3><h4 id="数组之间追加"><a href="#数组之间追加" class="headerlink" title="数组之间追加"></a>数组之间追加</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array1 = [<span class="number">12</span> , <span class="string">&quot;foo&quot;</span> , &#123;<span class="attr">name</span>:<span class="string">&quot;Joe&quot;</span>&#125; , <span class="number">-2458</span>]; </span><br><span class="line"><span class="keyword">var</span> array2 = [<span class="string">&quot;Doe&quot;</span> , <span class="number">555</span> , <span class="number">100</span>]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// apply：认为此处的第二参数就是 push 的参数列表</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(array1, array2); </span><br><span class="line"><span class="comment">// array1 值为  [12 , &quot;foo&quot; , &#123;name:&quot;Joe&quot;&#125; , -2458 , &quot;Doe&quot; , 555 , 100]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call：认为此处第二个参数就是 push 的第一个参数</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(array1, array2);</span><br><span class="line"><span class="comment">// array1 值为  [12, &quot;foo&quot;, &#123;…&#125;, -2458, Array(3)]</span></span><br></pre></td></tr></table></figure>

<h4 id="获取数组中的最大值和最小值"><a href="#获取数组中的最大值和最小值" class="headerlink" title="获取数组中的最大值和最小值"></a>获取数组中的最大值和最小值</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  numbers = [<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , <span class="number">-215</span> ]; </span><br><span class="line"><span class="keyword">var</span> maxInNumbers = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers),   <span class="comment">//458</span></span><br><span class="line">    maxInNumbers = <span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>,<span class="number">5</span>, <span class="number">458</span> , <span class="number">120</span> , <span class="number">-215</span>); <span class="comment">//458</span></span><br></pre></td></tr></table></figure>

<p>number 本身没有 max 方法，但是 Math 有，我们就可以借助 call 或者 apply 使用其方法。</p>
<h4 id="验证是否是数组（前提是toString-方法没有被重写过）"><a href="#验证是否是数组（前提是toString-方法没有被重写过）" class="headerlink" title="验证是否是数组（前提是toString()方法没有被重写过）"></a>验证是否是数组（前提是toString()方法没有被重写过）</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">functionisArray(obj)&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&#x27;[object Array]&#x27;</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="类（伪）数组使用数组方法"><a href="#类（伪）数组使用数组方法" class="headerlink" title="类（伪）数组使用数组方法"></a>类（伪）数组使用数组方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> domNodes = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;*&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>Javascript中存在一种名为伪数组的对象结构。比较特别的是 <code>arguments 对象</code>，还有像调用 <code>getElementsByTagName</code> , <code>document.childNodes</code> 之类的，它们返回<code>NodeList对象</code>都属于伪数组。不能应用 Array下的 push , pop 等方法。</p>
<p>但是我们能通过 Array.prototype.slice.call 转换为真正的数组的带有 length 属性的对象，这样 domNodes 就可以应用 Array 下的所有方法了。</p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>定义一个 log 方法，让它可以代理 console.log 方法，常见的解决方法是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg</span>)　</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(msg);</span><br><span class="line">&#125;</span><br><span class="line">log(<span class="number">1</span>);    <span class="comment">//1</span></span><br><span class="line">log(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>上面方法可以解决最基本的需求，但是当传入参数的个数是不确定的时候，上面的方法就失效了，这个时候就可以考虑使用 apply 或者 call，注意这里**<code>传入多少个参数是不确定的</code>**，所以使用apply是最好的，方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">log(<span class="number">1</span>);    <span class="comment">//1</span></span><br><span class="line">log(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">//1 2</span></span><br></pre></td></tr></table></figure>

<p> <strong>接下来的要求是给每一个 log 消息添加一个”(app)”的前辍，比如：</strong></p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">log</span>(<span class="string">&quot;hello world&quot;</span>); <span class="comment">//(app)hello world</span></span><br></pre></td></tr></table></figure>

<p>该怎么做比较优雅呢？<strong>这个时候需要想到arguments参数是个伪数组，通过 <code>Array.prototype.slice.call</code> 转化为标准数组，再使用数组方法unshift</strong>，像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">  args.unshift(<span class="string">&#x27;(app)&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>在讨论bind()方法之前我们先来看一道题目：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> altwrite = <span class="built_in">document</span>.write;</span><br><span class="line">altwrite(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>结果：<code>Uncaught TypeError: Illegal invocation</code><br>altwrite()函数改变this的指向global或window对象，导致执行时提示非法调用异常，正确的方案就是使用bind()方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">altwrite.bind(<span class="built_in">document</span>)(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>当然也可以使用call()方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">altwrite.call(<span class="built_in">document</span>, <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="绑定函数"><a href="#绑定函数" class="headerlink" title="绑定函数"></a>绑定函数</h4><p><code>bind()</code>最简单的用法是<strong>创建一个函数，使这个函数不论怎么调用都有同样的this值</strong>。常见的错误就像上面的例子一样，将方法从对象中拿出来，然后调用，并且希望this指向原来的对象。如果不做特殊处理，一般会丢失原来的对象。使用bind()方法能够很漂亮的解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.num = <span class="number">9</span>; </span><br><span class="line"><span class="keyword">var</span> mymodule = &#123;</span><br><span class="line">  num: <span class="number">81</span>,</span><br><span class="line">  getNum: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">mymodule.getNum(); <span class="comment">// 81</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getNum = mymodule.getNum;</span><br><span class="line">getNum(); <span class="comment">// 9, 因为在这个例子中，&quot;this&quot;指向全局对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundGetNum = getNum.bind(mymodule);</span><br><span class="line">boundGetNum(); <span class="comment">// 81</span></span><br></pre></td></tr></table></figure>

<p>bind() 方法与 apply 和 call 很相似，也是可以改变函数体内 this 的指向。</p>
<p><u>MDN的解释是</u>：<strong>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</strong></p>
<p>直接来看看具体如何使用，在常见的单体模式中，通常我们会使用 <code>_this</code> , <code>that</code> , <code>self</code> 等保存 this ，这样我们可以在改变了上下文之后继续引用到它。 像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar : <span class="number">1</span>,</span><br><span class="line">    eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">        $(<span class="string">&#x27;.someClass&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="comment">/* Act on the event */</span></span><br><span class="line">            <span class="built_in">console</span>.log(_this.bar);     <span class="comment">//1</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>Javascript</code> 特有的机制，上下文环境在 <code>eventBind:function()&#123; &#125;</code> 过渡到 <code>$(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) &#123; &#125;)</code> 发生了改变，上述使用变量保存 this 这些方式都是有用的，也没有什么问题。</p>
<p>当然使用 bind() 可以更加优雅的解决这个问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    bar : <span class="number">1</span>,</span><br><span class="line">    eventBind: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        $(<span class="string">&#x27;.someClass&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">            <span class="comment">/* Act on the event */</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.bar);      <span class="comment">//1</span></span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码里，bind() 创建了一个函数，当这个click事件绑定在被调用的时候，它的 this 关键词会被设置成被传入的值（这里指调用bind()时传入的参数）。</p>
<p>因此，这里我们传入想要的上下文 this(其实就是 foo )，到 bind() 函数中。然后，当回调函数被执行的时候， this 便指向 foo 对象。再来一个简单的栗子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    x:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo);</span><br><span class="line">func(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>这里我们创建了一个新的函数 func，当使用 bind() 创建一个绑定函数之后，它被执行的时候，它的 this 会被设置成 foo ， 而不是像我们调用 bar() 时的全局作用域。</p>
<h4 id="偏函数（Partial-Functions）"><a href="#偏函数（Partial-Functions）" class="headerlink" title="偏函数（Partial Functions）"></a>偏函数（Partial Functions）</h4><p><code>bind()</code>的另一个最简单的用法是<span style="color:red;">使一个函数拥有预设的初始参数</span>。<strong>只要将这些参数（如果有的话）作为<code>bind()</code>的参数写在<code>this</code>后面。当绑定函数被调用时，这些参数会被<span style="color:#2948ff;">插入到目标函数的参数列表的开始位置</span>，传递给绑定函数的参数会跟在它们后面。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预定义参数37</span></span><br><span class="line"><span class="keyword">var</span> leadingThirtysevenList = list.bind(<span class="literal">undefined</span>, <span class="number">37</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> list2 = leadingThirtysevenList(); <span class="comment">// [37]</span></span><br><span class="line"><span class="keyword">var</span> list3 = leadingThirtysevenList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [37, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h4 id="和setTimeout一起使用"><a href="#和setTimeout一起使用" class="headerlink" title="和setTimeout一起使用"></a>和setTimeout一起使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bloomer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.petalCount = <span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random() * <span class="number">12</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1秒后调用declare函数</span></span><br><span class="line">Bloomer.prototype.bloom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.setTimeout(<span class="built_in">this</span>.declare.bind(<span class="built_in">this</span>), <span class="number">100</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bloomer.prototype.declare = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我有 &#x27;</span> + <span class="built_in">this</span>.petalCount + <span class="string">&#x27; 朵花瓣!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bloo = <span class="keyword">new</span> Bloomer();</span><br><span class="line">bloo.bloom(); <span class="comment">//我有 5 朵花瓣!</span></span><br></pre></td></tr></table></figure>

<p>注意：对于事件处理函数和setInterval方法也可以使用上面的方法</p>
<h4 id="绑定函数作为构造函数"><a href="#绑定函数作为构造函数" class="headerlink" title="绑定函数作为构造函数"></a>绑定函数作为构造函数</h4><p>绑定函数也适用于使用new操作符来构造目标函数的实例。当使用绑定函数来构造实例，注意：this会被忽略，但是传入的参数仍然可用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.x + <span class="string">&#x27;,&#x27;</span> + <span class="built_in">this</span>.y);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">p.toString(); <span class="comment">// &#x27;1,2&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> emptyObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> YAxisPoint = Point.bind(emptyObj, <span class="number">0</span><span class="comment">/*x*/</span>);</span><br><span class="line"><span class="comment">// 实现中的例子不支持,</span></span><br><span class="line"><span class="comment">// 原生bind支持:</span></span><br><span class="line"><span class="keyword">var</span> YAxisPoint = Point.bind(<span class="literal">null</span>, <span class="number">0</span><span class="comment">/*x*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> axisPoint = <span class="keyword">new</span> YAxisPoint(<span class="number">5</span>);</span><br><span class="line">axisPoint.toString(); <span class="comment">// &#x27;0,5&#x27;</span></span><br><span class="line"></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> Point; <span class="comment">// true</span></span><br><span class="line">axisPoint <span class="keyword">instanceof</span> YAxisPoint; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> Point(<span class="number">17</span>, <span class="number">42</span>) <span class="keyword">instanceof</span> YAxisPoint; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="捷径"><a href="#捷径" class="headerlink" title="捷径"></a>捷径</h4><p>bind()也可以为需要特定this值的函数创造捷径。</p>
<p>例如要将一个类数组对象转换为真正的数组，可能的例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<p>如果使用<code>bind()</code>的话，情况变得更简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> unboundSlice = <span class="built_in">Array</span>.prototype.slice;</span><br><span class="line"><span class="keyword">var</span> slice = <span class="built_in">Function</span>.prototype.call.bind(unboundSlice);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">slice(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure>

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>上面的几个小节可以看出bind()有很多的使用场景，但是bind()函数是在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。这就需要我们自己实现bind()函数了。</p>
<p>首先我们可以通过给目标函数指定作用域来简单实现bind()方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  self = <span class="built_in">this</span>;  <span class="comment">//保存this，即调用bind方法的目标函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> self.apply(context,<span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>考虑到函数柯里化的情况，我们可以构建一个更加健壮的bind()：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">  self = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">      <span class="keyword">return</span> self.apply(context,finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这次的<code>bind()</code>方法可以绑定对象，也支持在绑定的时候传参。</p>
<p>继续，Javascript的函数还可以作为构造函数，那么绑定后的函数用这种方式调用时，情况就比较微妙了，需要涉及到原型链的传递：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">  F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  self = <span class="built_in">this</span>,</span><br><span class="line">  bound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> innerArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">var</span> finalArgs = args.concat(innerArgs);</span><br><span class="line">      <span class="keyword">return</span> self.apply((<span class="built_in">this</span> <span class="keyword">instanceof</span> F ? <span class="built_in">this</span> : context), finalArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  F.prototype = self.prototype;</span><br><span class="line">  bound.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  <span class="keyword">return</span> bound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这是《JavaScript Web Application》一书中对bind()的实现：通过设置一个中转构造函数F，使绑定后的函数与调用bind()的函数处于同一原型链上，用new操作符调用绑定后的函数，返回的对象也能正常使用instanceof，因此这是最严谨的bind()实现。</p>
<p>对于为了在浏览器中能支持bind()函数，只需要对上述函数稍微修改即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">oThis</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// closest thing possible to the ECMAScript 5</span></span><br><span class="line">      <span class="comment">// internal IsCallable function</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Function.prototype.bind - what is trying to be bound is not callable&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> aArgs   = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>),</span><br><span class="line">        fToBind = <span class="built_in">this</span>,</span><br><span class="line">        fNOP    = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fBound  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// this instanceof fBound === true时,说明返回的fBound被当做new的构造函数调用</span></span><br><span class="line">          <span class="keyword">return</span> fToBind.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fBound</span><br><span class="line">                 ? <span class="built_in">this</span></span><br><span class="line">                 : oThis,</span><br><span class="line">                 <span class="comment">// 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的</span></span><br><span class="line">                 aArgs.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 维护原型关系</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.prototype) &#123;</span><br><span class="line">      <span class="comment">// Function.prototype doesn&#x27;t have a prototype property</span></span><br><span class="line">      fNOP.prototype = <span class="built_in">this</span>.prototype; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下行的代码使fBound.prototype是fNOP的实例,因此</span></span><br><span class="line">    <span class="comment">// 返回的fBound若作为new的构造函数,new生成的新对象作为this传入fBound,新对象的__proto__就是fNOP的实例</span></span><br><span class="line">    fBound.prototype = <span class="keyword">new</span> fNOP();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fBound;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有个有趣的问题，如果连续 bind() 两次，亦或者是连续 bind() 三次那么输出的值是什么呢？像这样：</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = function()&#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    x:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sed = &#123;</span><br><span class="line">    x:<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">func</span> = <span class="title">bar</span>.<span class="title">bind</span><span class="params">(foo)</span>.<span class="title">bind</span><span class="params">(sed)</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span>; //?</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> fiv = &#123;</span><br><span class="line">    x:<span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">func</span> = <span class="title">bar</span>.<span class="title">bind</span><span class="params">(foo)</span>.<span class="title">bind</span><span class="params">(sed)</span>.<span class="title">bind</span><span class="params">(fiv)</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span>; //?</span></span><br></pre></td></tr></table></figure>

<p>答案是，两次都仍将输出 3 ，而非期待中的 4 和 5 。原因是，在Javascript中，多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。</p>
<h3 id="apply、call、bind比较"><a href="#apply、call、bind比较" class="headerlink" title="apply、call、bind比较"></a>apply、call、bind比较</h3><p>那么 apply、call、bind 三者相比较，之间又有什么异同呢？何时使用 apply、call，何时使用 bind 呢。简单的一个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">81</span>,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">    getX: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.bind(obj)());  <span class="comment">//81</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.call(obj));    <span class="comment">//81</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.getX.apply(obj));   <span class="comment">//81</span></span><br></pre></td></tr></table></figure>

<p>三个输出的都是81，但是注意看使用 bind() 方法的，他后面多了对括号。</p>
<p>也就是说，区别是：<strong>当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数</strong>。</p>
<p>再总结一下：</p>
<ul>
<li>apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；</li>
<li>apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；</li>
<li>apply 、 call 、bind 三者都可以利用后续参数传参；</li>
<li>bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。</li>
</ul>
<br>

<h2 id="四、日期操作汇总"><a href="#四、日期操作汇总" class="headerlink" title="四、日期操作汇总"></a>四、日期操作汇总</h2><h3 id="日期相关本地函数"><a href="#日期相关本地函数" class="headerlink" title="日期相关本地函数"></a>日期相关本地函数</h3><h4 id="1、生成标准日期格式下的自定义日期格式字符串"><a href="#1、生成标准日期格式下的自定义日期格式字符串" class="headerlink" title="1、生成标准日期格式下的自定义日期格式字符串"></a>1、生成标准日期格式下的自定义日期格式字符串</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatDateTime</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">  <span class="keyword">const</span> y = date.getFullYear();</span><br><span class="line">  <span class="keyword">let</span> MM = date.getMonth() + <span class="number">1</span>;</span><br><span class="line">  MM = MM &lt; <span class="number">10</span> ? (<span class="string">`0<span class="subst">$&#123;MM&#125;</span>`</span>) : MM;</span><br><span class="line">  <span class="keyword">let</span> d = date.getDate();</span><br><span class="line">  d = d &lt; <span class="number">10</span> ? (<span class="string">`0<span class="subst">$&#123;d&#125;</span>`</span>) : d;</span><br><span class="line">  <span class="keyword">let</span> h = date.getHours();</span><br><span class="line">  h = h &lt; <span class="number">10</span> ? (<span class="string">`0<span class="subst">$&#123;h&#125;</span>`</span>) : h;</span><br><span class="line">  <span class="keyword">let</span> m = date.getMinutes();</span><br><span class="line">  m = m &lt; <span class="number">10</span> ? (<span class="string">`0<span class="subst">$&#123;m&#125;</span>`</span>) : m;</span><br><span class="line">  <span class="keyword">let</span> s = date.getSeconds();</span><br><span class="line">  s = s &lt; <span class="number">10</span> ? (<span class="string">`0<span class="subst">$&#123;s&#125;</span>`</span>) : s;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;MM&#125;</span>-<span class="subst">$&#123;d&#125;</span>   <span class="subst">$&#123;h&#125;</span>:<span class="subst">$&#123;m&#125;</span>:<span class="subst">$&#123;s&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用日期数据内置方法"><a href="#常用日期数据内置方法" class="headerlink" title="常用日期数据内置方法"></a>常用日期数据内置方法</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>();        <span class="comment">// 返回标准时间，如：Sat Nov 21 2020 13:04:56 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的三种方法均为获取当前时间戳</span></span><br><span class="line">+<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">Date</span>.now();        <span class="comment">//获取当前时间戳</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().getTime() ;  <span class="comment">// 获取时间戳方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.parse(that.fendDate);      <span class="comment">//YYYY-MM-DD转为毫秒级时间戳</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取整点时间戳</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleDateString()).getTime()))</span><br><span class="line">toLocaleString()     <span class="comment">// 根据本地时间格式，把 Date 对象转换为字符串。 </span></span><br><span class="line">toLocaleTimeString()     <span class="comment">// 根据本地时间格式，把 Date 对象的时间部分转换为字符串。</span></span><br><span class="line">toLocaleDateString()     <span class="comment">// 根据本地时间格式，把 Date 对象的日期部分转换为字符串，如&quot;2020/11/21&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="查询扩展"><a href="#查询扩展" class="headerlink" title="查询扩展"></a>查询扩展</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">getDate() 从 <span class="built_in">Date</span> 对象返回一个月中的某一天 (<span class="number">1</span> ~ <span class="number">31</span>)。 </span><br><span class="line">getDay() 从 <span class="built_in">Date</span> 对象返回一周中的某一天 (<span class="number">0</span> ~ <span class="number">6</span>)。 </span><br><span class="line">getMonth() 从 <span class="built_in">Date</span> 对象返回月份 (<span class="number">0</span> ~ <span class="number">11</span>)。 </span><br><span class="line">getFullYear() 从 <span class="built_in">Date</span> 对象以四位数字返回年份。 </span><br><span class="line">getYear() 请使用 getFullYear() 方法代替。 </span><br><span class="line">getHours() 返回 <span class="built_in">Date</span> 对象的小时 (<span class="number">0</span> ~ <span class="number">23</span>)。 </span><br><span class="line">getMinutes() 返回 <span class="built_in">Date</span> 对象的分钟 (<span class="number">0</span> ~ <span class="number">59</span>)。 </span><br><span class="line">getSeconds() 返回 <span class="built_in">Date</span> 对象的秒数 (<span class="number">0</span> ~ <span class="number">59</span>)。 </span><br><span class="line">getMilliseconds() 返回 <span class="built_in">Date</span> 对象的毫秒(<span class="number">0</span> ~ <span class="number">999</span>)。 </span><br><span class="line"></span><br><span class="line">getTime() 返回 <span class="number">1970</span> 年 <span class="number">1</span> 月 <span class="number">1</span> 日至今的毫秒数。 </span><br><span class="line"></span><br><span class="line">getTimezoneOffset() 返回本地时间与格林威治标准时间 (GMT) 的分钟差。 </span><br><span class="line"></span><br><span class="line">getUTCDate() 根据世界时从 <span class="built_in">Date</span> 对象返回月中的一天 (<span class="number">1</span> ~ <span class="number">31</span>)。 </span><br><span class="line"></span><br><span class="line">getUTCDay() 根据世界时从 <span class="built_in">Date</span> 对象返回周中的一天 (<span class="number">0</span> ~ <span class="number">6</span>)。 </span><br><span class="line"></span><br><span class="line">getUTCMonth() 根据世界时从 <span class="built_in">Date</span> 对象返回月份 (<span class="number">0</span> ~ <span class="number">11</span>)。 </span><br><span class="line"></span><br><span class="line">getUTCFullYear() 根据世界时从 <span class="built_in">Date</span> 对象返回四位数的年份。 </span><br><span class="line"></span><br><span class="line">getUTCHours() 根据世界时返回 <span class="built_in">Date</span> 对象的小时 (<span class="number">0</span> ~ <span class="number">23</span>)。 </span><br><span class="line"></span><br><span class="line">getUTCMinutes() 根据世界时返回 <span class="built_in">Date</span> 对象的分钟 (<span class="number">0</span> ~ <span class="number">59</span>)。 </span><br><span class="line"></span><br><span class="line">getUTCSeconds() 根据世界时返回 <span class="built_in">Date</span> 对象的秒钟 (<span class="number">0</span> ~ <span class="number">59</span>)。 </span><br><span class="line"></span><br><span class="line">getUTCMilliseconds() 根据世界时返回 <span class="built_in">Date</span> 对象的毫秒(<span class="number">0</span> ~ <span class="number">999</span>)。 </span><br><span class="line"></span><br><span class="line">parse() 返回<span class="number">1970</span>年<span class="number">1</span>月<span class="number">1</span>日午夜到指定日期（字符串）的毫秒数。 </span><br><span class="line"></span><br><span class="line"><span class="comment">// setter</span></span><br><span class="line">setDate() 设置 <span class="built_in">Date</span> 对象中月的某一天 (<span class="number">1</span> ~ <span class="number">31</span>)。 </span><br><span class="line">setMonth() 设置 <span class="built_in">Date</span> 对象中月份 (<span class="number">0</span> ~ <span class="number">11</span>)。 </span><br><span class="line">setFullYear() 设置 <span class="built_in">Date</span> 对象中的年份（四位数字）。 </span><br><span class="line">setYear() 请使用 setFullYear() 方法代替。 </span><br><span class="line">setHours() 设置 <span class="built_in">Date</span> 对象中的小时 (<span class="number">0</span> ~ <span class="number">23</span>)。 </span><br><span class="line">setMinutes() 设置 <span class="built_in">Date</span> 对象中的分钟 (<span class="number">0</span> ~ <span class="number">59</span>)。 </span><br><span class="line">setSeconds() 设置 <span class="built_in">Date</span> 对象中的秒钟 (<span class="number">0</span> ~ <span class="number">59</span>)。 </span><br><span class="line">setMilliseconds() 设置 <span class="built_in">Date</span> 对象中的毫秒 (<span class="number">0</span> ~ <span class="number">999</span>)。 </span><br><span class="line"></span><br><span class="line">setTime() 以毫秒设置 <span class="built_in">Date</span> 对象。 </span><br><span class="line"></span><br><span class="line">setUTCDate() 根据世界时设置 <span class="built_in">Date</span> 对象中月份的一天 (<span class="number">1</span> ~ <span class="number">31</span>)。 </span><br><span class="line"></span><br><span class="line">setUTCMonth() 根据世界时设置 <span class="built_in">Date</span> 对象中的月份 (<span class="number">0</span> ~ <span class="number">11</span>)。 </span><br><span class="line"></span><br><span class="line">setUTCFullYear() 根据世界时设置 <span class="built_in">Date</span> 对象中的年份（四位数字）。 </span><br><span class="line"></span><br><span class="line">setUTCHours() 根据世界时设置 <span class="built_in">Date</span> 对象中的小时 (<span class="number">0</span> ~ <span class="number">23</span>)。 </span><br><span class="line"></span><br><span class="line">setUTCMinutes() 根据世界时设置 <span class="built_in">Date</span> 对象中的分钟 (<span class="number">0</span> ~ <span class="number">59</span>)。 </span><br><span class="line"></span><br><span class="line">setUTCSeconds() 根据世界时设置 <span class="built_in">Date</span> 对象中的秒钟 (<span class="number">0</span> ~ <span class="number">59</span>)。 </span><br><span class="line"></span><br><span class="line">setUTCMilliseconds() 根据世界时设置 <span class="built_in">Date</span> 对象中的毫秒 (<span class="number">0</span> ~ <span class="number">999</span>)。 </span><br><span class="line"></span><br><span class="line">toSource() 返回该对象的源代码。 </span><br><span class="line"></span><br><span class="line">toString() 把 <span class="built_in">Date</span> 对象转换为字符串。 </span><br><span class="line"></span><br><span class="line">toTimeString() 把 <span class="built_in">Date</span> 对象的时间部分转换为字符串。 </span><br><span class="line"></span><br><span class="line">toDateString() 把 <span class="built_in">Date</span> 对象的日期部分转换为字符串。 </span><br><span class="line"></span><br><span class="line">toGMTString() 请使用 toUTCString() 方法代替。 </span><br><span class="line"></span><br><span class="line">toUTCString() 根据世界时，把 <span class="built_in">Date</span> 对象转换为字符串。 </span><br><span class="line"></span><br><span class="line">toLocaleString() 根据本地时间格式，把 <span class="built_in">Date</span> 对象转换为字符串。 </span><br><span class="line">toLocaleTimeString() 根据本地时间格式，把 <span class="built_in">Date</span> 对象的时间部分转换为字符串。</span><br><span class="line">toLocaleDateString() 根据本地时间格式，把 <span class="built_in">Date</span> 对象的日期部分转换为字符串。 </span><br><span class="line"></span><br><span class="line">UTC() 根据世界时返回 <span class="number">1997</span> 年 <span class="number">1</span> 月 <span class="number">1</span> 日 到指定日期的毫秒数。valueOf() 返回 <span class="built_in">Date</span> 对象的原始值。=</span><br></pre></td></tr></table></figure>

<h3 id="常用日期需求"><a href="#常用日期需求" class="headerlink" title="常用日期需求"></a>常用日期需求</h3><h4 id="1、获取时间戳"><a href="#1、获取时间戳" class="headerlink" title="1、获取时间戳"></a>1、获取时间戳</h4><p>首先，应该获取 <code>Date</code> 类型的数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2020-1-1&#x27;</span>);</span><br><span class="line"><span class="comment">// 形式必须是 yyyy-MM-dd HH:mm:ss 的形式</span></span><br></pre></td></tr></table></figure>

<p><code>Date</code> 类型转化为时间戳有三种方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一  会精确到毫秒，毫秒用000替代</span></span><br><span class="line"><span class="keyword">var</span> time1 = date.getTime();  </span><br><span class="line"><span class="comment">// 方法二  会精确到毫秒，毫秒用000替代</span></span><br><span class="line"><span class="keyword">var</span> time2 = date.valueOf();</span><br><span class="line"><span class="comment">// 方法三  精确到秒</span></span><br><span class="line"><span class="keyword">var</span> time3 = <span class="built_in">Date</span>.parse(date);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：获取到的时间戳除以1000就可获得Unix时间戳，就可传值给后台得到。</p>
</blockquote>
<h2 id="五、奇葩操作"><a href="#五、奇葩操作" class="headerlink" title="五、奇葩操作"></a>五、奇葩操作</h2><h3 id="1、点击按钮复制内容"><a href="#1、点击按钮复制内容" class="headerlink" title="1、点击按钮复制内容"></a>1、点击按钮复制内容</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// html</span></span><br><span class="line">&lt;el-button type=<span class="string">&quot;primary&quot;</span> round size=<span class="string">&quot;mini&quot;</span> @click=<span class="string">&quot;copyUrl&quot;</span>&gt;复制url&lt;/el-button&gt;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//js</span></span><br><span class="line">copyUrl() &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="built_in">document</span>.createElement(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(input)</span><br><span class="line">    input.setAttribute(<span class="string">&#x27;value&#x27;</span>,<span class="string">&quot;这里可以写变量或者要复制的字符串内容&quot;</span>)</span><br><span class="line">    input.select()</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.execCommand(<span class="string">&#x27;copy&#x27;</span>)) &#123;</span><br><span class="line">        <span class="built_in">document</span>.execCommand(<span class="string">&#x27;copy&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(input)；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown</title>
    <url>/2020/08/26/markdown/</url>
    <content><![CDATA[<blockquote>
<p>参考资料</p>
<ul>
<li><a href="https://github.com/LearnShare/Learning-Markdown/blob/master/README.md">markdown入门参考</a></li>
<li><a href="https://www.zybuluo.com/mdeditor">mdeditor</a> 一款国内的在线markdown编辑器</li>
<li><a href="http://bh-lay.github.io/mditor/">mditor</a> 一款轻量级的markdown编辑器</li>
<li><a href="https://www.miaoroom.com/?target/aHR0cHM6Ly9naXRodWIuY29tL2xlcHR1cmUvZWRpdG9y">lepture-editor</a></li>
<li><a href="https://www.miaoroom.com/?target/aHR0cHM6Ly9naXRodWIuY29tL2pidC9tYXJrZG93bi1lZGl0b3I=">markdown-editor</a></li>
</ul>
</blockquote>
<h2 id="一、关于Markdown"><a href="#一、关于Markdown" class="headerlink" title="一、关于Markdown"></a>一、关于Markdown</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="http://zh.wikipedia.org/wiki/Markdown">Wiki: Markdown</a></p>
<blockquote>
<p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。</p>
</blockquote>
<a id="more"></a>

<h3 id="为什么选择-Markdown"><a href="#为什么选择-Markdown" class="headerlink" title="为什么选择 Markdown"></a>为什么选择 Markdown</h3><ul>
<li>它基于纯文本，方便修改和共享；</li>
<li>几乎可以在所有的文本编辑器中编写；</li>
<li>有众多编程语言的实现，以及应用的相关扩展；</li>
<li>在 <a href="https://github.com/">GitHub</a> 等网站中有很好的应用；</li>
<li>很容易转换为 HTML 文档或其他格式，兼容HTML；</li>
<li>适合用来编写文档、记录笔记、撰写文章。</li>
</ul>
<blockquote>
<p>‘.md’ 和 ‘.markdown’ 都是被普遍支持的扩展名，不过 ‘.md’ 更加简单和方便。</p>
</blockquote>
<h2 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h2><h3 id="2-1-段落与换行"><a href="#2-1-段落与换行" class="headerlink" title="2.1 段落与换行"></a>2.1 段落与换行</h3><ul>
<li>段落的前后必须是空行：</li>
</ul>
<blockquote>
<p>空行指的是行内什么都没有，或者只有空白符（空格或制表符）</p>
</blockquote>
<blockquote>
<p>相邻两行文本，如果中间没有空行 会显示在一行中（换行符被转换为空格）</p>
</blockquote>
<ul>
<li>如果需要在段落内加入换行（<code>&lt;br&gt;</code>）：</li>
</ul>
<blockquote>
<p>可以在前一行的末尾加入至少两个空格<br>然后换行写其它的文字</p>
</blockquote>
<ul>
<li>Markdown 中的多数区块都需要在两个空行之间。</li>
</ul>
<h3 id="2-2-标题"><a href="#2-2-标题" class="headerlink" title="2.2 标题"></a>2.2 标题</h3><h4 id="Setext-形式"><a href="#Setext-形式" class="headerlink" title="Setext 形式"></a>Setext 形式</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">H1</span><br><span class="line">====</span><br><span class="line"></span><br><span class="line">H2</span><br><span class="line">----</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>=</code> 和 <code>-</code> 的数量是没有限制的。通常的做法是使其和标题文本的长度相同，这样看起来比较舒服。或者可以像我一样，用四个 <code>-</code> 或 <code>=</code>。<br>Setext 形式只支持 <code>h1</code> 和 <code>h2</code> 两种标题。</p>
<p>使用 === 表示一级标题，使用 — 表示二级标题。(Setext 形式只支持 <code>h1</code> 和 <code>h2</code> 两种标题。)</p>
</blockquote>
<h4 id="atx-形式"><a href="#atx-形式" class="headerlink" title="atx 形式"></a>atx 形式</h4><p>① 可以用对称的 <code>#</code> 包括文本：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">####H4####</span></span><br><span class="line"></span><br><span class="line"><span class="section">#####H5#####</span></span><br></pre></td></tr></table></figure>

<p>② 也可以只在左边使用 <code>#</code>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">####H4</span></span><br><span class="line"></span><br><span class="line"><span class="section">#####H5</span></span><br></pre></td></tr></table></figure>

<p>③ 成对的 <code>#</code> 左侧和只在左边使用的 <code>#</code> 的情况：左侧都不可以有任何空白，但其内侧可以使用空白。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"> ###左侧使用了空格###</span><br><span class="line"></span><br><span class="line"><span class="section">#### 内侧使用了空格</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-引用"><a href="#2-3-引用" class="headerlink" title="2.3 引用"></a>2.3 引用</h3><h4 id="引用内容"><a href="#引用内容" class="headerlink" title="引用内容"></a>引用内容</h4><p>在段落或其他内容前使用 <code>&gt;</code> 符号，就可以将这段内容标记为 ‘引用’ 的内容（<code>&lt;blockquote&gt;</code>）</p>
<h4 id="多行引用"><a href="#多行引用" class="headerlink" title="多行引用"></a>多行引用</h4><blockquote>
<p>多行引用 可以在每行前加 <code>&gt;</code></p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;如果仅在第一行使用 <span class="code">`&gt;`</span>，</span><br><span class="line">后面相邻的行即使省略 <span class="code">`&gt;`</span>，也会变成引用内容</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果仅在第一行使用 <code>&gt;</code>， 后面相邻的行即使省略 <code>&gt;</code>，也会变成引用内容</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;如果引用内容需要换行，  </span><br><span class="line">&gt;可以在行尾添加两个空格</span><br><span class="line">&gt;</span><br><span class="line">&gt;或者在引用内容中加一个空行</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果引用内容需要换行，<br>可以在行尾添加两个空格</p>
<p>或者在引用内容中加一个空行</p>
</blockquote>
<h4 id="嵌套引用"><a href="#嵌套引用" class="headerlink" title="嵌套引用"></a>嵌套引用</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&gt;也可以在引用中</span><br><span class="line">&gt;&gt;使用嵌套的引用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以在引用中</p>
<blockquote>
<p>使用嵌套的引用</p>
</blockquote>
</blockquote>
<h3 id="2-4-列表"><a href="#2-4-列表" class="headerlink" title="2.4 列表"></a>2.4 列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>使用 *，+，- 表示无序列表。</p>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><ol>
<li>有序列表以数字和 <code>.</code> 开始；</li>
<li>数字的序列并不会影响生成的列表序列；</li>
<li>但仍然推荐按照自然顺序（1.2.3…）编写。</li>
</ol>
<h4 id="嵌套的列表"><a href="#嵌套的列表" class="headerlink" title="嵌套的列表"></a>嵌套的列表</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一层</span><br><span class="line"><span class="bullet">  +</span> 1-1</span><br><span class="line"><span class="bullet">  +</span> 1-2</span><br><span class="line"><span class="bullet">2.</span> 无序列表和有序列表可以随意相互嵌套</span><br><span class="line"><span class="bullet">  1.</span> 2-1</span><br><span class="line"><span class="bullet">  2.</span> 2-2</span><br></pre></td></tr></table></figure>

<ol>
<li>第一层<ul>
<li>1-1</li>
<li>1-2</li>
</ul>
</li>
<li>无序列表和有序列表可以随意相互嵌套<ol>
<li>2-1</li>
<li>2-2</li>
</ol>
</li>
</ol>
<h4 id="语法和用法"><a href="#语法和用法" class="headerlink" title="语法和用法"></a>语法和用法</h4><ol>
<li>无序列表项的开始是：符号 空格；</li>
<li>有序列表项的开始是：数字 <code>.</code> 空格；</li>
<li>空格至少为一个，多个空格将被解析为一个；</li>
<li>如果仅需要在行前显示数字和 <code>.</code>：</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">05\. 可以使用：数字\. 来取消显示为列表</span><br></pre></td></tr></table></figure>

<p>\05. 可以使用：数字. 来取消显示为列表</p>
<h3 id="2-5-代码"><a href="#2-5-代码" class="headerlink" title="2.5 代码"></a>2.5 代码</h3><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>可以使用缩进来插入代码块这里使用``````来包含多行代码：</p>
<p>代码块前后需要有至少一个空行，且每行代码前需要有至少一个 Tab 或四个空格；</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="params">&lt;html&gt;</span> <span class="comment">// Tab开头</span></span><br><span class="line">    <span class="params">&lt;title&gt;</span>Markdown<span class="params">&lt;/title&gt;</span></span><br><span class="line"><span class="params">&lt;/html&gt;</span> <span class="comment">// 四个空格开头</span></span><br></pre></td></tr></table></figure>

<h4 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h4><p>也可以通过 ``，插入行内代码：</p>
<p>例如 <code>&lt;title&gt;Markdown&lt;/title&gt;</code></p>
<h4 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h4><p>代码块中的文本（包括 Markdown 语法）都会显示为原始内容，而特殊字符会被转换为 HTML <a href="https://zh.wikipedia.org/wiki/XML%E4%B8%8EHTML%E5%AD%97%E7%AC%A6%E5%AE%9E%E4%BD%93%E5%BC%95%E7%94%A8%E5%88%97%E8%A1%A8">字符实体</a>。</p>
<h3 id="2-6-分隔线"><a href="#2-6-分隔线" class="headerlink" title="2.6 分隔线"></a>2.6 分隔线</h3><ul>
<li>可以在一行中使用三个或更多的 <code>*</code>、<code>-</code> 或 <code>_</code> 来添加分隔线（<code>&lt;hr&gt;</code>）</li>
<li>多个字符之间可以有空格（空白符），但不能有其他字符</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="strong"><span class="emphasis">-- -- --</span></span></span><br><span class="line"><span class="strong"><span class="emphasis"><span class="strong">__<span class="emphasis">_</span></span></span></span></span><br></pre></td></tr></table></figure>

<hr>
<hr>
<hr>
<h3 id="2-7-超链接"><a href="#2-7-超链接" class="headerlink" title="2.7 超链接"></a>2.7 超链接</h3><h4 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h4><p>格式为 <code>[link text](URL &#39;title text&#39;)</code>。</p>
<p>① 普通链接：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Google</span>](<span class="link">http://www.google.com/</span>)</span><br></pre></td></tr></table></figure>

<p><a href="http://www.google.com/">Google</a></p>
<p>② 指向本地文件的链接：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">icon.png</span>](<span class="link">./images/icon.png</span>)</span><br></pre></td></tr></table></figure>

<p><a href="./images/icon.png">icon.png</a></p>
<p>③ 包含 ‘title’ 的链接:</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Google</span>](<span class="link">http://www.google.com/ &quot;Google&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><a href="http://www.google.com/">Google</a></p>
<blockquote>
<p>title 使用 ‘ 或 “ 都是可以的。</p>
</blockquote>
<h4 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h4><p>参考式链接的写法相当于行内式拆分成两部分，并通过一个 <em>识别符</em> 来连接两部分。参考式能尽量保持文章结构的简单，也方便统一管理 URL。</p>
<blockquote>
<p>参考式相对于行内式有一个明显的优点，就是可以在多个不同的位置引用同一个 URL。</p>
</blockquote>
<p>① 首先，定义链接：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Google</span>][<span class="symbol">link</span>]</span><br></pre></td></tr></table></figure>

<p><a href="http://www.google.com/">Google</a></p>
<p>第二个方括号内为链接独有的 <em>识别符</em>，可以是字母、数字、空白或标点符号。识别符是 <em>不区分大小写</em> 的；</p>
<p>② 然后定义链接内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="symbol">link</span>]: <span class="link">http://www.google.com/ &quot;Google&quot;</span></span><br></pre></td></tr></table></figure>

<p>其格式为：<code>[识别符]: URL &#39;title&#39;</code>。</p>
<blockquote>
<p>其中，URL可以使用 &lt;&gt; 包括起来，title 可以使用 “”、’’、() 包括（考虑到兼容性，建议使用引号），title 部分也可以换行来写；</p>
<p>链接内容的定义可以放在同一个文件的 <em>任意位置</em>；</p>
</blockquote>
<p>③ 也可以省略 <em>识别符</em>，使用链接文本作为 <em>识别符</em>：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">Google</span>][<span class="symbol"></span>]</span><br><span class="line">[<span class="symbol">Google</span>]: <span class="link">http://www.google.com/ &quot;Google&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="http://www.google.com/">Google</a></p>
<h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><p>使用 <code>&lt;&gt;</code> 包括的 URL 或邮箱地址会被自动转换为超链接：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">http:</span>//<span class="attr">www.google.com</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">123@email.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><a href="http://www.google.com/">http://www.google.com/</a></p>
<p><a href="mailto:123@email.com">123@email.com</a></p>
<p>该方式适合行内较短的链接，会使用 URL 作为链接文字。邮箱地址会自动编码，以逃避抓取机器人。</p>
<h3 id="2-8-图像"><a href="#2-8-图像" class="headerlink" title="2.8 图像"></a>2.8 图像</h3><p>插入图片的语法和插入超链接的语法基本一致，只是在最前面多一个 <code>!</code>。也分为行内式和参考式两种。</p>
<h4 id="行内式-1"><a href="#行内式-1" class="headerlink" title="行内式"></a>行内式</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">GitHub</span>](<span class="link">https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100 &quot;GitHub,Social Coding&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>方括号中的部分是图片的替代文本，括号中的 ‘title’ 部分和链接一样，是可选的。</p>
<h4 id="参考式-1"><a href="#参考式-1" class="headerlink" title="参考式"></a>参考式</h4><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">GitHub</span>][<span class="symbol">github</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">github</span>]: <span class="link">https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100 &quot;GitHub,Social Coding&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="指定图片的显示大小"><a href="#指定图片的显示大小" class="headerlink" title="指定图片的显示大小"></a>指定图片的显示大小</h4><p>Markdown 不支持指定图片的显示大小，不过可以通过直接插入<code>&lt;img /&gt;</code>标签来指定相关属性：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://avatars2.githubusercontent.com/u/3265208?v=3&amp;s=100&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;GitHub&quot;</span> <span class="attr">title</span>=<span class="string">&quot;GitHub,Social Coding&quot;</span> <span class="attr">width</span>=<span class="string">&quot;50&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-9-强调"><a href="#2-9-强调" class="headerlink" title="2.9 强调"></a>2.9 强调</h3><ul>
<li>使用 <code>* *</code> 或 <code>_ _</code> 包括的文本会被转换为 <code>&lt;em&gt;&lt;/em&gt;</code> ，通常表现为斜体：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是用来 <span class="emphasis">*演示*</span> 的 <span class="emphasis">_文本_</span></span><br></pre></td></tr></table></figure>

<p>这是用来 <em>演示</em> 的 <em>文本</em></p>
<ul>
<li>使用 <code>** **</code> 或 <code>__ __</code> 包括的文本会被转换为 <code>&lt;strong&gt;&lt;/strong&gt;</code>，通常表现为加粗：</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这是用来 <span class="strong">**演示**</span> 的 <span class="strong">__文本__</span></span><br></pre></td></tr></table></figure>

<p>这是用来 <strong>演示</strong> 的 <strong>文本</strong></p>
<ul>
<li><p>用来包括文本的 <code>*</code> 或 <code>_</code> 内侧不能有空白，否则 <code>*</code> 和 <code>_</code> 将不会被转换（不同的实现会有不同的表现）</p>
</li>
<li><p>如果需要在文本中显示成对的 <code>*</code> 或 <code>_</code>，可以在符号前加入 <code>\</code> 即可</p>
</li>
<li><p><code>*</code>、<code>**</code>、<code>_</code> 和 <code>__</code> 都必须 <em>成对使用</em> 。</p>
</li>
</ul>
<h3 id="2-9-字符转义"><a href="#2-9-字符转义" class="headerlink" title="2.9 字符转义"></a>2.9 字符转义</h3><p>  反斜线（<code>\</code>）用于插入在 Markdown 语法中有特殊作用的字符</p>
<p>  这些字符包括：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">\ `* _ &#123;&#125;<span class="selector-attr">[]</span>()#+. !</span><br></pre></td></tr></table></figure>



<h2 id="三、扩展语法"><a href="#三、扩展语法" class="headerlink" title="三、扩展语法"></a>三、扩展语法</h2><h3 id="3-1-内容目录"><a href="#3-1-内容目录" class="headerlink" title="3.1 内容目录"></a>3.1 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p>
<p>[TOC]</p>
<h3 id="3-2-标签分类"><a href="#3-2-标签分类" class="headerlink" title="3.2 标签分类"></a>3.2 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">标签： 数学 英语 Markdown</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">Tags： 数学 英语 Markdown</span><br></pre></td></tr></table></figure>

<h3 id="3-3-删除线"><a href="#3-3-删除线" class="headerlink" title="3.3 删除线"></a>3.3 删除线</h3><p>成对使用 ~~ 表示删除线。</p>
<p><del>这是一段错误的文本。</del></p>
<h3 id="3-4-注脚"><a href="#3-4-注脚" class="headerlink" title="3.4 注脚"></a>3.4 注脚</h3><p>使用 <code>[^keyword]</code> 表示注脚。</p>
<p>这是一个注脚<a href="1">^footnote</a>的样例。</p>
<p>这是第二个注脚<a href="2">^footnote2</a>的样例。</p>
<h3 id="3-5-LaTeX-公式"><a href="#3-5-LaTeX-公式" class="headerlink" title="3.5 LaTeX 公式"></a>3.5 LaTeX 公式</h3><p>$ 表示行内公式： </p>
<p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p>
<p>$$ 表示整行公式：</p>
<p>$$\sum_{i=1}^n a_i=0$$</p>
<p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p>
<p>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p>
<p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax</a> 参考更多使用方法。</p>
<h3 id="3-6-加强的代码块"><a href="#3-6-加强的代码块" class="headerlink" title="3.6 加强的代码块"></a>3.6 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p>
<blockquote>
<p>格式如下：</p>
</blockquote>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">​<span class="string">``</span><span class="string">`python</span></span><br><span class="line"><span class="string">@requires_authorization</span></span><br><span class="line"><span class="string">def somef</span></span><br><span class="line"><span class="string">.......................</span></span><br><span class="line"><span class="string">​`</span><span class="string">``</span></span><br></pre></td></tr></table></figure>

<p>非代码示例：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ sudo apt-<span class="builtin-name">get</span> install vim-gnome</span><br></pre></td></tr></table></figure>

<p>Python 示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span>(<span class="params">param1=<span class="string">&#x27;&#x27;</span>, param2=<span class="number">0</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;A docstring&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">&#x27;Greater&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">&#x27;&#x27;&#x27;interpreter</span></span><br><span class="line"><span class="string"><span class="meta">... </span>prompt&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nth element in the fibonacci series.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>n &gt;= 0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return </span>the nth element, &gt;= 0.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> tmp;</span><br><span class="line">  <span class="keyword">while</span> (--n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp = a;</span><br><span class="line">    a += b;</span><br><span class="line">    b = tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(fib(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<h3 id="3-7-表格支持"><a href="#3-7-表格支持" class="headerlink" title="3.7 表格支持"></a>3.7 表格支持</h3><h4 id="单元格和表头"><a href="#单元格和表头" class="headerlink" title="单元格和表头"></a>单元格和表头</h4><p>使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">name | age</span><br><span class="line">---- | ---</span><br><span class="line">LearnShare | 12</span><br><span class="line">Mike |  32</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>LearnShare</td>
<td>12</td>
</tr>
<tr>
<td>Mike</td>
<td>32</td>
</tr>
</tbody></table>
<p>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 <code>|</code> 来标记单元格边界：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|    name    | age |</span><br><span class="line">| ---------- | --- |</span><br><span class="line">| LearnShare |  12 |</span><br><span class="line">| Mike       |  32 |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody><tr>
<td>LearnShare</td>
<td>12</td>
</tr>
<tr>
<td>Mike</td>
<td>32</td>
</tr>
</tbody></table>
<blockquote>
<p>为了使 Markdown 更清晰，<code>|</code> 和 <code>-</code> 两侧需要至少有一个空格（最左侧和最右侧的 <code>|</code> 外就不需要了）。</p>
</blockquote>
<h4 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h4><p>在表头下方的分隔线标记中加入 <code>:</code>，即可标记下方单元格内容的对齐方式：</p>
<ul>
<li><code>:---</code> 代表左对齐</li>
<li><code>:--:</code> 代表居中对齐</li>
<li><code>---:</code> 代表右对齐</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| left | center | right |</span><br><span class="line">| :--- | :----: | ----: |</span><br><span class="line">| aaaa | bbbbbb | ccccc |</span><br><span class="line">| a    | b      | c     |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">left</th>
<th align="center">center</th>
<th align="right">right</th>
</tr>
</thead>
<tbody><tr>
<td align="left">aaaa</td>
<td align="center">bbbbbb</td>
<td align="right">ccccc</td>
</tr>
<tr>
<td align="left">a</td>
<td align="center">b</td>
<td align="right">c</td>
</tr>
</tbody></table>
<blockquote>
<p>如果不使用对齐标记，单元格中的内容默认左对齐；表头单元格中的内容会一直居中对齐（不同的实现可能会有不同表现）。</p>
</blockquote>
<h4 id="插入其他内容"><a href="#插入其他内容" class="headerlink" title="插入其他内容"></a>插入其他内容</h4><p>表格中可以插入其他 Markdown 中的行内标记：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">|     name     | age |             blog                |</span><br><span class="line">| ------------ | --- | ------------------------------- |</span><br><span class="line">| <span class="emphasis">_LearnShare_</span> |  12 | [<span class="string">LearnShare</span>](<span class="link">http://xianbai.me</span>) |</span><br><span class="line">| <span class="strong">__Mike__</span>     |  32 | [<span class="string">Mike</span>](<span class="link">http://mike.me</span>)          |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
<th>blog</th>
</tr>
</thead>
<tbody><tr>
<td><em>LearnShare</em></td>
<td>12</td>
<td><a href="http://xianbai.me/">LearnShare</a></td>
</tr>
<tr>
<td><strong>Mike</strong></td>
<td>32</td>
<td><a href="http://mike.me/">Mike</a></td>
</tr>
</tbody></table>
<h3 id="3-8-Html-标签"><a href="#3-8-Html-标签" class="headerlink" title="3.8 Html 标签"></a>3.8 Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p>
<pre><code>&lt;table&gt;
    &lt;tr&gt;
        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;
        &lt;th&gt;星期一&lt;/th&gt;
        &lt;th&gt;星期二&lt;/th&gt;
        &lt;th&gt;星期三&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;李强&lt;/td&gt;
        &lt;td&gt;张明&lt;/td&gt;
        &lt;td&gt;王平&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</code></pre>
<table>
    <tr>
        <th rowspan="2">值班人员</th>
        <th>星期一</th>
        <th>星期二</th>
        <th>星期三</th>
    </tr>
    <tr>
        <td>李强</td>
        <td>张明</td>
        <td>王平</td>
    </tr>
</table>


<h3 id="3-9-内嵌图标"><a href="#3-9-内嵌图标" class="headerlink" title="3.9 内嵌图标"></a>3.9 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p>
<pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;</code></pre>
<p>即显示微博的图标： <i class="icon-weibo icon-2x"></i></p>
<p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p>
<pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;</code></pre>
<p>即显示人人的图标： <i class="icon-renren icon-2x"></i></p>
<p>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/">font-awesome</a> 官方网站。</p>
<h3 id="3-10-待办事宜-Todo-列表"><a href="#3-10-待办事宜-Todo-列表" class="headerlink" title="3.10 待办事宜 Todo 列表"></a>3.10 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p>
<pre><code>- [ ] **Cmd Markdown 开发**
    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率
    - [ ] 支持以 PDF 格式导出文稿
    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)
    - [x] 改进 LaTex 功能
        - [x] 修复 LaTex 公式渲染问题
        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)
- [ ] **七月旅行准备**
    - [ ] 准备邮轮上需要携带的物品
    - [ ] 浏览日本免税店的物品
    - [x] 购买蓝宝石公主号七月一日的船票</code></pre>
<p>对应显示如下待办事宜 Todo 列表：</p>
<ul>
<li><input checked disabled type="checkbox"> <strong>Cmd Markdown 开发</strong><ul>
<li><input checked disabled type="checkbox"> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li><input disabled type="checkbox"> 支持以 PDF 格式导出文稿</li>
<li><input disabled type="checkbox"> 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments">语法参考</a></li>
<li><input disabled type="checkbox"> 改进 LaTex 功能<ul>
<li><input checked disabled type="checkbox"> 修复 LaTex 公式渲染问题</li>
<li><input checked disabled type="checkbox"> 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers">语法参考</a></li>
</ul>
</li>
</ul>
</li>
<li><input disabled type="checkbox"> <strong>七月旅行准备</strong><ul>
<li><input disabled type="checkbox"> 准备邮轮上需要携带的物品</li>
<li><input disabled type="checkbox"> 浏览日本免税店的物品</li>
<li><input checked disabled type="checkbox"> 购买蓝宝石公主号七月一日的船票</li>
</ul>
</li>
</ul>
<h3 id="3-11-流程图"><a href="#3-11-流程图" class="headerlink" title="3.11 流程图"></a>3.11 流程图</h3><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">​&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">&quot;flowchart-0&quot;</span> <span class="built_in">class</span>=<span class="string">&quot;flow-chart&quot;</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<div id="flowchart-1" class="flow-chart"></div>


<h3 id="3-12-序列图"><a href="#3-12-序列图" class="headerlink" title="3.12 序列图"></a>3.12 序列图</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">​```squence</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">​```</span><br></pre></td></tr></table></figure>

<div id="sequence-0"></div>

<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">​```squence</span><br><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br><span class="line">​```</span><br></pre></td></tr></table></figure>

<div id="sequence-1"></div>
#### 示例 3
<figure class="highlight mathematica"><table><tr><td class="code"><pre><span class="line">​```squence</span><br><span class="line">Title: <span class="keyword">Here</span> is a title</span><br><span class="line">A-&gt;B: <span class="keyword">Normal</span> line</span><br><span class="line">B--&gt;<span class="keyword">C</span>: <span class="keyword">Dashed</span> line</span><br><span class="line"><span class="keyword">C</span>-&gt;&gt;<span class="keyword">D</span>: <span class="keyword">Open</span> arrow</span><br><span class="line"><span class="keyword">D</span>--&gt;&gt;A: <span class="keyword">Dashed</span> open arrow</span><br><span class="line">​```</span><br></pre></td></tr></table></figure>


<div id="sequence-2"></div>

<h3 id="3-13-甘特图"><a href="#3-13-甘特图" class="headerlink" title="3.13 甘特图"></a>3.13 甘特图</h3><p>甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">​&lt;pre class&#x3D;&quot;mermaid&quot;&gt;    gantt</span><br><span class="line">    title 项目开发流程</span><br><span class="line">    section 项目确定</span><br><span class="line">        需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">        可行性报告     :after a1, 5d</span><br><span class="line">        概念验证       : 5d</span><br><span class="line">    section 项目实施</span><br><span class="line">        概要设计      :2016-07-05  , 5d</span><br><span class="line">        详细设计      :2016-07-08, 10d</span><br><span class="line">        编码          :2016-07-15, 10d</span><br><span class="line">        测试          :2016-07-22, 5d</span><br><span class="line">    section 发布验收</span><br><span class="line">        发布: 2d</span><br><span class="line">        验收: 3d</span><br><span class="line">​&lt;&#x2F;pre&gt;</span><br></pre></td></tr></table></figure>

<pre class="mermaid">gantt
 title 项目开发流程
    section 项目确定
        需求分析       :a1, 2016-06-22, 3d
        可行性报告     :after a1, 5d
        概念验证       : 5d
    section 项目实施
        概要设计      :2016-07-05  , 5d
        详细设计      :2016-07-08, 10d
        编码          :2016-07-15, 10d
        测试          :2016-07-22, 5d
    section 发布验收
        发布: 2d
        验收: 3d</pre>


<h3 id="3-14-Mermaid-流程图"><a href="#3-14-Mermaid-流程图" class="headerlink" title="3.14 Mermaid 流程图"></a>3.14 Mermaid 流程图</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">​&lt;pre <span class="built_in">class</span>=<span class="string">&quot;mermaid&quot;</span>&gt;graph LR</span><br><span class="line">A[方形] <span class="comment">--&gt;B(圆角)</span></span><br><span class="line">  B <span class="comment">--&gt; C&#123;条件a&#125;</span></span><br><span class="line">  C <span class="comment">--&gt;|a=1| D[结果1]</span></span><br><span class="line">  C <span class="comment">--&gt;|a=2| E[结果2]</span></span><br><span class="line">  F[横向流程图]</span><br><span class="line">​&lt;/pre&gt;</span><br></pre></td></tr></table></figure>

<pre class="mermaid">graph LR
A[方形] -->B(圆角)
  B --> C{条件a}
  C -->|a=1| D[结果1]
  C -->|a=2| E[结果2]
  F[横向流程图]</pre>
<script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display: none">st=>start: Start:>https://www.zybuluo.com
io=>inputoutput: verification
op=>operation: Your Operation
cond=>condition: Yes or No?
sub=>subroutine: Your Subroutine
e=>end

st->io->op->cond
cond(yes)->e
cond(no)->sub->io
​</textarea><textarea id="flowchart-0-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-0", options);</script><textarea id="flowchart-1-code" style="display: none">st=>start: Start:>https://www.zybuluo.com
io=>inputoutput: verification
op=>operation: Your Operation
cond=>condition: Yes or No?
sub=>subroutine: Your Subroutine
e=>end

st->io->op->cond
cond(yes)->e
cond(no)->sub->io</textarea><textarea id="flowchart-1-options" style="display: none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>  var code = document.getElementById("flowchart-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value));  var diagram = flowchart.parse(code);  diagram.drawSVG("flowchart-1", options);</script><script src="https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js"></script><script src="https://cdn.bootcss.com/raphael/2.2.7/raphael.min.js"></script><script src="https://cdn.bootcss.com/underscore.js/1.8.3/underscore-min.js"></script><script src="https://cdn.bootcss.com/js-sequence-diagrams/1.0.6/sequence-diagram-min.js"></script><textarea id="sequence-0-code" style="display: none">对象A->对象B: 对象B你好吗?（请求）
Note right of 对象B: 对象B的描述
Note left of 对象A: 对象A的描述(提示)
对象B-->对象A: 我很好(响应)
对象A->对象B: 你真的好吗？</textarea><textarea id="sequence-0-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-0-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-0-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-0", options);</script><textarea id="sequence-1-code" style="display: none">Alice->Bob: Hello Bob, how are you?
Note right of Bob: Bob thinks
Bob-->Alice: I am good thanks!</textarea><textarea id="sequence-1-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-1-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-1-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-1", options);</script><textarea id="sequence-2-code" style="display: none">Title: Here is a title
A->B: Normal line
B-->C: Dashed line
C->>D: Open arrow
D-->>A: Dashed open arrow</textarea><textarea id="sequence-2-options" style="display: none">{"theme":"simple"}</textarea><script>  var code = document.getElementById("sequence-2-code").value;  var options = JSON.parse(decodeURIComponent(document.getElementById("sequence-2-options").value));  var diagram = Diagram.parse(code);  diagram.drawSVG("sequence-2", options);</script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Tool &amp; Platform</category>
      </categories>
      <tags>
        <tag>开发与调试</tag>
        <tag>开发工具</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 基础概念二</title>
    <url>/2020/10/07/JS-basic-concept-sec/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>紧接 <code>基础概念</code>  做一系列补充</p>
<p>–  变量提升</p>
<p>–  作用域</p>
<p>–  闭包</p>
<p>–  立即执行函数表达式</p>
<p>–  异步任务队列</p>
<p>–  事件冒泡</p>
</blockquote>
<a id="more"></a>

<h2 id="一、变量提升"><a href="#一、变量提升" class="headerlink" title="一、变量提升"></a>一、变量提升</h2><h3 id="JS代码的运行规则"><a href="#JS代码的运行规则" class="headerlink" title="JS代码的运行规则"></a>JS代码的运行规则</h3><p>在<code>JavaScript</code>代码运行之前其实是有一个编译阶段的。编译之后才是从上到下，一行一行解释执行。<code>变量提升</code>就发生在编译阶段，<em>它把变量和函数的声明提升至作用域的顶端</em>。（编译阶段的工作之一就是将变量与其作用域进行关联）。<br>所以对于代码<code>var a =2;</code>来说，编译器看到的是两行代码<code>var a; a = 2;</code>第一个语句是声明语句，在编译阶段处理。第二个语句是赋值语句，在运行阶段处理。</p>
<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>ES6之前我们一般使用var来声明变量，<strong>提升</strong>简单来说就是把我们所写的类似于<code>var a = 123;</code>这样的变量声明，提升到它所在作用域的顶端去执行，到我们代码所在的位置来赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">//undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">123</span>; </span><br><span class="line">&#125;;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>上述代码a的结果是<code>undefined</code>，它的实际执行顺序如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    a = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>再看一个：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p>第一眼看到的时候会认为<code>undefined</code>, 但是记住声明会提升到作用域顶端</p>
<p><strong>下面来看一道经典面试题：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(v1);</span><br><span class="line"><span class="keyword">var</span> v1 = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v1);</span><br><span class="line">    <span class="keyword">var</span> v1 = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(v1);</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(v1);</span><br></pre></td></tr></table></figure>

<p>输出的结果：</p>
<blockquote>
<p>//undefined<br>//undefined<br>//200<br>//100</p>
</blockquote>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>变量提升</strong>需要注意两点：</p>
<ol>
<li>提升的部分只是变量声明，赋值语句和可执行的代码逻辑还保持在原地不动</li>
<li>提升只是将变量声明提升到变量所在的变量范围的顶端，并不是提升到全局范围，说明如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">//会输出undefined</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量提升之后的效果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    a = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p><code>Javascript</code>中不仅仅是变量声明有提升的现象，函数的声明也是一样</p>
<p>具名函数的声明有两种方式：  <strong>函数声明式</strong>   <strong>函数字面量式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//函数字面量式 </span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数字面量式</strong>的声明和<strong>变量提升</strong>的结果是一样的，函数只是一个具体的值；</p>
<p>但是函数声明式的提升现象和变量提升略有不同</p>
<h4 id="函数声明式"><a href="#函数声明式" class="headerlink" title="函数声明式"></a>函数声明式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印结果：ƒ bar () &#123;</span></span><br><span class="line"><span class="comment">//  console.log(1);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>

<p>执行顺序相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br></pre></td></tr></table></figure>

<p><strong>函数提升是整个代码块提升到它所在的作用域的最开始执行</strong></p>
<h4 id="函数字面量式"><a href="#函数字面量式" class="headerlink" title="函数字面量式"></a>函数字面量式</h4><p><strong>函数声明会提升，但是函数表达式不会提升。</strong> 看如下代码：</p>
<p><span style="color:red;">注意：变量提升和变量赋值 是两回事！</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo();</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;    <span class="comment">//这是一个函数表达式，不再是函数声明。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理方式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;    </span><br><span class="line">foo();    <span class="comment">//TypeError，因为还没有赋值</span></span><br><span class="line">bar();    <span class="comment">//bar不可以在全局范围内引用</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h4 id="函数优先规则"><a href="#函数优先规则" class="headerlink" title="函数优先规则"></a>函数优先规则</h4><p>思考下面的问题:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo(); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是<strong>函数优先规则</strong></p>
<p><span style="color:red;">变量声明和函数声明都会得到变量提升，但函数声明会最先得到提升，然后是变量声明。</span></p>
<p>处理方式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">foo();</span><br><span class="line">foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：<code>var foo;</code>由于是重复声明变量，所以被编译优化去掉。</p>
<h4 id="补充情况"><a href="#补充情况" class="headerlink" title="补充情况"></a>补充情况</h4><p><strong>1、对于函数声明来说，如果定义了相同的函数变量声明，后定义的声明会覆盖掉先前的声明，看如下代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo();    <span class="comment">//输出3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>2、JavaScript中是没有块级作用域的概念</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo();    <span class="comment">//输出结果为2</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h2 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h2><h3 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h3><p>作用域是<span style="color:red;">在运行时代码中的某些特定部分中变量，函数和对象的可访问性</span>。换句话说，<em>作用域决定了代码区块中变量和其他资源的可见性。</em></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outFun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">&quot;内层变量2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">outFun2();<span class="comment">//要先执行这个函数，否则根本不知道里面是啥</span></span><br><span class="line"><span class="built_in">console</span>.log(inVariable);<span class="comment">// inVariable is not defined</span></span><br></pre></td></tr></table></figure>

<p>从上面的例子可以体会到作用域的概念，变量 <code>inVariable</code> 在全局作用域没有声明，所以在全局作用域下取值会报错。我们可以这样理解：作用域就是一个独立的地盘，让变量不会外泄、暴露出去。<strong>也就是说作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p>
<p>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域。ES6 的到来，为我们提供了<strong>块级作用域</strong>，可通过新增命令 <code>let</code> 和 <code>const</code> 来体现。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在代码中任何地方都能访问到的对象拥有<strong>全局作用域</strong>，一般来说以下几种情形拥有全局作用域：</p>
<blockquote>
<p>在代码中任何地方都能访问到的对象拥有全局作用域一般来说以下几种情形拥有全局作用域：</p>
</blockquote>
<p><strong>1、最外层函数</strong>和<strong>在最外层函数外面定义的变量</strong>拥有全局作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> outVariable = <span class="string">&quot;我是最外层变量&quot;</span>; <span class="comment">//最外层变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outFun</span>(<span class="params"></span>) </span>&#123; <span class="comment">//最外层函数</span></span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">&quot;内层变量&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>) </span>&#123; <span class="comment">//内层函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(inVariable);</span><br><span class="line">    &#125;</span><br><span class="line">    innerFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(outVariable); <span class="comment">//我是最外层变量</span></span><br><span class="line">outFun(); <span class="comment">//内层变量</span></span><br><span class="line"><span class="built_in">console</span>.log(inVariable); <span class="comment">//inVariable is not defined</span></span><br><span class="line">innerFun(); <span class="comment">//innerFun is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong>2、所有未定义直接赋值的变量</strong>，自动声明为拥有全局作用域</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outFun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    variable = <span class="string">&quot;未定义直接赋值的变量&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> inVariable2 = <span class="string">&quot;内层变量2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">outFun2();<span class="comment">//要先执行这个函数，否则根本不知道里面是啥</span></span><br><span class="line"><span class="built_in">console</span>.log(variable); <span class="comment">//未定义直接赋值的变量</span></span><br><span class="line"><span class="built_in">console</span>.log(inVariable2); <span class="comment">//inVariable2 is not defined</span></span><br></pre></td></tr></table></figure>

<p><strong>3、所有 window 对象的属性拥有全局作用域</strong></p>
<p>一般情况下，window 对象的内置属性都拥有全局作用域，例如 window.name、window.location、window.top 等等。</p>
<p>全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会污染全局命名空间, 容易引起命名冲突。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 张三写的代码中</span></span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">a</span>: <span class="number">100</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 李四写的代码中</span></span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">x</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这就是为何 jQuery、Zepto 等库的源码，所有的代码都会放在(function(){…})()中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是<strong>函数作用域</strong>的一个体现。</p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><blockquote>
<p>函数作用域，是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> blogName=<span class="string">&quot;浮游天地&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerSay</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(blogName);</span><br><span class="line">    &#125;</span><br><span class="line">    innerSay();</span><br><span class="line">&#125;</span><br><span class="line">alert(blogName); <span class="comment">//脚本错误</span></span><br><span class="line">innerSay(); <span class="comment">//脚本错误</span></span><br></pre></td></tr></table></figure>

<p>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行。</p>
<p><strong>值得注意的是</strong>：块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域。在块语句中定义的变量将保留在它们已经存在的作用域中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// &#x27;if&#x27; 条件语句块不会创建一个新的作用域</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;Hammad&#x27;</span>; <span class="comment">// name 依然在全局作用域中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// logs &#x27;Hammad&#x27;</span></span><br></pre></td></tr></table></figure>

<p>初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致bug 。正因为如此，ES6 引入了块级作用域，让变量的生命周期更加可控。</p>
<p><strong>函数作用域有两种方式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>两者的区别在于</strong>它们的<strong>名称标识符会被绑定到何处</strong>，第一段代码中会被绑定到所在作用域中，第二段代码<u>被绑定在函数表达式自身的函数中而不是所在作用域中</u>。</p>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>ES6之前，在javascript中<strong>没有块作用域</strong>,也就是说在<code>&#123;...&#125;</code>中声明的变量会泄露到外面作用域</p>
<p>另外，ES5利用<strong>函数闭包</strong>，也可以<em>模仿块级作用域</em></p>
<blockquote>
<p>块级作用域可通过ES6新增命令 let 和 const 声明，所声明的变量在指定块的作用域外无法被访问。</p>
<p>let 声明的语法与 var 的语法一致。基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。</p>
</blockquote>
<p><strong>块级作用域在如下情况被创建：</strong></p>
<ul>
<li>在一个函数内部</li>
<li>在一个代码块（由一对花括号包裹）内部</li>
</ul>
<p><strong>块级作用域有以下几个特点：</strong></p>
<p><strong>1、声明变量不会提升到代码块顶部</strong>：let/const 声明并不会被提升到当前代码块的顶部，因此你需要手动将 let/const 声明放置到顶部，以便让变量在整个代码块内部可用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// value 在此处不可用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// value 在此处不可用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、禁止重复声明</strong></p>
<p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">40</span>; <span class="comment">// Identifier &#x27;count&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>

<p>在本例中， count 变量被声明了两次：一次使用 var ，另一次使用 let 。因为 let 不能在同一作用域内重复声明一个已有标识符，此处的 let 声明就会抛出错误。但如果在嵌套的作用域内使用 let 声明一个同名的新变量，则不会抛出错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 不会抛出错误</span></span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">40</span>;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3、循环中的绑定块作用域的妙用</strong></p>
<p>开发者可能最希望实现 for 循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>测试1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>测试2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>测试3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;button&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">      btns[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;第&#x27;</span> + (i + <span class="number">1</span>) + <span class="string">&#x27;个&#x27;</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们要实现这样的一个需求: 点击某个按钮, 提示”点击的是第 n 个按钮”，结果点击任意一个按钮，后台都是弹出“第四个”，这是因为 i 是全局变量，执行到点击事件时，此时 i 的值为 3，最简单的方法是<code>用 let 声明 i</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">   btns[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;第&#x27;</span> + (i + <span class="number">1</span>) + <span class="string">&#x27;个&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>三个简单案例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope=<span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(scope);</span><br><span class="line">  <span class="keyword">var</span> scope=<span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">  alert(scope);</span><br><span class="line">&#125;</span><br><span class="line">fn();   </span><br><span class="line">alert(scope);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//结果是undefined , local , global</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope=<span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(scope);</span><br><span class="line">  scope=<span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">  alert(scope);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">alert(scope);</span><br><span class="line">  </span><br><span class="line"><span class="comment">//结果是global , local , local</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope=<span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">scope</span>)</span>&#123;</span><br><span class="line">  alert(scope);</span><br><span class="line">  scope=<span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">  alert(scope);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line">alert(scope);</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是undefined , local , global</span></span><br></pre></td></tr></table></figure>

<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域链本质上就是<strong>根据名称查找变量(标识符名称)的一套规则</strong>。</p>
<p>规则非常简单，在自己的变量对象里找不到变量，就上父级的变量对象查找，当抵达最外层的全局上下文中，无论找到还是没找到，查找过程都会停止。<strong>查找会在找到第一个匹配的变量时停止，被称为遮蔽效应</strong></p>
<p><strong>作用域</strong>其实是由<strong>执行上下文中的变量对象</strong>和<strong>作用域链</strong>共同构成的。</p>
<h3 id="相关试题"><a href="#相关试题" class="headerlink" title="相关试题"></a>相关试题</h3><p><strong>1、说明：因为<code>fn:function()</code>中的活动对象只有全局的a</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a:<span class="number">11</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">        fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.b.fn(); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p><strong>2、说明：foo()中先查找自己的活动对象是否有a, 发现有，直接输出自己活动对象的a=1</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;        </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">bar();<span class="comment">//1 </span></span><br></pre></td></tr></table></figure>
<p><strong>3、这种情况与上面有点不同, value=2只有赋值没有定义，所以会被提升到最上面</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var value = 2   </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">bar();<span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p><strong>4、函数体内函数声明会被提升</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b);  <span class="comment">//函数b</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(b); <span class="comment">//函数b</span></span><br><span class="line">    &#125;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>等效于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(b); <span class="comment">//函数b</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(b);  <span class="comment">//函数b</span></span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="三、闭包"><a href="#三、闭包" class="headerlink" title="三、闭包"></a>三、闭包</h2><h3 id="1、什么是闭包？"><a href="#1、什么是闭包？" class="headerlink" title="1、什么是闭包？"></a>1、什么是闭包？</h3><p>闭包是指有权访问另外一个函数作用域中的变量的函数。可以理解为<strong>能够读取另一个函数作用域的变量的函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="string">&#x27;变量1&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> inner = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.info(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner <span class="comment">// inner 就是一个闭包函数，因为他能够访问到outer函数的作用域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多人会搞不懂匿名函数与闭包的关系，实际上，<strong>闭包是站在作用域的角度上来定义的</strong>。</p>
<p>因为inner访问到outer作用域的变量，所以inner就是一个闭包函数。虽然定义很简单，但是有很多坑点，比如this指向、变量的作用域，稍微不注意可能就造成内存泄露。我们先把问题抛一边，思考一个问题：为什么闭包函数能够访问其他函数的作用域 ?</p>
<h3 id="2、从堆栈的角度看待JS函数"><a href="#2、从堆栈的角度看待JS函数" class="headerlink" title="2、从堆栈的角度看待JS函数"></a>2、从堆栈的角度看待JS函数</h3><p>基本变量的值一般都是存在栈内存中，而对象类型的变量的值存储在堆内存中，栈内存存储对应空间地址。基本的数据类型: Number 、Boolean、Undefined、String、Null。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> <span class="comment">//a是一个基本类型</span></span><br><span class="line"><span class="keyword">var</span> b = &#123;<span class="attr">m</span>: <span class="number">20</span> &#125; <span class="comment">//b是一个对象</span></span><br></pre></td></tr></table></figure>

<p>对应内存存储：</p>
<p><img data-src="js-bibao-1.png"></p>
<p>当我们执行 <code>b=&#123;m:30&#125;</code>时，堆内存就有新的对象<code>&#123;m：30&#125;</code>，栈内存的b指向新的空间地址( <code>指向&#123;m：30&#125;</code> )，而堆内存中原来的{m：20}就会被程序引擎垃圾回收掉，节约内存空间。我们知道js函数也是对象，它也是在堆与栈内存中存储的，我们来看一下转化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(b);</span><br><span class="line">    &#125;</span><br><span class="line">    fn1();</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<p><img data-src="js-bibao-2.png"></p>
<p>栈是一种先进后出的数据结构：</p>
<ol>
<li>在执行fn前，此时我们在全局执行环境(浏览器就是window作用域)，全局作用域里有个变量a；</li>
<li>进入fn，此时栈内存就会push一个fn的执行环境，这个环境里有变量b和函数对象fn1，这里可以访问自身执行环境和全局执行环境所定义的变量</li>
<li>进入fn1，此时栈内存就会push 一个fn1的执行环境，这里面没有定义其他变量，但是我们可以访问到fn和全局执行环境里面的变量，因为程序在访问变量时，是向底层栈一个个找，如果找到全局执行环境里都没有对应变量，则程序抛出undefined的错误。</li>
<li>随着fn1()执行完毕，fn1的执行环境被杯销毁，接着执行完fn()，fn的执行环境也会被销毁，只剩全局的执行环境下，现在没有b变量，和fn1函数对象了，只有a 和 fn(函数声明作用域是window下)</li>
</ol>
<p>在函数内访问某个变量是根据函数作用域链来判断变量是否存在的，而函数作用域链是程序根据函数所在的执行环境栈来初始化的，所以上面的例子，我们在fn1里面打印变量b，根据fn1的作用域链的找到对应fn执行环境下的变量b。所以当程序在调用某个函数时，做了以下的工作：准备执行环境，初始函数作用域链和arguments参数对象</p>
<p>我们现在看回最初的例子outer与inner</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span>  a = <span class="string">&#x27;变量1&#x27;</span></span><br><span class="line">     <span class="keyword">var</span>  inner = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info(a)</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> inner    <span class="comment">// inner 就是一个闭包函数，因为他能够访问到outer函数的作用域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span>  inner = outer()   <span class="comment">// 获得inner闭包函数</span></span><br><span class="line">inner()   <span class="comment">//&quot;变量1&quot;</span></span><br></pre></td></tr></table></figure>

<p>当程序执行完<code>var inner = outer()</code>，其实outer的执行环境并没有被销毁，因为他里面的变量a仍然被inner的函数作用域链所引用，当程序执行完inner(), 这时候，inner和outer的执行环境才会被销毁调</p>
<p>《JavaScript高级编程》书中建议：<strong>由于闭包会携带包含它的函数的作用域，因为会比其他函数占用更多内容，过度使用闭包，会导致内存占用过多。</strong></p>
<h3 id="3、闭包坑点"><a href="#3、闭包坑点" class="headerlink" title="3、闭包坑点"></a>3、闭包坑点</h3><p><strong>坑点1： 引用的变量可能发生变化</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = [];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>； i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">        result.[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info(i)</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JS经典问题：打印结果不是<code>1,2,3,4,...,10</code></p>
<p>因为每个闭包函数访问变量i是outer执行环境下的<code>变量i</code>，随着循环的结束，i已经变成10了，所以执行每个闭包函数，结果打印<code>10， 10， ..., 10</code></p>
<p><span style="color:red;">解决方法：</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> result = [];</span><br><span class="line">      <span class="keyword">for</span> （<span class="keyword">var</span> i = <span class="number">0</span>； i&lt;<span class="number">10</span>; i++）&#123;</span><br><span class="line">        result.[i] = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                   <span class="built_in">console</span>.info(num);    </span><br><span class="line">                <span class="comment">// 此时访问的num，是上层函数执行环境的num</span></span><br><span class="line">                <span class="comment">// 数组有10个函数对象，每个对象的执行环境下的number都不一样</span></span><br><span class="line">             &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>坑点2： this指向问题</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">     name: <span class="string">&#x27;&#x27;</span>object<span class="string">&quot;，</span></span><br><span class="line"><span class="string">     getName： function() &#123;</span></span><br><span class="line"><span class="string">        return function() &#123;</span></span><br><span class="line"><span class="string">             console.info(this.name)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">object.getName()()    // underfined</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 因为里面的闭包函数是在window作用域下执行的，也就是说，this指向windows</span></span><br></pre></td></tr></table></figure>

<p><strong>坑点3：内存泄露问题</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">showId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">    el.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(el.id)   <span class="comment">// 这样会导致闭包引用外层的el，当执行完showId后，el无法释放</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改成下面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">showId</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> id  = el.id</span><br><span class="line">    el.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(id)   <span class="comment">// 这样会导致闭包引用外层的el，当执行完showId后，el无法释放</span></span><br><span class="line">    &#125;</span><br><span class="line">    el = <span class="literal">null</span>    <span class="comment">// 主动释放el</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、闭包技巧"><a href="#4、闭包技巧" class="headerlink" title="4、闭包技巧"></a>4、闭包技巧</h3><p><strong>技巧1： 用闭包解决递归调用问题</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(num&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> anotherFactorial = factorial</span><br><span class="line">factorial = <span class="literal">null</span></span><br><span class="line">anotherFactorial(<span class="number">4</span>)   </span><br><span class="line"><span class="comment">// 报错 ，因为最好是return num* arguments.callee（num-1）</span></span><br><span class="line"><span class="comment">// arguments.callee指向当前执行函数，但是在严格模式下不能使用该属性也会报错，所以借助闭包来实现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用闭包实现递归</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFactorial</span> = （<span class="title">function</span> <span class="title">f</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num&lt;<span class="number">1</span>) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> num* f(num<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;） </span><br><span class="line"><span class="comment">//这样就没有问题了，实际上起作用的是闭包函数f，而不是外面的函数newFactorial</span></span><br></pre></td></tr></table></figure>

<p><strong>技巧2：用闭包模仿块级作用域</strong></p>
<p>es6没出来之前，用var定义变量存在变量提升问题；es6以后当然大多用es6的<code>let 和const</code> 定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.info(i)</span><br><span class="line">&#125;</span><br><span class="line">alert(i)  <span class="comment">// 变量提升，弹出10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了避免i的提升可以这样做</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">         <span class="built_in">console</span>.info(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line">alert(i)   <span class="comment">// underfined   因为i随着闭包函数的退出，执行环境销毁，变量回收</span></span><br></pre></td></tr></table></figure>

<h3 id="5、使用闭包的注意点"><a href="#5、使用闭包的注意点" class="headerlink" title="5、使用闭包的注意点"></a>5、使用闭包的注意点</h3><ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ul>
<h3 id="6、补充"><a href="#6、补充" class="headerlink" title="6、补充"></a>6、补充</h3><p><strong>闭包的创建：­­­</strong></p>
<p>闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。</p>
<p>闭包会发生内存泄漏，<span style="color:red;">每次外部函数执行的时候，外部函数的引用地址不同，都会重新创建一个新的地址。</span>但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。</p>
<p><strong>在闭包的应用场景中，记住一句话：</strong></p>
<p><span style="color:red;"><strong>闭包找到的是同一地址中父级函数中对应变量最终的值</strong></span></p>
<h4 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h4><p><strong>例一</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;  <span class="comment">// funA的活动对象之中;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   <span class="comment">//匿名函数的活动对象;</span></span><br><span class="line">        alert(a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = funA();</span><br><span class="line">b();  <span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<p><strong>例二</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      i++;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> innerFn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inner = outerFn();  </span><br><span class="line"><span class="comment">//每次外部函数执行的时候,都会开辟一块内存空间,外部函数的地址不同，都会重新创建一个新的地址</span></span><br><span class="line">inner();</span><br><span class="line">inner();</span><br><span class="line">inner();</span><br><span class="line"><span class="keyword">var</span> inner2 = outerFn();</span><br><span class="line">inner2();</span><br><span class="line">inner2();</span><br><span class="line">inner2();   <span class="comment">//1 2 3 1 2 3</span></span><br></pre></td></tr></table></figure>

<p><strong>例三</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> m = <span class="number">0</span>; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getM</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> m; &#125; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">seta</span>(<span class="params">val</span>) </span>&#123; m = val; &#125; </span><br><span class="line">  <span class="built_in">window</span>.g = getM; </span><br><span class="line">  <span class="built_in">window</span>.f = seta; </span><br><span class="line">&#125;)(); </span><br><span class="line">f(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.info(g());   <span class="comment">//100  闭包找到的是同一地址中父级函数中对应变量最终的值</span></span><br></pre></td></tr></table></figure>

<p><strong>例四</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> count = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span>  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">      count++; </span><br><span class="line">      <span class="built_in">console</span>.info(count); </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> t1 = f();</span><br><span class="line">t1();     <span class="comment">//1 </span></span><br><span class="line">t1();     <span class="comment">//2 </span></span><br><span class="line">t1();     <span class="comment">//3 </span></span><br></pre></td></tr></table></figure>

<p><strong>例五</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">var</span> tmp = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">      sum = sum + x; </span><br><span class="line">      <span class="keyword">return</span> tmp;    </span><br><span class="line">  &#125; </span><br><span class="line">  tmp.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> sum; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tmp; </span><br><span class="line">&#125; </span><br><span class="line">alert(add(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>).toString());     <span class="comment">//6</span></span><br><span class="line"><span class="comment">// add()的第一次参数无效</span></span><br></pre></td></tr></table></figure>

<p><strong>例六</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;li&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;lis.length;i++)&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">      lis[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(i);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;)(i);       <span class="comment">//事件处理函数中闭包的写法</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>例七</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  fn=(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span>  i=<span class="number">10</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span>  <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(++i);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span>   fn;</span><br><span class="line">&#125;)() </span><br><span class="line">fn();   <span class="comment">//11</span></span><br><span class="line">fn();   <span class="comment">//12</span></span><br></pre></td></tr></table></figure>

<p><strong>例八</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">n,o</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(o);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">         fun:<span class="function"><span class="keyword">function</span>(<span class="params">m</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">return</span> fun(m,n);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = fun(<span class="number">0</span>);  <span class="comment">//undefined</span></span><br><span class="line">a.fun(<span class="number">1</span>);  <span class="comment">//0  </span></span><br><span class="line">a.fun(<span class="number">2</span>);  <span class="comment">//0  </span></span><br><span class="line">a.fun(<span class="number">3</span>);  <span class="comment">//0  </span></span><br><span class="line"><span class="keyword">var</span> b = fun(<span class="number">0</span>).fun(<span class="number">1</span>).fun(<span class="number">2</span>).fun(<span class="number">3</span>);   <span class="comment">//undefined  0  1  2</span></span><br><span class="line"><span class="keyword">var</span> c = fun(<span class="number">0</span>).fun(<span class="number">1</span>);  </span><br><span class="line">c.fun(<span class="number">2</span>);  </span><br><span class="line">c.fun(<span class="number">3</span>);  <span class="comment">//undefined  0  1  1</span></span><br></pre></td></tr></table></figure>

<p><strong>例九</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经典对比</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> arr = [];</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)&#123;</span><br><span class="line">     arr[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list = fn();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = list.length;i &lt; len ; i ++)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(list[i]());</span><br><span class="line">&#125;  <span class="comment">//5 5 5 5 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i ++)&#123;</span><br><span class="line">    arr[i] = (<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list = fn();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,len = list.length;i &lt; len ; i ++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list[i]());</span><br><span class="line">&#125;  <span class="comment">//0 1 2 3 4</span></span><br></pre></td></tr></table></figure>

<h2 id="四、立即执行函数表达式"><a href="#四、立即执行函数表达式" class="headerlink" title="四、立即执行函数表达式"></a>四、立即执行函数表达式</h2><h3 id="1、函数声明和函数表达式"><a href="#1、函数声明和函数表达式" class="headerlink" title="1、函数声明和函数表达式"></a>1、函数声明和函数表达式</h3><h4 id="1-1-函数声明（函数语句）"><a href="#1-1-函数声明（函数语句）" class="headerlink" title="1.1 函数声明（函数语句）"></a>1.1 函数声明（函数语句）</h4><ul>
<li>使用 function 关键字声明一个函数，再指定一个函数名，叫函数声明。</li>
<li>【注意】JavaScript引擎规定，如果function关键字出现在<strong>行首</strong>，一律解释成函数声明语句</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// body</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  调用函数</span></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<h4 id="1-2-函数表达式-function-expression"><a href="#1-2-函数表达式-function-expression" class="headerlink" title="1.2 函数表达式    function expression"></a>1.2 函数表达式    <code>function expression</code></h4><ol>
<li>使用 function 关键字声明一个函数，函数名称可被省略，此种情况下的函数是 <strong>匿名函数</strong>（anonymous）。 函数名称只是函数体中的一个本地变量。</li>
<li><strong>将匿名函数赋予一个变量</strong>，叫函数表达式，这是最常见的函数表达式语法形式。</li>
</ol>
<h4 id="1-3-匿名函数"><a href="#1-3-匿名函数" class="headerlink" title="1.3 匿名函数"></a>1.3 匿名函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// statement</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以为其命名</span></span><br><span class="line"><span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span> <span class="title">nameFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>命名函数表达式的<strong>好处</strong>是当我们遇到错误时，堆栈跟踪会显示函数名，<strong>容易寻找错误</strong>。</li>
<li>可以看到，上面的两个例子都不以function开头。<strong>不以function开头的函数语句就是函数表达式定义</strong>。</li>
</ol>
<h4 id="1-4-IIFE"><a href="#1-4-IIFE" class="headerlink" title="1.4 IIFE"></a>1.4 IIFE</h4><p>但有时需要在定义函数之后，立即调用该函数（<strong>函数只使用一次</strong>）。这种函数就叫做<strong>立即执行函数</strong>，全称为<strong>立即调用函数表达式</strong>IIFE(Imdiately Invoked Function Expression)</p>
<h3 id="2、立即调用函数表达式"><a href="#2、立即调用函数表达式" class="headerlink" title="2、立即调用函数表达式"></a>2、立即调用函数表达式</h3><p><strong>立即调用函数表达式</strong>（IIFE）是一个<strong>在定义时就会立即执行的 JavaScript 函数。</strong></p>
<p>（1）这是一个被称为 <strong>自执行匿名函数 的设计模式</strong>，主要包含两部分。第一部分是包围在 <strong>圆括号运算符()</strong> 里的一个<strong>匿名函数</strong>。</p>
<p>（2）第二部分再一次使用 <strong>()</strong> 创建了一个<strong>立即执行函数表达式</strong>，JavaScript 引擎到此将直接执行函数。</p>
<h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><p>（1）【最常用的两种办法】</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐使用</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;());</span><br><span class="line"><span class="comment">// 也可以</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure>

<p>（2）【其他写法】</p>
<p>在Javascript里圆括号内不能包含语句，<strong>当解释器对代码进行解释的时候遇到圆括号就认为这里面是表达式，然后遇到function关键字就认为这是一个函数表达式，而不是函数声明</strong>。而更加奇妙的是只要是能将后面语句预先解释为表达式都可以，不一定是分分组操作符，于是立即执行函数表达式有了五花八门的写法，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; counter1(); &#125;());</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; counter1(); &#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; counter1(); &#125;();</span><br><span class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; counter1(); &#125;();</span><br><span class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; counter1() &#125;();</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; counter1(); &#125;();</span><br><span class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; counter1(); &#125;();</span><br><span class="line">-<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; counter1(); &#125;();</span><br><span class="line">+<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; counter1(); &#125;();</span><br></pre></td></tr></table></figure>

<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>1、IIFE 中的匿名函数拥有 <strong>独立的词法作用域</strong>。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。（另一种说法 【构造一个函数作用域，防止污染全局变量】）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Barry&quot;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部不能访问变量 name</span></span><br><span class="line">name  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>2、 JavaScript <strong>没用私有作用域的概念</strong>，如果是在多人开发的项目，你在全局或局部作用域中声明的变量，可能会被其他人不小心用同名的变量给 <strong>覆盖</strong>，根据JavaScript 函数作用域链的特性，使用这种技术可以模仿一个私有作用域，<strong>匿名函数</strong>作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以 <code>( function()&#123;…&#125; )()</code> <strong>内部定义的变量不会和外部的变量发生冲突</strong>，俗称“匿名包裹器”或“命名空间”。</p>
<p>3、【注意】将 IIFE 分配给一个变量，不是存储 IIFE 本身，而是<strong>存储 IIFE 执行后返回的结果</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;Barry&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// IIFE 执行后返回的结果</span></span><br><span class="line">result; <span class="comment">// &quot;Barry&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>假设有一个需求，每次调用函数，都返回加1的一个数字(数字初始值为0)</p>
<p><strong>一般情况下，我们会使用全局变量来保存该数字状态</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(add()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义属性</strong></p>
<p>但上面的方法中，变量a实际上只和add函数相关，却声明为全局变量，不太合适</p>
<p>因此，<span style="color:red;">将变量a更改为函数的自定义属性更为恰当</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ++add.count;</span><br><span class="line">&#125;</span><br><span class="line">add.count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(add()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(add()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><strong>IIFE</strong></p>
<p>其实这样做，还是有问题。有些代码可能会无意中将add.count重置</p>
<p><span style="color:red;">使用IIFE把计数器变量保存为私有变量更安全，同时也可以减少对全局空间的污染</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> add =  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ++counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(add()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(add()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<hr>

<h2 id="五、异步任务队列-task-queues"><a href="#五、异步任务队列-task-queues" class="headerlink" title="五、异步任务队列  task queues"></a>五、异步任务队列  <code>task queues</code></h2><blockquote>
<p>本文转载自 <a href="https://segmentfault.com/a/1190000019123388">异步任务队列</a></p>
<p>本文是对于异步系列第一篇里提到的<code>evenloop</code>模型中，所提到的任务队列(task queues)的展开分析</p>
<p><em>以下代码均使用chrome浏览器运行 关于浏览器表现的差异在最后做补充</em></p>
</blockquote>
<h3 id="一个典型例子"><a href="#一个典型例子" class="headerlink" title="一个典型例子"></a>一个典型例子</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="comment">// 第一个异步任务</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个异步任务</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function">()=&gt;</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"><span class="comment">// 实际输出结果： </span></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure>

<p>根据之前说过的<code>evenloop</code>模型，首先输出<code>script start</code>和<code>script end</code>没有什么问题;<br>但是接下来却发现：<br><strong>先执行了<code>Promise</code>指定的<code>callback</code>而不是<code>setTimeout</code>的<code>callback</code>。</strong>– Why？</p>
<h3 id="两种任务队列"><a href="#两种任务队列" class="headerlink" title="两种任务队列"></a>两种任务队列</h3><p><strong>(<code>microtask queue</code>&amp;<code>macrotask queue</code>)</strong></p>
<p>在之前讨论evenloop模型时，粗略提到了任务队列有2种类型:<code>microtask queue</code>和<code>macrotask queue</code>，他们的区别在于:</p>
<ul>
<li><code>macrotask</code>的执行：是在evenloop的每次循环过程，先取出macrotask queue中可执行的第一个（<em>注意不一定是第一个，因为我们说过例如setTimeout可以指定任务被执行的最少延迟时间，当前macrotask queue的首位保存的任务可能还没有到执行时间，所以queue只是代表<code>callback</code>插入的顺序，不代表执行时也要按照这个顺序</em>）。</li>
<li><code>microtask</code>的执行：在evenloop的每次循环过程之后,<strong>如果当前的执行栈(call stack)为空，那么执行<code>microtask queue</code>中所有可执行的任务</strong></li>
</ul>
<p>（某些文献内容中 直接把<code>macrotask</code>称为<code>task</code>,或者某些中文文章中把它们翻译成”微任务”和”宏任务”，含义都是相似的：macrotask或者task代表相对单独占据evenloop过程一次循环的任务，而microtask有可能在一次循环中执行多个）</p>
<p>现在回头来解析前面的例子：</p>
<ol>
<li>第一次执行主函数，输出<code>script start</code></li>
<li>遇到<code>setTimeout</code>，将对应的callback插入<code>macrotask queue</code></li>
<li>遇到<code>promise</code>，将对应的callback插入<code>microtask queue</code></li>
<li>输出<code>script end</code>，主函数运行结束，执行栈清空，此时开始检查<code>microtask queue</code>，发现里面有可运行的任务，因此按顺序输出<code>promise1</code>和<code>promise2</code></li>
<li><code>microtask queue</code>执行完，开始新一轮循环，从<code>macrotask queue</code>取出<code>setTimeout</code>任务并执行，输出<code>setTimeout</code></li>
<li>结束，呈现上面的输出结果。</li>
</ol>
<p>常见异步操作对应的回调函数任务类型如下：</p>
<ul>
<li>macrotask: <code>setTimeout</code>, <code>setInterval</code>, <code>setImmediate</code>, <code>requestAnimationFrame</code>, <code>I/O</code>, <code>UI rendering</code></li>
<li>microtask: <code>process.nextTick</code>, <code>Promises</code>, <code>Object.observe</code>, <code>MutationObserver</code></li>
</ul>
<p>大概可以这样区分：和html交互密切相关的异步操作，一般是<code>macrotasks</code>；由<code>emcascript</code>的相关接口返回的异步操作，一般是<code>microtasks</code></p>
<h3 id="如何判断执行顺序"><a href="#如何判断执行顺序" class="headerlink" title="如何判断执行顺序"></a>如何判断执行顺序</h3><p>接下来看一个更复杂的例子，帮助理解不同异步任务的执行顺序</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.outer</span> &#123;</span></span><br><span class="line">        padding: 30px;</span><br><span class="line">        background-color: aqua;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line">        height: 100px;</span><br><span class="line">        background-color: brown;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span>outer</span><br><span class="line">         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span>inner<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> outer = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.outer&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> inner = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.inner&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// Let&#x27;s listen for attribute changes on the</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// outer element</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;mutate&#x27;</span>);</span></span><br><span class="line">    &#125;).observe(outer, &#123;</span><br><span class="line"><span class="javascript">        attributes: <span class="literal">true</span></span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// Here&#x27;s a click listener…</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;click&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span></span><br><span class="line">        &#125;, 0);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>);</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">        outer.setAttribute(<span class="string">&#x27;data-random&#x27;</span>, <span class="built_in">Math</span>.random());</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// …which we&#x27;ll attach to both elements</span></span></span><br><span class="line"><span class="javascript">    inner.addEventListener(<span class="string">&#x27;click&#x27;</span>, onClick);</span></span><br><span class="line"><span class="javascript">    outer.addEventListener(<span class="string">&#x27;click&#x27;</span>, onClick);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>运行以上代码，可以在浏览器看到两个嵌套的div（如图）:</p>
<p><img data-src="js-async-1.png"></p>
<p><strong>点击inner部分</strong>，打开chrome的调试器，可以看到console打出的结果是:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">click</span><br><span class="line">promise</span><br><span class="line">mutate</span><br><span class="line">click</span><br><span class="line">promise</span><br><span class="line">mutate</span><br><span class="line"><span class="keyword">timeout</span></span><br><span class="line"><span class="keyword">timeout</span></span><br></pre></td></tr></table></figure>

<p>接下来分析运行过程 (<em>建议打开chrome单步调试，进行观察分析</em>)：</p>
<ol>
<li>点击<code>inner</code>,触发对应的<code>onClick</code>事件，此时inner对应的<code>onClick</code>函数进入执行栈；</li>
<li>运行<code>console.log(&#39;click&#39;)</code>,**输出<code>(1)click</code>**；</li>
<li>运行<code>setTimeout</code>,<code>macrotask queue</code>添加对应的<code>console</code>函数</li>
<li>运行<code>Promise</code>，此时<code>microtask queue</code>添加对应的<code>console</code>函数</li>
<li>运行<code>outer.setAttribute</code>,触发<code>MutationObserver</code>,<code>microtask queue</code>添加对应的<code>console</code>函数（前面注明了MutationObserver创建的回调任务类型是microtask）</li>
<li>当前函数执行完毕，由于<strong>执行栈清空</strong>，此时开始调度<code>microtask queue</code>，因此<strong>依次输出<code>(2)promise</code>和<code>(3)mutate</code>**，此时</strong>当前执行栈<code>call stack</code>和<code>microtask queue</code>均为空，但是<code>macrotask queue</code>里依然存储着两个东西–inner的Click触发的任务，以及先前setTimeout的回调函数。**</li>
<li>inner的<code>onclick</code>函数虽然执行完毕，但是由于<code>事件冒泡</code>，紧接着要触发<code>outer</code>的<code>onClick</code>的执行函数，因此<code>setTimeout</code>的回调暂时还无法执行。</li>
<li><code>outer</code>的<code>onClick</code>函数执行过程，重复前面的2-5步骤，因此<strong>输出<code>(4)click</code> <code>(5)promise</code> <code>(6)mutate</code></strong></li>
<li>此时<strong>执行栈<code>call stack</code>和<code>microtask queue</code>均为空，<code>macrotask queue</code>存储着两个setTimeout的回调函数。</strong>，根据evenloop模型，开始分别执行这两个task，于是输出了两个<code>(7)和(8)timeout</code></li>
<li>结束。</li>
</ol>
<br>

<p>在充分理解上面例子的基础上，我们把**点击inner部分的这个操作，改成直接在js代码的末尾加上<code>innner.click()</code>**，请问结果是否一致呢？</p>
<p>先说最终结果:</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">click</span><br><span class="line">click</span><br><span class="line">promise</span><br><span class="line">mutate</span><br><span class="line">promise</span><br><span class="line"><span class="keyword">timeout</span></span><br><span class="line"><span class="keyword">timeout</span></span><br></pre></td></tr></table></figure>

<p>由于是直接执行<code>inner.click()</code>,这次进入<code>inner</code>绑定的<code>onclick</code>函数时，与前面是有所不同的:</p>
<p><strong>通过chrome调试器可以看到，此时的call stack有两层–除了onClick函数之外，还有一层匿名函数，这层函数其实就是最外层的script，相当于window.onload绑定的处理函数。</strong></p>
<p>接下来分析本次的输出顺序：</p>
<ol>
<li>重复前面例子中，步骤<code>2-5</code>，输出一个<code>(1)click</code></li>
<li><code>inner</code>的<code>onClick</code>函数执行完毕，<strong>但是这次执行栈并未清空，因为当前匿名函数还在执行栈里，因此无法开始调度<code>microtask queue</code>！！！（前面说过，microtask queue的调度必须在当前执行栈为空的情况下）</strong>，因此，这时候会<strong>先进入冒泡事件触发的<code>onClick</code></strong></li>
<li>类似的，输出<code>(2)clcik</code>之后，<code>promise</code>的回调函数进入<code>microtask queue</code></li>
<li>运行<code>outer.setAttribute</code>,触发<code>MutationObserver</code>,但是<strong>此时<code>microtask queue</code>无法再次添加对应的回调函数了，因为已经有一个存在的监听函数在<code>pengding</code></strong></li>
<li>两个<code>onclick</code>执行完毕，执行栈清空，接下来开始调度<code>microtask queue</code>,输出<code>(3)promise</code> <code>(4)mutate``(5)promise</code></li>
<li>此时<strong>当前执行栈<code>call stack</code>和<code>microtask queue</code>均为空，<code>macrotask queue</code>存储着两个setTimeout的回调函数。</strong>根据evenloop模型，开始分别执行这两个task，于是输出了两个<code>(6)和(7)timeout</code></li>
<li>结束</li>
</ol>
<p>这两个例子的对比，着重说明了一点:<br>–<strong><code>microtask queue</code>存储的任务，必须要在当前函数执行栈为空时才会开始调度。</strong></p>
<h2 id="六、事件冒泡"><a href="#六、事件冒泡" class="headerlink" title="六、事件冒泡"></a>六、事件冒泡</h2><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>1、事件捕获</strong><br>捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定) </p>
<p><strong>2、事件冒泡</strong><br>冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 </p>
<p><strong>3、捕获和冒泡过程图</strong> </p>
<p><img data-src="js-bubble-1.png"></p>
<p>事件捕获和事件冒泡属于两个相反的过程</p>
<blockquote>
<p>里可以有一个我感觉十分恰当的比喻，当你把一个可以漂浮在水面上的物品，使劲向水里砸下去，它会首先有一个下降的过程，这个过程就可以理解为从最顶层向事件发生的最具体元素（目标点）的捕获过程；之后由于浮力大于物体自身的重力，物体会在到达最低点（ 最具体元素）之后漂浮到水面上，这个过程相对于事件捕获是一个回溯的过程，即事件冒泡。 </p>
</blockquote>
<p><strong>以click点击事件为例</strong>。假如我们有一个多层结构标签。如下图，是4个div嵌套。每个div都有点击的监听事件，分别输出1234。当我们点击最里面的div时，点击事件开始传递，传递的<strong>全过程是1-2-3-4-4-3-2-1</strong>。</p>
<p>前半部分，事件从最外面的父div依次传递到最里面的后代div，<strong>1-2-3-4这部分我们叫捕获过程</strong>。</p>
<p>之后事件又从最里层的后代div逐层传出，<strong>4-3-2-1这部分我们叫冒泡过程</strong>。</p>
<p>如果我把捕获监听器和冒泡监听器都加上，如下图这样。</p>
<p><img data-src="js-bubble-2.png"></p>
<h3 id="添加两种监听的方法"><a href="#添加两种监听的方法" class="headerlink" title="添加两种监听的方法"></a>添加两种监听的方法</h3><p>在不使用任何框架的情况下，我们在js中通过<code>addEventListener</code>方法给Dom添加事件监听。</p>
<p>这个方法有三个参数可以传递addEventListener(event,fn,useCapture)。event是事件类型click，focus，blur等；fn是事件触发时将执行的函数方法（function）；第三个参数可以不传，默认是false<strong>，这个参数控制是否捕获触发</strong>。所以我们只传两个参数时，这个事件是冒泡传递触发的，<strong>当第三个参数存在且为true时，事件是捕获传递触发的。</strong></p>
<p>使用框架时可使用对应的框架提供的方法。如上面我使用了Vue框架，通过事件装饰来区分捕获与冒泡。</p>
<h3 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h3><blockquote>
<p>完整代码</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-1.11.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box1</span> &#123;</span></span><br><span class="line">    border: green 40px solid;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="css"><span class="selector-class">.box2</span> &#123;</span></span><br><span class="line">    border: yellow 40px solid;</span><br><span class="line">    width: 220px;</span><br><span class="line">    height: 220px;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">span &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    left: 50px;</span><br><span class="line">    top: 50px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-tag">rgba</span>(128, 128, 128, 0<span class="selector-class">.22</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;body&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>,eventHandler);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;时间：&quot;</span>+<span class="keyword">new</span> <span class="built_in">Date</span>(event.timeStamp)+<span class="string">&quot; 产生事件的节点：&quot;</span> + event.target.id +<span class="string">&quot;  当前节点：&quot;</span>+event.currentTarget.id);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;span&quot;</span>&gt;</span>This is a span.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>我们来考虑一个形象一点的情况：水中的一个气泡正在从底部往上冒，而你现在在水中，不想让这个气泡往上冒，怎么办呢？——把它扎破！没了气泡，自然不会往上冒了。类似地，对某一个节点而言，如果不想它现在处理的事件继续往上冒泡的话，我们可以终止冒泡：</p>
<p>在相应的处理函数内，加入 <code>event.stopPropagation()</code>  ,终止事件的广播分发，这样事件停留在本节点，不会再往外传播了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;您好，我是最外层div。&quot;</span>);</span></span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;box2&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;您好，我是第二层div。&quot;</span>);</span></span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;span&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;您好，我是span。&quot;</span>);</span></span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>事件包含最初触发事件的节点引用 和 当前处理事件节点的引用，那如果节点只处理自己触发的事件即可,不是自己产生的事件不处理。<code>event.target</code> 引用了产生此event对象的dom 节点，而<code>event.currrentTarget</code> 则引用了当前处理节点，我们可以通过这 两个target 是否相等。</p>
<p>​      比如span 点击事件，产生一个event 事件对象，<code>event.target</code> 指向了span元素，span处理此事件时，<code>event.currentTarget</code> 指向的也是span元素，这时判断两者相等，则执行相应的处理函数。而事件传递给 div2 的时候，<code>event.currentTarget</code>变成 div2，这时候判断二者不相等，即事件不是div2 本身产生的，就不作响应处理逻辑。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;box1&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line">            if(event.target == event.currentTarget)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="javascript">                alert(<span class="string">&quot;您好，我是最外层div。&quot;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;box2&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line">            if(event.target == event.currentTarget)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="javascript">                alert(<span class="string">&quot;您好，我是第二层div。&quot;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;span&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line">            if(event.target == event.currentTarget)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="javascript">                alert(<span class="string">&quot;您好，我是span。&quot;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>​     从事件传递上看：<strong>方法一在于取消事件冒泡，即当某些节点取消冒泡后，事件不会再传递；方法二在于不阻止冒泡，过滤需要处理的事件，事件处理后还会继续传递；</strong></p>
<p><strong>优缺点：</strong></p>
<p>​     <strong>方法一缺点：为了实现点击特定的元素显示对应的信息，方法一要求每个元素的子元素也必须终止事件的冒泡传递</strong>，即跟别的元素功能上强关联，这样的方法会很脆弱。比如，如果span 元素的处理函数没有执行冒泡终止，则事件会传到div2 上，这样会造成div2 的提示信息；</p>
<p>​    <strong>方法二缺点</strong>：方法二为每一个元素都增加了事件监听处理函数，事件的处理逻辑都很相似，即都有判断 <code>if(event.target == event.currentTarget)</code>，这样存在了很大的代码冗余，现在是三个元素还好，当有10几个，上百个又该怎么办呢？还有就是为每一个元素都有处理函数，在一定程度上增加逻辑和代码的复杂度。</p>
<br>

<p>​    我们再来分析一下方法二：<span style="color:red;font-weight:bold;">方法二的原理是 元素收到事件后，判断事件是否符合要求，然后做相应的处理，然后事件继续冒泡往上传递；</span></p>
<p>既然事件是冒泡传递的，那可不可以让某个父节点统一处理事件，通过判断事件的发生地（即事件产生的节点），然后做出相应的处理呢？答案是可以的，下面通过给body 元素添加事件监听，然后通过判断event.target 然后对不同的target产生不同的行为。</p>
<p>​    将方法二的代码重构一下：<em>结果会是点击不同的元素，只弹出相符合的提示，不会有多余的提示。</em></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.getElementById(<span class="string">&quot;body&quot;</span>).addEventListener(<span class="string">&quot;click&quot;</span>,eventPerformed);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">eventPerformed</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> target = event.target;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">switch</span> (target.id) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">case</span> <span class="string">&quot;span&quot;</span>: </span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;您好，我是span。&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">case</span> <span class="string">&quot;div1&quot;</span>:</span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&quot;您好，我是第二层div。&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">case</span> <span class="string">&quot;div2&quot;</span>:</span></span><br><span class="line"><span class="javascript">             alert(<span class="string">&quot;您好，我是最外层div。&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">break</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过以上方式，<span style="color:red;font-weight:bold;">我们把本来每个元素都要有的处理函数，都交给了其祖父节点body 元素来完成了，也就是说，span,div2,div1 将自己的响应逻辑委托给body，让它来完成相应逻辑，自己不实现相应逻辑，这个模式，就是所谓的事件委托。</span></p>
<p>​     下面是一个示意图：</p>
<p><img data-src="js-bubble-3.png"></p>
<p><span style="color:red;"></span></p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript Function</title>
    <url>/2020/08/25/JavaScript-commonly-used-functions/</url>
    <content><![CDATA[<blockquote>
<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><p>以下记录经常忘记又常用的<code>JS</code>内置函数</p>
<p><strong>相关 资料  ：</strong></p>
<p><a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312">廖雪峰的JavaScript教程</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/">MSD—&gt;Nice！@</a></p>
</blockquote>
<a id="more"></a>

<h2 id="Array-Functions"><a href="#Array-Functions" class="headerlink" title="Array Functions"></a>Array Functions</h2><h3 id="1、Array-forEach"><a href="#1、Array-forEach" class="headerlink" title="1、Array.forEach()"></a>1、Array.forEach()</h3><p><strong>描述</strong>：forEach()方法用于调用数组的每一个元素，并将元素传递给回调函数。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>.<span class="keyword">for</span><span class="constructor">Each(<span class="params">function</span>(<span class="params">currentValue</span>, <span class="params">index</span>, <span class="params">arr</span>)</span>, thisValue)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>currentValue：必填，当前元素。</p>
<p>index：可选，当前元素的索引。</p>
<p>arr：可选，当前元素所属的数组对象。</p>
<p>thisValue：可选，传递给函数的值一般用this值，如果这个参数为空，”undefined”会传递给”this”值。（这个参数一般很少填）</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JS代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line"></span><br><span class="line">colors.forEach(<span class="function">(<span class="params">item, $index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span> =&gt; <span class="subst">$&#123;$index&#125;</span> =&gt; <span class="subst">$&#123;arr&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img data-src="pic1.png"></p>
<p>上面的代码用了ES6语法，几乎等同于下面的代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JS代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line"></span><br><span class="line">colors.<span class="keyword">forEach</span>(<span class="function"><span class="keyword">function</span>(<span class="params">item, $index, arr</span>) </span>&#123;</span><br><span class="line">  console.log(item + <span class="string">&#x27; =&gt; &#x27;</span> + $index + <span class="string">&#x27; =&gt; &#x27;</span> + arr);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>区别</strong>：其实，用 forEach() 主要是为了更方便的代替 for 对数组进行遍历。</p>
<p>用 for 遍历数组的方法</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JS代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i &lt; colors.length; i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( colors[i] + <span class="string">&#x27; =&gt; &#x27;</span> + i + <span class="string">&#x27; =&gt; &#x27;</span> + colors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>forEach() 对于空数组是不会执行回调函数的。</li>
<li>for可以用continue跳过循环中的一个迭代，forEach用continue会报错。</li>
<li>forEach() 需要用 return 跳过循环中的一个迭代，跳过之后会执行下一个迭代。</li>
</ul>
<p><strong>如何跳过一次迭代</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* JS代码 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i &lt; colors.length; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>( colors[i] == <span class="string">&#x27;blue&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log( colors[i] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">colors.forEach( <span class="function"><span class="keyword">function</span>(<span class="params"> item </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(item == <span class="string">&#x27;blue&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log( item );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p>没有办法终止或跳出forEach循环，除非抛出一个异常。</p>
<p>如果需要终止或者跳出循环，建议用some()或者every()。</p>
</blockquote>
<h3 id="2、Array-shift"><a href="#2、Array-shift" class="headerlink" title="2、Array.shift()"></a>2、Array.shift()</h3><p>shift() 方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>Object.shift()</span><br></pre></td></tr></table></figure>

<p><strong>返回值</strong>：数组原来的第一个元素的值。</p>
<p><strong>说明</strong></p>
<ul>
<li>如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。</li>
<li>请注意，该方法不创建新数组，而是直接修改原有的 arrayObject。</li>
<li>该方法会改变数组的长度。</li>
</ul>
<h3 id="3、Array-every-Array-some"><a href="#3、Array-every-Array-some" class="headerlink" title="3、Array.every()   Array.some()"></a>3、Array.every()   Array.some()</h3><blockquote>
<p>every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。</p>
<p>some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。</p>
<p>some一直在找符合条件的值，一旦找到，则不会继续迭代下去。<br>every从迭代开始，一旦有一个不符合条件，则不会继续迭代下去。</p>
</blockquote>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">var arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ];  </span><br><span class="line">console.log( arr.<span class="keyword">some</span>( <span class="keyword">function</span>( item, <span class="keyword">index</span>, <span class="keyword">array</span> )&#123;     </span><br><span class="line">    console.log( <span class="string">&#x27;item=&#x27;</span> + item + <span class="string">&#x27;,index=&#x27;</span>+<span class="keyword">index</span>+<span class="string">&#x27;,array=&#x27;</span>+<span class="keyword">array</span> );     </span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span>;  </span><br><span class="line">&#125;));  </span><br><span class="line">console.log( arr.every( <span class="keyword">function</span>( item, <span class="keyword">index</span>, <span class="keyword">array</span> )&#123;     </span><br><span class="line">    console.log( <span class="string">&#x27;item=&#x27;</span> + item + <span class="string">&#x27;,index=&#x27;</span>+<span class="keyword">index</span>+<span class="string">&#x27;,array=&#x27;</span>+<span class="keyword">array</span> );     </span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span>;  </span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="4、Array-slice"><a href="#4、Array-slice" class="headerlink" title="4、Array.slice()"></a>4、Array.slice()</h3><p><strong>描述</strong>：slice() 方法可从已有的数组中返回选定的元素。</p>
<p>返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</p>
<p>该方法并不会修改数组，而是返回一个子数组。</p>
<blockquote>
<p><strong>注释：</strong>您可使用负值从数组的尾部选取元素。</p>
<p><strong>注释：</strong>如果 end 未被规定，那么 slice() 方法会选取从 start 到数组结尾的所有元素。</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">arrayObject.<span class="keyword">slice</span>(<span class="keyword">start</span>,<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">start</td>
<td align="left">必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</td>
</tr>
<tr>
<td align="left">end</td>
<td align="left">可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</td>
</tr>
</tbody></table>
<h3 id="5、String-prototype-indexOf"><a href="#5、String-prototype-indexOf" class="headerlink" title="5、String.prototype.indexOf()"></a>5、String.prototype.indexOf()</h3><p><strong>描述：</strong>方法返回调用它的 <code>String</code> 对象中第一次出现的<code>指定值</code>的索引，从 <code>fromIndex</code> 处进行搜索。如果未找到该值，则返回 -1。</p>
<p><strong>语法</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">str.index<span class="constructor">Of(<span class="params">searchValue</span> [, <span class="params">fromIndex</span>])</span></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><p><code>searchValue</code></p>
<p>要被查找的字符串值。</p>
<p>如果没有提供确切地提供字符串，searchValue 会被强制设置为 <code>&quot;undefined&quot;</code>， 然后在当前字符串中查找这个值。</p>
<p>举个例子：<code>&#39;undefined&#39;.indexOf()</code> 将会返回0，因为 <code>undefined</code> 在位置0处被找到，但是 <code>&#39;undefine&#39;.indexOf()</code> 将会返回 -1 ，因为字符串 <code>&#39;undefined&#39;</code> 未被找到。</p>
</li>
<li><p><code>fromIndex</code> 可选</p>
<p>数字表示开始查找的位置。可以是任意整数，默认值为 <code>0</code>。</p>
<p>如果 <code>fromIndex</code> 的值小于 <code>0</code>，或者大于 <code>str.length</code> ，那么查找分别从 <code>0</code> 和<code>str.length</code> 开始。（译者注： <code>fromIndex</code> 的值小于 <code>0</code>，等同于为空情况； <code>fromIndex</code> 的值大于 <code>str.length</code> ，那么结果会直接返回 <code>-1</code> 。）</p>
<p>举个例子，<code>&#39;hello world&#39;.indexOf(&#39;o&#39;, -5)</code> 返回 <code>4</code> ，因为它是从位置<code>0</code>处开始查找，然后 <code>o</code> 在位置<code>4</code>处被找到。另一方面，<code>&#39;hello world&#39;.indexOf(&#39;o&#39;, 11)</code> （或 <code>fromIndex</code> 填入任何大于<code>11</code>的值）将会返回 <code>-1</code> ，因为开始查找的位置<code>11</code>处，已经是这个字符串的结尾了。</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<p>查找的字符串 <code>searchValue</code> 的第一次出现的索引，如果没有找到，则返回 <code>-1</code>。</p>
<p>若被查找的字符串 <code>searchValue</code> 是一个空字符串，将会产生“奇怪”的结果。如果 <code>fromIndex</code> 值为空，或者 <code>fromIndex</code> 值小于被查找的字符串的长度，返回值和以下的 <code>fromIndex</code> 值一样</p>
<h3 id="6、Array-prototype-splice"><a href="#6、Array-prototype-splice" class="headerlink" title="6、Array.prototype.splice()"></a>6、Array.prototype.splice()</h3><p><strong>描述</strong></p>
<p>splice() 方法向/从数组中<code>添加</code>/<code>删除</code>项目，然后返回被删除的项目。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">array.splice(start<span class="comment">[, deleteCount<span class="comment">[, item1<span class="comment">[, item2<span class="comment">[, ...]</span>]</span>]</span>]</span>)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li><p><code>start</code></p>
<p>指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于<code>array.length-n</code>）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。</p>
</li>
<li><p><code>deleteCount</code> 可选</p>
<p>整数，表示要移除的数组元素的个数。</p>
<p>如果 <code>deleteCount</code> 大于 <code>start</code> 之后的元素的总数，则从 <code>start</code> 后面的元素都将被删除（含第 <code>start</code> 位）。</p>
<p>如果 <code>deleteCount</code> 被省略了，或者它的值大于等于<code>array.length - start</code>(也就是说，如果它大于或者等于<code>start</code>之后的所有元素的数量)，那么<code>start</code>之后数组的所有元素都会被删除。</p>
<p>如果 <code>deleteCount</code> 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。</p>
</li>
<li><p><code>item1, item2, *...*</code> 可选</p>
<p>要添加进数组的元素,从<code>start</code> 位置开始。如果不指定，则 <code>splice()</code> 将只删除数组元素。</p>
</li>
</ul>
<p><strong>返回值</strong></p>
<p>由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。</p>
<p><strong>注意</strong></p>
<p>该方法会改变原始数组。</p>
<h3 id="7、Array-prototype-map"><a href="#7、Array-prototype-map" class="headerlink" title="7、Array.prototype.map()"></a>7、Array.prototype.map()</h3><p><strong>map()</strong> 方法创建一个新数组(未修改原数组)，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</p>
<p><strong>语法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Return element for new_array </span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><em>callback</em></p>
<p>生成新数组元素的函数，使用三个参数：</p>
<ul>
<li><p><code>currentValue</code></p>
<p><code>callback</code> 数组中正在处理的当前元素。</p>
</li>
<li><p><code>index</code>可选</p>
<p><code>callback</code> 数组中正在处理的当前元素的索引。</p>
</li>
<li><p><code>array</code>可选</p>
<p><code>map</code> 方法调用的数组。</p>
</li>
</ul>
<p><code>thisArg</code>可选</p>
<p>执行 <code>callback</code> 函数时值被用作<code>this</code>。</p>
<p><strong>描述</strong></p>
<p><code>map</code> 方法会给原数组中的每个元素都按顺序调用一次  <code>callback</code> 函数。<code>callback</code> 每次执行后的返回值（包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>）组合起来形成一个新数组。 <code>callback</code> 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 <code>delete</code> 删除的索引则不会被调用。</p>
<p>因为<code>map</code>生成一个新数组，当你不打算使用返回的新数组却使用<code>map</code>是违背设计初衷的，请用<code>forEach</code>或者<code>for-of</code>替代。你不该使用<code>map</code>: A)你不打算使用返回的新数组，或/且 B) 你没有从回调函数中返回值。</p>
<p><code>callback</code> 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。</p>
<p>如果 <code>thisArg</code> 参数提供给<code>map</code>，则会被用作回调函数的<code>this</code>值。否则<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a>会被用作回调函数的<code>this</code>值。<code>this</code>的值最终相对于<code>callback</code>函数的可观察性是依据<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">the usual rules for determining the this seen by a function</a>决定的</p>
<p><code>map </code>不修改调用它的原数组本身（当然可以在 <code>callback</code> 执行时改变原数组）</p>
<p><code>map</code> 方法处理数组元素的范围是在 <code>callback</code> 方法第一次调用之前就已经确定了。调用<code>map</code>方法之后追加的数组元素不会被<code>callback</code>访问。如果存在的数组元素改变了，那么传给<code>callback</code>的值是<code>map</code>访问该元素时的值。在<code>map</code>函数调用后但在访问该元素前，该元素被删除的话，则无法被访问到。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map"><strong>示例见MDN</strong></a></p>
<ul>
<li>求数组中每个元素的平方根</li>
<li>使用 map 重新格式化数组中的对象</li>
<li>使用一个包含一个参数的函数来mapping(构建)一个数字数组</li>
<li>一般的<code>map</code> 方法(在一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>String</code></a> 上使用 map 方法获取字符串中每个字符所对应的 ASCII 码)</li>
</ul>
<h3 id="8、Array-prototype-filter"><a href="#8、Array-prototype-filter" class="headerlink" title="8、Array.prototype.filter()"></a>8、Array.prototype.filter()</h3><p><strong>filter()</strong> 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 </p>
<p>返回一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p>
<p><strong>语法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p><em>callback</em></p>
<p>用来测试数组的每个元素的函数。返回 <code>true</code> 表示该元素通过测试，保留该元素，<code>false</code> 则不保留。它接受以下三个参数：</p>
<ul>
<li><p><code>element</code></p>
<p>数组中当前正在处理的元素。</p>
</li>
<li><p><code>index</code>可选</p>
<p>正在处理的元素在数组中的索引。</p>
</li>
<li><p><code>array</code>可选</p>
<p>调用了 <code>filter</code> 的数组本身。</p>
</li>
</ul>
<p><code>thisArg</code>可选</p>
<p>执行 <code>callback</code> 时，用于 <code>this</code> 的值。</p>
<p><strong>描述</strong></p>
<p><code>filter</code> 为数组中的每个元素调用一次 <code>callback</code> 函数，并利用所有使得 <code>callback</code> 返回 true 或<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">等价于 true 的值</a>的元素创建一个新数组。<code>callback</code> 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 <code>callback</code> 测试的元素会被跳过，不会被包含在新数组中。</p>
<p><code>callback</code> 被调用时传入三个参数：</p>
<ol>
<li>元素的值</li>
<li>元素的索引</li>
<li>被遍历的数组本身</li>
</ol>
<p>如果为 <code>filter</code> 提供一个 <code>thisArg</code> 参数，则它会被作为 <code>callback</code> 被调用时的 <code>this</code> 值。否则，<code>callback</code> 的 <code>this</code> 值在非严格模式下将是全局对象，严格模式下为 <code>undefined</code>。<code>callback</code> 函数最终观察到的 <code>this</code> 值是根据<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">通常函数所看到的 “this”的规则</a>确定的。</p>
<p><code>filter</code> 不会改变原数组，它返回过滤后的新数组。</p>
<p><code>filter</code> 遍历的元素范围在第一次调用 <code>callback</code> 之前就已经确定了。在调用 <code>filter</code> 之后被添加到数组中的元素不会被 <code>filter</code> 遍历到。如果已经存在的元素被改变了，则他们传入 <code>callback</code> 的值是 <code>filter</code> 遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。</p>
<h3 id="9、Array-prototype-reduce"><a href="#9、Array-prototype-reduce" class="headerlink" title="9、Array.prototype.reduce()"></a>9、Array.prototype.reduce()</h3><blockquote>
<p>方法对数组中的每个元素执行一个由您提供的<strong>reducer</strong>函数(升序执行)，将其结果汇总为单个返回值。</p>
</blockquote>
<p><strong>语法</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MDN</span></span><br><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">accumulator, currentValue</span>) =&gt;</span> accumulator + currentValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce(reducer));</span><br><span class="line"><span class="comment">// expected output: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 + 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="built_in">console</span>.log(array1.reduce(reducer, <span class="number">5</span>));</span><br><span class="line"><span class="comment">// expected output: 15</span></span><br></pre></td></tr></table></figure>

<p><strong>reducer</strong> 函数接收4个参数:</p>
<ol>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)</li>
</ol>
<p><strong>reducer</strong> 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">其他具体用法参考MDN</a></p>
<h3 id="10、Array-prototype-find"><a href="#10、Array-prototype-find" class="headerlink" title="10、Array.prototype.find()"></a>10、Array.prototype.find()</h3><p><code>find()</code> 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 <code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">5</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> found = array1.find(<span class="function"><span class="params">element</span> =&gt;</span> element &gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(found);</span><br><span class="line"><span class="comment">// expected output: 12</span></span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find">MDN 官方解释</a></p>
<h3 id="11、Array-prototype-findIndex"><a href="#11、Array-prototype-findIndex" class="headerlink" title="11、Array.prototype.findIndex()"></a>11、Array.prototype.findIndex()</h3><p>它返回数组中找到的元素的<strong>值</strong>，而不是其索引。其他同上</p>
<h3 id="12、Array-prototype-includes"><a href="#12、Array-prototype-includes" class="headerlink" title="12、Array.prototype.includes()"></a>12、Array.prototype.includes()</h3><p><code>includes()</code> 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array1.includes(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pets = [<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;bat&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(pets.includes(<span class="string">&#x27;cat&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: true</span></span><br></pre></td></tr></table></figure>



<h2 id="Object-Function"><a href="#Object-Function" class="headerlink" title="Object Function"></a>Object Function</h2><h3 id="1-Object-assign"><a href="#1-Object-assign" class="headerlink" title="1. Object.assign()"></a>1. Object.assign()</h3><p>将所有可枚举的自身属性的值从一个或多个源对象复制到目标对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="built_in">Object</span>.assign(target, source);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target);</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(returnedTarget);</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-Object-create"><a href="#2-Object-create" class="headerlink" title="2. Object.create()"></a>2. Object.create()</h3><p>用指定的原型对象和属性创建一个新对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  isHuman: <span class="literal">false</span>,</span><br><span class="line">  printIntroduction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>. Am I human? <span class="subst">$&#123;<span class="built_in">this</span>.isHuman&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="built_in">Object</span>.create(person);</span><br><span class="line"></span><br><span class="line">me.name = <span class="string">&#x27;Matthew&#x27;</span>; <span class="comment">// &quot;name&quot; is a property set on &quot;me&quot;, but not on &quot;person&quot;</span></span><br><span class="line">me.isHuman = <span class="literal">true</span>; <span class="comment">// inherited properties can be overwritten</span></span><br><span class="line"></span><br><span class="line">me.printIntroduction();</span><br><span class="line"><span class="comment">// expected output: &quot;My name is Matthew. Am I human? true&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Object-keys"><a href="#3-Object-keys" class="headerlink" title="3. Object.keys()"></a>3. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"><code>Object.keys()</code></a></h3><p>返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// simple array</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(arr)); <span class="comment">// console: [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// console: [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object with random key ordering</span></span><br><span class="line"><span class="keyword">var</span> anObj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(anObj)); <span class="comment">// console: [&#x27;2&#x27;, &#x27;7&#x27;, &#x27;100&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFoo is a property which isn&#x27;t enumerable</span></span><br><span class="line"><span class="keyword">var</span> myObj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;</span><br><span class="line">  getFoo: &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">this</span>.foo; &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;);</span><br><span class="line">myObj.foo = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(myObj)); <span class="comment">// console: [&#x27;foo&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Object-values"><a href="#4-Object-values" class="headerlink" title="4. Object.values()"></a>4. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values"><code>Object.values()</code></a></h3><p>方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a>循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// [&#x27;bar&#x27;, 42]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj)); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object with random key ordering</span></span><br><span class="line"><span class="comment">// when we use numeric keys, the value returned in a numerical order according to the keys</span></span><br><span class="line"><span class="keyword">var</span> an_obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(an_obj)); <span class="comment">// [&#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="5-Object-entries"><a href="#5-Object-entries" class="headerlink" title="5. Object.entries()"></a>5. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><code>Object.entries()</code></a></h3><p>返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a> 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  a: <span class="string">&#x27;somestring&#x27;</span>,</span><br><span class="line">  b: <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(object1)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;], [&#x27;baz&#x27;, 42] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [ [&#x27;0&#x27;, &#x27;a&#x27;], [&#x27;1&#x27;, &#x27;b&#x27;], [&#x27;2&#x27;, &#x27;c&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// array like object with random key ordering</span></span><br><span class="line"><span class="keyword">const</span> anObj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(anObj)); <span class="comment">// [ [&#x27;2&#x27;, &#x27;b&#x27;], [&#x27;7&#x27;, &#x27;c&#x27;], [&#x27;100&#x27;, &#x27;a&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getFoo is property which isn&#x27;t enumerable</span></span><br><span class="line"><span class="keyword">const</span> myObj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123; <span class="attr">getFoo</span>: &#123; value() &#123; <span class="keyword">return</span> <span class="built_in">this</span>.foo; &#125; &#125; &#125;);</span><br><span class="line">myObj.foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(myObj)); <span class="comment">// [ [&#x27;foo&#x27;, &#x27;bar&#x27;] ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// non-object argument will be coerced to an object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(<span class="string">&#x27;foo&#x27;</span>)); <span class="comment">// [ [&#x27;0&#x27;, &#x27;f&#x27;], [&#x27;1&#x27;, &#x27;o&#x27;], [&#x27;2&#x27;, &#x27;o&#x27;] ]</span></span><br></pre></td></tr></table></figure>

<h3 id="6-删除对象属性"><a href="#6-删除对象属性" class="headerlink" title="6. 删除对象属性"></a>6. 删除对象属性</h3><p>通过<code>delete</code>操作符, 可以实现对对象属性的删除操作, 返回值是布尔</p>
<p><strong>注意：核心是 已声明的对象不可删除, 对象中的对象属性可以删除</strong></p>
<h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name =<span class="string">&#x27;zs&#x27;</span>  <span class="comment">//已声明的变量</span></span><br><span class="line"><span class="keyword">delete</span> name  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> name)  <span class="comment">//String</span></span><br><span class="line"></span><br><span class="line">age = <span class="number">19</span>  <span class="comment">//未声明的变量</span></span><br><span class="line"><span class="keyword">delete</span> age     <span class="comment">//true</span></span><br><span class="line"><span class="keyword">typeof</span> age <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.val = <span class="string">&#x27;fds&#x27;</span>  <span class="comment">//window下的变量</span></span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">this</span>.val      <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">this</span>.val)  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">//已声明的函数</span></span><br><span class="line"><span class="keyword">delete</span> fn    <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn)  <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line">fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">//未声明的函数</span></span><br><span class="line"><span class="keyword">delete</span> fn    <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> fn)  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="删除数组"><a href="#删除数组" class="headerlink" title="删除数组"></a>删除数组</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>]  <span class="comment">///已声明的数组</span></span><br><span class="line"><span class="keyword">delete</span> arr    <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr)  <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line">arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>]  <span class="comment">//未声明的数组</span></span><br><span class="line"><span class="keyword">delete</span> arr   <span class="comment">//true    </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr)   <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>]   <span class="comment">//已声明的数组</span></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">1</span>]  <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)   <span class="comment">//[&#x27;1&#x27;,&#x27;empty&#x27;,&#x27;3&#x27;] </span></span><br></pre></td></tr></table></figure>

<h4 id="删除对象"><a href="#删除对象" class="headerlink" title="删除对象"></a>删除对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  height: <span class="number">180</span>,</span><br><span class="line">  long: <span class="number">180</span>,</span><br><span class="line">  weight: <span class="number">180</span>,</span><br><span class="line">  hobby: &#123;</span><br><span class="line">    ball: <span class="string">&#x27;good&#x27;</span>,</span><br><span class="line">    music: <span class="string">&#x27;nice&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> person  <span class="comment">///false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person)   <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  height: <span class="number">180</span>,</span><br><span class="line">  long: <span class="number">180</span>,</span><br><span class="line">  weight: <span class="number">180</span>,</span><br><span class="line">  hobby: &#123;</span><br><span class="line">    ball: <span class="string">&#x27;good&#x27;</span>,</span><br><span class="line">    music: <span class="string">&#x27;nice&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> person.hobby  <span class="comment">///true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> person.hobby)  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="7-Object-is"><a href="#7-Object-is" class="headerlink" title="7. Object.is()"></a>7. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is()</code></a></h3><p><code>Object.is()</code> 方法判断两个值是否为<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness">同一个值</a>。如果满足以下条件则两个值相等:</p>
<ul>
<li>都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined"><code>undefined</code></a></li>
<li>都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null"><code>null</code></a></li>
<li>都是 <code>true</code> 或 <code>false</code></li>
<li>都是相同长度的字符串且相同字符按相同顺序排列</li>
<li>都是相同对象（意味着每个对象有同一个引用）</li>
<li>都是数字且<ul>
<li>都是 <code>+0</code></li>
<li>都是 <code>-0</code></li>
<li>都是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a></li>
<li>或都是非零而且非 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a> 且为同一个值</li>
</ul>
</li>
</ul>
<p>与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Equality"><code>==</code></a> 运算<em>不同。</em> <code>==</code> 运算符在判断相等前对两边的变量(如果它们不是同一类型) 进行强制转换 (这种行为的结果会将 <code>&quot;&quot; == false</code> 判断为 <code>true</code>), 而 <code>Object.is</code>不会强制转换两边的值。</p>
<p>与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators#Identity"><code>===</code></a> 运算也不相同。 <code>===</code> 运算符 (也包括 <code>==</code> 运算符) 将数字 <code>-0</code> 和 <code>+0</code> 视为相等 ，而将<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/NaN"><code>Number.NaN</code></a> 与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a>视为不相等.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a></p>
<p>将给定描述符描述的命名属性添加到对象。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties"><code>Object.defineProperties()</code></a></p>
<p>将给定描述符描述的命名属性添加到对象。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"><code>Object.freeze()</code></a></p>
<p>冻结对象。其他代码无法删除或更改其属性。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries"><code>Object.fromEntries()</code></a></p>
<p>从可迭代的<code>[key, value]</code>对中返回一个新对象。（这是的反向 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries"><code>Object.entries</code></a>）。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor"><code>Object.getOwnPropertyDescriptor()</code></a></p>
<p>返回对象的命名属性的属性描述符。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors"><code>Object.getOwnPropertyDescriptors()</code></a></p>
<p>返回一个包含对象自身所有属性描述符的对象。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames"><code>Object.getOwnPropertyNames()</code></a></p>
<p>返回一个数组，其中包含给定对象<strong>自己</strong>的所有可枚举和不可枚举属性的名称。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols"><code>Object.getOwnPropertySymbols()</code></a></p>
<p>返回直接在给定对象上找到的所有符号属性的数组。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf"><code>Object.getPrototypeOf()</code></a></p>
<p>返回<code>prototype</code>指定对象的。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible"><code>Object.isExtensible()</code></a></p>
<p>确定是否允许扩展对象。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen"><code>Object.isFrozen()</code></a></p>
<p>确定对象是否冻结。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed"><code>Object.isSealed()</code></a></p>
<p>确定对象是否密封。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions"><code>Object.preventExtensions()</code></a></p>
<p>防止对象的任何扩展。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal"><code>Object.seal()</code></a></p>
<p>防止其他代码删除对象的属性。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a></p>
<p>设置对象的原型（其内部<code>[[Prototype]]</code>属性）。</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a></p>
<p>指定创建对象原型的函数。</p>
<h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><h3 id="一、-JS中判断某个字符串是否包含另一个字符串的五种方法"><a href="#一、-JS中判断某个字符串是否包含另一个字符串的五种方法" class="headerlink" title="一、 JS中判断某个字符串是否包含另一个字符串的五种方法"></a>一、 JS中判断某个字符串是否包含另一个字符串的五种方法</h3><h4 id="String对象的方法"><a href="#String对象的方法" class="headerlink" title="String对象的方法"></a>String对象的方法</h4><p><strong>方法一: indexOf()  (推荐)</strong></p>
<figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line">var <span class="built_in">str</span> = <span class="string">&quot;123&quot;</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.indexOf(<span class="string">&quot;2&quot;</span>) != -<span class="number">1</span>);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。</p>
<p><strong>方法二:match()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="keyword">if</span> (str.match(reg))&#123;<span class="string">``</span> <span class="string">``</span><span class="comment">//包含；``&#125;</span></span><br></pre></td></tr></table></figure>

<p>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p>
<p><strong>方法三: search()</strong></p>
<figure class="highlight openscad"><table><tr><td class="code"><pre><span class="line">var <span class="built_in">str</span> = <span class="string">&quot;123&quot;</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">str</span>.<span class="built_in">search</span>( <span class="string">&quot;2&quot;</span> ) != -<span class="number">1</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。</p>
<h4 id="RegExp对象的方法"><a href="#RegExp对象的方法" class="headerlink" title="RegExp对象的方法"></a>RegExp对象的方法</h4><p><strong>方法四: test()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  str = <span class="string">&quot;123&quot;</span> </span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str) != <span class="number">-1</span>);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>test() 方法用于检索字符串中指定的值。返回 true 或 false。</p>
<p><strong>方法五:exec()</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123&quot;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="built_in">RegExp</span>(<span class="regexp">/3/</span>);</span><br><span class="line"><span class="keyword">if</span>(reg.exec(str))&#123;<span class="string">``</span> <span class="string">``</span><span class="comment">//包含；``&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>exec() 方法</strong>用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<h3 id="二、原生JS清空数组的三种方式"><a href="#二、原生JS清空数组的三种方式" class="headerlink" title="二、原生JS清空数组的三种方式"></a>二、原生JS清空数组的三种方式</h3><h4 id="1-splice函数"><a href="#1-splice函数" class="headerlink" title="1. splice函数"></a>1. splice函数</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">arrayObject.splice(index,howmany,element1,<span class="built_in">..</span><span class="built_in">..</span>.,elementX)</span><br></pre></td></tr></table></figure>

<p><code>index</code>：必选，规定从何处添加/删除元素。</p>
<p><code>howmany</code>：必选，规定应该删除多少元素。未规定此参数，则删除从 index 开始到原数组结尾的所有元素。</p>
<p><code>element1</code>:可选，规定要添加到数组的新元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];  </span><br><span class="line">arr.splice(<span class="number">0</span>,arr.length);  </span><br></pre></td></tr></table></figure>

<h4 id="2-给数组的length赋值为0"><a href="#2-给数组的length赋值为0" class="headerlink" title="2. 给数组的length赋值为0"></a>2. 给数组的length赋值为0</h4><p>该方法保留了数组其它属性。</p>
<p>赋予数组的长度小于本身的长度，数组中后面的元素将被截断。</p>
<p>赋予数组的长度大于本身的长度，将扩展数组长度，多的元素为undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];  </span><br><span class="line">arr.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>目前 Prototype中数组的 <a href="http://api.prototypejs.org/language/Array/prototype/clear/">clear</a> 和mootools库中数组的 <a href="http://mootools.net/docs/core/Types/Array#Array:empty">empty</a> 使用这种方式清空数组。</p>
<p>其它语言如Java，其数组的length是只读的，不能被赋值。如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int[] ary = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">ary.length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>Java中会报错，编译通不过。</p>
<h4 id="3-直接赋予新数组"><a href="#3-直接赋予新数组" class="headerlink" title="3. 直接赋予新数组 []"></a>3. 直接赋予新数组 []</h4><p>这种方式为将arr重新赋值为空数组，之前的数组如果没有被引用，将等待垃圾回收。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];  </span><br><span class="line">arr = [];</span><br></pre></td></tr></table></figure>

<h3 id="三、判断是否为字符串"><a href="#三、判断是否为字符串" class="headerlink" title="三、判断是否为字符串"></a>三、判断是否为字符串</h3><h4 id="1-基本方法"><a href="#1-基本方法" class="headerlink" title="1. 基本方法"></a>1. 基本方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span>(str)==<span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-利用JS原生函数"><a href="#2-利用JS原生函数" class="headerlink" title="2. 利用JS原生函数"></a>2. 利用JS原生函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString <span class="comment">// ƒ toString() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(str)==<span class="string">&quot;[object String]&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在<code>Object.prototype</code>这个this（上下文环境）中执行<code>toString</code>原生函数，会把里边的环境变量类型打印出来。</p>
<p><code>Object.prototype.toString()</code> –&gt;<code>执行结果</code>–&gt;<code>&quot;[object Object]&quot;</code></p>
</li>
<li><p>如果我们改变this（上下文环境），就能打印出当前环境变量类型，根据这个类型来判断。</p>
<p><code>Object.prototype.toString.call(str)</code> –&gt;<code>执行结果</code>–&gt;<code>&quot;[object String]&quot;</code></p>
</li>
</ul>
<h3 id="四、字符串转为数字的三种方法"><a href="#四、字符串转为数字的三种方法" class="headerlink" title="四、字符串转为数字的三种方法"></a>四、字符串转为数字的三种方法</h3><blockquote>
<p><strong>三种方法</strong>：转换函数、强制类型转换、利用js变量弱类型转换</p>
</blockquote>
<h4 id="1、转换函数："><a href="#1、转换函数：" class="headerlink" title="1、转换函数："></a>1、转换函数：</h4><p>js提供了 <code>parseInt()</code> 和 <code>parseFloat()</code> 两个转换函数。前者把值转换成整数，后者把值转换成浮点数。只有对String类型调用这些方法，这两个函数才能正确运行；对其他类型返回的都是NaN(Not a Number)。</p>
<p>一些示例 代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">//returns 1234</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">//returns 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;22.5&quot;</span>); <span class="comment">//returns 22</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;blue&quot;</span>); <span class="comment">//returns NaN</span></span><br></pre></td></tr></table></figure>

<p>parseInt()方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由parseInt()方法的第二个参数指定的，示例如下：</p>
<p>代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>); <span class="comment">//returns 175</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>); <span class="comment">//returns 2</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>); <span class="comment">//returns 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>); <span class="comment">//returns 10</span></span><br></pre></td></tr></table></figure>

<p>parseFloat()方法与parseInt()方法的处理方式相似。<br>使用parseFloat()方法的另一不同之处在于，字符串必须以十进制形式表示浮点数，parseFloat()没有基模式。</p>
<p>下面是使用parseFloat()方法的示例代码如下:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;1234blue&quot;</span>); <span class="comment">//returns 1234.0</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>); <span class="comment">//returns NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;22.5&quot;</span>); <span class="comment">//returns 22.5</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;22.34.5&quot;</span>); <span class="comment">//returns 22.34</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;0908&quot;</span>); <span class="comment">//returns 908</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;blue&quot;</span>); <span class="comment">//returns NaN</span></span><br></pre></td></tr></table></figure>

<h4 id="2、-强制类型转换"><a href="#2、-强制类型转换" class="headerlink" title="2、 强制类型转换"></a>2、 强制类型转换</h4><p>还可使用强制类型转换<code>（type casting）</code>处理转换值的类型。使用强制类型转换可以访问特定的值，即使它是另一种类型的。</p>
<p><strong>ECMAScript中可用的3种强制类型转换如下：</strong></p>
<ul>
<li>Boolean(value)——把给定的值转换成Boolean型；</li>
<li>Number(value)——把给定的值转换成数字（可以是整数或浮点数）；</li>
<li>String(value)——把给定的值转换成字符串。</li>
</ul>
<p>用这三个函数之一转换值，将创建一个新值，存放由原始值直接转换成的值。这会造成意想不到的后果。</p>
<p>当要转换的值是至少有一个字符的字符串、非0数字或对象时，Boolean()函数将返回true。如果该值是空字符串、数字0、undefined或null，它将返回false。</p>
<p>可以用下面的代码段测试Boolean型的强制类型转换，代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">&quot;&quot;</span>); <span class="comment">//false – empty string</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">&quot;hi&quot;</span>); <span class="comment">//true – non-empty string</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">100</span>); <span class="comment">//true – non-zero number</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>); <span class="comment">//false - null</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>); <span class="comment">//false - zero</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="keyword">new</span> <span class="built_in">Object</span>()); <span class="comment">//true – object</span></span><br></pre></td></tr></table></figure>

<p>Number()的强制类型转换与parseInt()和parseFloat()方法的处理方式相似，只是它转换的是整个值，而不是部分值。示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="number">0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="number">1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="number">0</span></span><br><span class="line"><span class="built_in">Number</span>( <span class="string">&quot;5.5 &quot;</span>) <span class="number">5.5</span></span><br><span class="line"><span class="built_in">Number</span>( <span class="string">&quot;56 &quot;</span>) <span class="number">56</span></span><br><span class="line"><span class="built_in">Number</span>( <span class="string">&quot;5.6.7 &quot;</span>) <span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Object</span>()) <span class="literal">NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">100</span>) <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>最后一种强制类型转换方法String()是最简单的，示例如下：</p>
<p>代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">String</span>(<span class="literal">null</span>); <span class="comment">//&quot;null&quot;</span></span><br><span class="line"><span class="keyword">var</span> oNull = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = oNull.toString(); <span class="comment">//won&#x27;t work, causes an error</span></span><br></pre></td></tr></table></figure>

<h4 id="3、利用js变量弱类型转换"><a href="#3、利用js变量弱类型转换" class="headerlink" title="3、利用js变量弱类型转换"></a>3、利用js变量弱类型转换</h4><p>代码如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">var</span> str= <span class="string">&#x27;012.345 &#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> x = str<span class="number">-0</span>;</span><br><span class="line">x = x*<span class="number">1</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>上例利用了js的弱类型的特点，只进行了算术运算，实现了字符串到数字的类型转换，不过这个方法还是不推荐的</p>
<h3 id="五、Javascript-遍历对象的方法"><a href="#五、Javascript-遍历对象的方法" class="headerlink" title="五、Javascript 遍历对象的方法"></a>五、<code>Javascript</code> 遍历对象的方法</h3><h4 id="1、-for-in"><a href="#1、-for-in" class="headerlink" title="1、 for......in"></a>1、 <code>for......in</code></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    id:<span class="number">1</span>,</span><br><span class="line">    name:<span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">    age:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key  <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">&#x27;---&#x27;</span> + obj[key])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">id--<span class="number">-1</span></span><br><span class="line">name---zhangsan</span><br><span class="line">age--<span class="number">-18</span></span><br></pre></td></tr></table></figure>

<h4 id="2、Object-keys-obj-和-Object-values-obj"><a href="#2、Object-keys-obj-和-Object-values-obj" class="headerlink" title="2、Object.keys(obj) 和 Object.values(obj)"></a>2、<code>Object.keys(obj)</code> 和 <code>Object.values(obj)</code></h4><h4 id="3、使用Object-getOwnPropertyNames-obj"><a href="#3、使用Object-getOwnPropertyNames-obj" class="headerlink" title="3、使用Object.getOwnPropertyNames(obj)"></a>3、使用<code>Object.getOwnPropertyNames(obj)</code></h4><h3 id="六、JS中动态追加属性"><a href="#六、JS中动态追加属性" class="headerlink" title="六、JS中动态追加属性"></a>六、JS中动态追加属性</h3><p>只有一种方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;&#125;;</span><br><span class="line">data[<span class="string">&#x27;key1&#x27;</span>] = <span class="string">&quot;哈哈哈&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态追加</span></span><br><span class="line"><span class="keyword">var</span> variable = <span class="string">&#x27;key2&#x27;</span>;</span><br><span class="line">data[variable] = <span class="string">&quot;嘿嘿嘿&quot;</span>;</span><br><span class="line">data.key3 = <span class="string">&quot;也行&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="七、Js查找数组中的元素"><a href="#七、Js查找数组中的元素" class="headerlink" title="七、Js查找数组中的元素"></a>七、Js查找数组中的元素</h3><h4 id="1、数组-Array-indexOf-方法"><a href="#1、数组-Array-indexOf-方法" class="headerlink" title="1、数组 Array.indexOf() 方法"></a>1、数组 <code>Array.indexOf()</code> 方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.indexOf(searchElement[, fromIndex])</span><br></pre></td></tr></table></figure>

<h4 id="2、数组-Array-find-方法"><a href="#2、数组-Array-find-方法" class="headerlink" title="2、数组 Array.find() 方法"></a>2、数组 <code>Array.find()</code> 方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.find(callback[, thisArg])</span><br></pre></td></tr></table></figure>

<h4 id="3、Array-includes-方法"><a href="#3、Array-includes-方法" class="headerlink" title="3、Array.includes() 方法"></a>3、<code>Array.includes()</code> 方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr.includes(valueToFind[, fromIndex])</span><br></pre></td></tr></table></figure>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>The Starting Point of Blogs</title>
    <url>/2020/08/18/The-Starting-Point-of-Blogs/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Moustache’s First Blog 介绍 <code>Hexo</code>+<code>Github Page</code>的步骤和遇到的问题，并在此列出参考的文章，衷心感谢。</p>
<ul>
<li><a href="https://blog.csdn.net/jiunian_2761/article/details/97388534">Hexo博客搭建记录（一）：本地搭建以及部署到Github</a></li>
<li><a href="https://blog.csdn.net/jiunian_2761/article/details/97388745Hexo">博客搭建记录（二）：基本主题设置以及美化</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30836436">Hexo+Next主题优化</a></li>
<li><a href="https://hexo.io/zh-cn/">Hexo官方文档</a></li>
</ul>
<a id="more"></a>

<h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h2><ul>
<li>Node.js</li>
<li>Npm</li>
<li>Git</li>
</ul>
<h2 id="二、配置本地Hexo"><a href="#二、配置本地Hexo" class="headerlink" title="二、配置本地Hexo"></a>二、配置本地Hexo</h2><h3 id="1-配置hexo全局控制命令"><a href="#1-配置hexo全局控制命令" class="headerlink" title="1.配置hexo全局控制命令"></a>1.配置hexo全局控制命令</h3><p>​    在cmd或者其他命令行工具下输入如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli </span><br></pre></td></tr></table></figure>

<h3 id="2-下载Hexo-工具"><a href="#2-下载Hexo-工具" class="headerlink" title="2.下载Hexo 工具"></a>2.下载Hexo 工具</h3><h4 id="2-1初始化博客目录"><a href="#2-1初始化博客目录" class="headerlink" title="2.1初始化博客目录"></a>2.1初始化博客目录</h4><p>在准备好的一个目录下存放自己的博客网站文件，例如我的是 <strong>/e/blog</strong>，也就是在E盘根目录新建了一个<strong>blog</strong>文件夹</p>
<p>然后我们进入该目录，点击鼠标右键，然后点击 <code>git bash</code> 出现一个命令窗口，接下来我们的大多数操作都用它来完成。</p>
<blockquote>
<p><code>Git Bash</code>在这里并不是唯一的选择，如您熟悉其他命令工具，也可以使用其他工具，这里使用<code>Git Bash</code>是为了减少更多不必要的麻烦</p>
</blockquote>
<p>在 <code>Git Bash</code>窗口下输入如下命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<p>按下回车Enter，<code>Git bash</code> 会自动下载相关文件</p>
<h4 id="2-2-本地生成运行"><a href="#2-2-本地生成运行" class="headerlink" title="2.2 本地生成运行"></a>2.2 本地生成运行</h4><p>在<code>Git Bash</code>窗口下，依次执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>这样，Hexo会默认运行在你本机的4000端口上，然后我们在浏览器中输入<code>http://localhost:4000</code>即可显示主题为<code>landscaped</code> 的页面</p>
<h2 id="三、部署到GitPage"><a href="#三、部署到GitPage" class="headerlink" title="三、部署到GitPage"></a>三、部署到GitPage</h2><blockquote>
<p>这个步骤开始前，请确保你已经注册了Github账号，且已经配置好了相关信息，配置方法请向上翻阅 <strong>二、安装Git</strong> 环节下。</p>
</blockquote>
<h3 id="1-在Github创建仓库。"><a href="#1-在Github创建仓库。" class="headerlink" title="1.在Github创建仓库。"></a>1.在Github创建仓库。</h3><p>打开 <a href="https://github.com/">Github官网</a> 登陆你的Github账号，点击页面右上角的 <code>+</code> 、<code>New repository</code>新建一个<code>repository</code>仓库</p>
<blockquote>
<p>为避免麻烦，这里仓库名必须按照<code>yourusername.github.io</code>规范填写，填写完仓库名后，我们点击<code>Create repository</code>按钮，然后等待其创建完成。复制该项目的HTTP链接<code>https://github.com/yourusername/yourusername.github.io.git</code></p>
</blockquote>
<blockquote>
<p><code>yourusername</code>指的就是你的github用户名，本文中出现的该字段都表示这个意思。</p>
</blockquote>
<h3 id="2-Hexo-配置"><a href="#2-Hexo-配置" class="headerlink" title="2.Hexo 配置"></a>2.Hexo 配置</h3><p>打开 <code>Git Bash</code> 切换到博客的根目录，输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install hexo-depolyer-git --save    </span><br></pre></td></tr></table></figure>

<p>然后输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure>

<p>进入站点配置文件编辑模式，我们向下翻到底部，可以看到 <code>depoly</code> 字段</p>
<p>在英文输入模式下，按键盘上的 <code>i</code>键进入编辑模式，将<code>depoly</code>字段编辑如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">          github: https:<span class="comment">//github.com/yourusername/yourusername.github.io.git</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>注意这里<code>:</code>后面一定要加空格，不然会出错。</p>
<p>然后我们按<code>Esc</code> 键，输入<code>:wq</code> 保存退出</p>
<h3 id="3-完成部署"><a href="#3-完成部署" class="headerlink" title="3.完成部署"></a>3.完成部署</h3><p>在命令行输入并执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>其中，<code>hexo d</code> 则是将本地文件推送到远程。</p>
<p>在第一次推送时，需要输入github  <code>userNam</code>e和<code>password</code></p>
<h2 id="四、使用Next主题"><a href="#四、使用Next主题" class="headerlink" title="四、使用Next主题"></a>四、使用Next主题</h2><h3 id="1-更改主题"><a href="#1-更改主题" class="headerlink" title="1. 更改主题"></a>1. 更改主题</h3><p><a href="https://hexo.io/themes/">Hexo主题库</a>可以找到更多主题，以下以Next为例</p>
<blockquote>
<p>在Hexo目录下有两份重要的配置文件，其名称都是<code>_config.yml</code> 。其中，一份位于站点根目录下，主要包含<code>Hexo</code>的自身配置，另一份位于主题目录下，主要用于配置主题相关的选项。<br>在接下来的描述中，我将前者称为 <strong>站点配置文件</strong>，后者称为 <strong>主题配置文件</strong> 。</p>
</blockquote>
<h4 id="1-1-安装Next"><a href="#1-1-安装Next" class="headerlink" title="1.1 安装Next"></a>1.1 安装Next</h4><p>安装Next主题的方式很简单，利用Git bash 在博客主目录下执行：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/theme-next/</span>hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<p>然后我们打开站点配置文件，将theme属性从默认值landscape改为next</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">theme: <span class="keyword">next</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>记住，所有的配置属性<code>:</code> 后面都要加一个空格,这样我们设定的值才会生效。</p>
</blockquote>
<h4 id="1-2-选择不同的Next主题样式"><a href="#1-2-选择不同的Next主题样式" class="headerlink" title="1.2 选择不同的Next主题样式"></a>1.2 选择不同的Next主题样式</h4><p>Next提供了四种主题风格scheme,可以在主题配置文件中配置：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="meta"># Scheme Settings</span></span><br><span class="line"><span class="meta"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="meta"># Schemes</span></span><br><span class="line"><span class="meta">#scheme: Muse</span></span><br><span class="line"><span class="meta">#scheme: Mist</span></span><br><span class="line"><span class="meta">#scheme: Pisces</span></span><br><span class="line">scheme: Gemini</span><br></pre></td></tr></table></figure>

<p>这里个人选择 <code>Gemini</code></p>
<h3 id="2-更改站点属性"><a href="#2-更改站点属性" class="headerlink" title="2. 更改站点属性"></a>2. 更改站点属性</h3><h4 id="2-1-更改网站名、语言、作者"><a href="#2-1-更改网站名、语言、作者" class="headerlink" title="2.1 更改网站名、语言、作者"></a>2.1 更改网站名、语言、作者</h4><p>打开站点配置文件，找到<code>site</code>字段，具体修改如下：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 设置网站属性信息</span></span><br><span class="line"><span class="meta"># Site:</span></span><br><span class="line"><span class="symbol">title:</span> 小白的博客 <span class="meta">#网站标题（博客站点名字）。</span></span><br><span class="line"><span class="symbol">subtitle:</span> 小小白 <span class="meta">#网站副标题，显示在标题下方</span></span><br><span class="line"><span class="symbol">description:</span> 我是小白 <span class="meta">#个人描述，类似签名，用于搜索引擎对站点的描述，建议在里面加上你的站点的关键词</span></span><br><span class="line"><span class="symbol">keywords:</span> </span><br><span class="line"><span class="symbol">author:</span> 小白 <span class="meta">#博客文章作者</span></span><br><span class="line"><span class="symbol">language:</span> <span class="built_in">zh</span>-CN  <span class="meta">#设置博客站点语言为中文</span></span><br><span class="line"><span class="symbol">timezone:</span>  <span class="meta">#设置时区，默认当前电脑时区 一般设置为 Asia/Shanghai</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-更改blog-favicon"><a href="#2-2-更改blog-favicon" class="headerlink" title="2.2 更改blog favicon"></a>2.2 更改blog favicon</h4><p>博客网站的图标可以在<a href="https://www.easyicon.net/">easyicon</a>、<a href="http://www.bitbug.net/">bitbug</a>、<a href="https://www.iconfont.cn/plus/user/detail?uid=41718">iconfont</a>等网站选择和制作，然后选择或者创建相应大小的图标文件，放置在blog/themes/next/sources/images目录下，并在主题配置文件中进行如下配置，只需要设置small和medium两个就可以：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">favicon:</span>  </span><br><span class="line"><span class="symbol">    small:</span> <span class="meta-keyword">/images/</span><span class="number">16</span>x16.png  </span><br><span class="line"><span class="symbol">    medium:</span> <span class="meta-keyword">/images/</span><span class="number">32</span>x32.png  </span><br><span class="line"><span class="symbol">    apple_touch_icon:</span> <span class="meta-keyword">/images/</span><span class="number">128</span>x128.png  </span><br><span class="line"><span class="symbol">    safari_pinned_tab:</span> <span class="meta-keyword">/images/</span>logo2.svg</span><br></pre></td></tr></table></figure>

<h3 id="3-菜单栏"><a href="#3-菜单栏" class="headerlink" title="3. 菜单栏"></a>3. 菜单栏</h3><h4 id="3-1-显示更多栏目"><a href="#3-1-显示更多栏目" class="headerlink" title="3.1 显示更多栏目"></a>3.1 显示更多栏目</h4><p>在主题配置文件中修改如下：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> / || home <span class="meta"># 首页</span></span><br><span class="line"><span class="symbol">  about:</span> <span class="meta-keyword">/about/</span> || user <span class="meta"># 关于</span></span><br><span class="line"><span class="symbol">  tags:</span> <span class="meta-keyword">/tags/</span> || tags <span class="meta"># 标签</span></span><br><span class="line"><span class="symbol">  categories:</span> <span class="meta-keyword">/categories/</span> || th <span class="meta"># 分类</span></span><br><span class="line"><span class="symbol">  archives:</span> <span class="meta-keyword">/archives/</span> || archive  <span class="meta"># 归档</span></span><br><span class="line">  <span class="meta"># schedule: /schedule/ || calendar # 日历</span></span><br><span class="line">  <span class="meta"># sitemap: /sitemap.xml || sitemap # 站点地图</span></span><br><span class="line">  <span class="meta"># commonweal: /404/ || heartbeat # 腾讯公益404</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-图标和内容量"><a href="#3-2-图标和内容量" class="headerlink" title="3.2 图标和内容量"></a>3.2 图标和内容量</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span> <span class="comment"># 是否显示各个页面的图标</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span> <span class="comment"># 是否显示分类/标签/归档页的内容量</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-添加分类、标签、关于菜单项"><a href="#3-3-添加分类、标签、关于菜单项" class="headerlink" title="3.3 添加分类、标签、关于菜单项"></a>3.3 添加分类、标签、关于菜单项</h4><p>首先打开主题下的配置文件_config.yml，然后搜索menu找到如下配置项，将about、tags、categories前的#号去掉，就开启了关于、标签和分类标签，当然还有其他菜单项也可以开启</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">menu:</span></span><br><span class="line"><span class="symbol">  home:</span> / || home</span><br><span class="line"><span class="symbol">  about:</span> <span class="meta-keyword">/about/</span> || user</span><br><span class="line"><span class="symbol">  tags:</span> <span class="meta-keyword">/tags/</span> || tags</span><br><span class="line"><span class="symbol">  categories:</span> <span class="meta-keyword">/categories/</span> || th</span><br><span class="line"><span class="symbol">  archives:</span> <span class="meta-keyword">/archives/</span> || archive</span><br><span class="line">  <span class="meta">#schedule: /schedule/ || calendar</span></span><br></pre></td></tr></table></figure>


<p>需运行如下命令新建相关页面</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hexo new<span class="built_in"> page </span><span class="string">&quot;about&quot;</span></span><br><span class="line">hexo new<span class="built_in"> page </span><span class="string">&quot;tags&quot;</span></span><br><span class="line">hexo new<span class="built_in"> page </span><span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure>

<p>打开各页面对应的index.md文件，编辑如下内容</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">title</span>: about  # 在页面中显示的title</span><br><span class="line"><span class="attribute">date</span>: <span class="number">2019</span>-<span class="number">06</span>-<span class="number">25</span> <span class="number">19</span>:<span class="number">16</span>:<span class="number">17</span></span><br><span class="line"><span class="attribute">type</span>: <span class="string">&quot;about&quot;</span>  # 为固定内容，其他对应  <span class="string">&quot;tags&quot;</span>  <span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后在发布的博文开头添加<code>tag</code>s和<code>categories</code>,如：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">title: The Starting Point of Blogs</span><br><span class="line">urlname: The Starting Point of Blogs</span><br><span class="line">date: 2020<span class="string">-08</span><span class="string">-18</span> 13:56:39</span><br><span class="line"><span class="keyword">tags:</span> [hexo部署,next使用]   #new</span><br><span class="line">categories: Tool&amp;Platform   #new</span><br></pre></td></tr></table></figure>

<h4 id="3-4-本地搜索"><a href="#3-4-本地搜索" class="headerlink" title="3.4 本地搜索"></a>3.4 本地搜索</h4><p>在你站点的根目录下</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>打开 <code>Hexo</code> 站点的 <code>_config.yml</code>,添加配置</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>打开 <code>themes/next/_config.yml</code> ,搜索关键字 <code>local_search</code> ,设置为 <code>true</code>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line"># Dependencies: https://github.com/flashlab/hexo-generator-search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  # if auto, trigger search by changing input</span><br><span class="line">  # if manual, trigger search by pressing enter key or search button</span><br><span class="line">  trigger: auto</span><br><span class="line">  # show top n results per article, show all results by setting to -1</span><br><span class="line">  top_n_per_article: 1</span><br></pre></td></tr></table></figure>

<h3 id="4-侧边栏"><a href="#4-侧边栏" class="headerlink" title="4. 侧边栏"></a>4. 侧边栏</h3><p>以下设置都是在 <strong>主题配置</strong> 文件中</p>
<h4 id="4-1-显示可跳转-日志-分类-标签页-的链接"><a href="#4-1-显示可跳转-日志-分类-标签页-的链接" class="headerlink" title="4.1 显示可跳转 日志 / 分类 / 标签页 的链接"></a>4.1 显示可跳转 日志 / 分类 / 标签页 的链接</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Posts / Categories / Tags in sidebar.</span></span><br><span class="line"><span class="attr">site_state:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="4-2-社交信息设置"><a href="#4-2-社交信息设置" class="headerlink" title="4.2 社交信息设置"></a>4.2 社交信息设置</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">social</span>:</span><br><span class="line">  <span class="attribute">GitHub</span>: <span class="attribute">https</span>:<span class="comment">//github.com/yourname || github</span></span><br><span class="line">  <span class="number">#E</span><span class="attribute">-Mail</span>: <span class="attribute">mailto</span>:yourname<span class="variable">@gmail</span>.com || envelope</span><br><span class="line">  <span class="attribute">Weibo</span>: <span class="attribute">https</span>:<span class="comment">//weibo.com/yourname || weibo</span></span><br><span class="line">  #<span class="attribute">Google</span>: <span class="attribute">https</span>:<span class="comment">//plus.google.com/yourname || google</span></span><br><span class="line">  #<span class="attribute">Twitter</span>: <span class="attribute">https</span>:<span class="comment">//twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="number">#FB</span> <span class="attribute">Page</span>: <span class="attribute">https</span>:<span class="comment">//www.facebook.com/yourname || facebook</span></span><br><span class="line">  #VK <span class="attribute">Group</span>: <span class="attribute">https</span>:<span class="comment">//vk.com/yourname || vk</span></span><br><span class="line">  #<span class="attribute">StackOverflow</span>: <span class="attribute">https</span>:<span class="comment">//stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  #<span class="attribute">YouTube</span>: <span class="attribute">https</span>:<span class="comment">//youtube.com/yourname || youtube</span></span><br><span class="line">  #<span class="attribute">Instagram</span>: <span class="attribute">https</span>:<span class="comment">//instagram.com/yourname || instagram</span></span><br><span class="line">  #<span class="attribute">Skype</span>: <span class="attribute">skype</span>:yourname?call|chat || skype</span><br></pre></td></tr></table></figure>

<p>Next 默认给出了一些模板，我们只要将其中的链接改为自己的链接就可以了，当然你也可以自己定义，格式为</p>
<p>名字: 链接 || 图标名，图标必须是<a href="http://fontawesome.dashgame.com/">FontAwesome</a>网站中能找到的图标名。</p>
<p>例如我添加我的博客地址：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="attr">qianfanguojin:</span> <span class="attr">https:</span><span class="comment">//qianfanguojin.github.io/ || codepen </span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-圆形头像设置"><a href="#4-3-圆形头像设置" class="headerlink" title="4.3 圆形头像设置"></a>4.3 圆形头像设置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># In theme directory (source/images): /images/avatar.gif</span></span><br><span class="line">  <span class="comment"># In site directory (source/uploads): /uploads/avatar.gif</span></span><br><span class="line">  <span class="comment"># You can also use other linking images.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span> <span class="comment">#头像文件目录</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span> <span class="comment">#设置鼠标放在头像上面是否旋转</span></span><br><span class="line">  <span class="comment"># If true, the avatar would be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span> <span class="comment">#头像是否设为圆形</span></span><br></pre></td></tr></table></figure>

<p>将自己喜欢的头像头像按照需求自己更换自己喜欢的就可以了，不过这里要注意一下头像可能会变成椭圆，如果头像是椭圆的，是因为图片不是一个正方形的图片，找到一个宽高像素一样的的图片即可。</p>
<h5 id="设置头像边框为圆形框"><a href="#设置头像边框为圆形框" class="headerlink" title="设置头像边框为圆形框"></a>设置头像边框为圆形框</h5><p>打开位于 <code>themes/next/source/css/_common/components/sidebar/sidebar-author.syl</code> 文件,修改如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line"> // 修改头像边框</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  -webkit-border-radius: 50%;</span><br><span class="line">  -moz-border-radius: 50%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-4-设置侧边栏社交图标"><a href="#4-4-设置侧边栏社交图标" class="headerlink" title="4.4 设置侧边栏社交图标"></a>4.4 设置侧边栏社交图标</h4><p>打开 <code>themes/next/_config.yml</code> 文件,搜索关键字 <code>social_icons</code> ，添加社交站点名称（注意大小写）图标，<a href="https://link.zhihu.com/?target=http://fontawesome.dashgame.com/">Font Awesome</a>图标</p>
<h4 id="4-5-RSS"><a href="#4-5-RSS" class="headerlink" title="4.5 RSS"></a>4.5 RSS</h4><p>在你 <code>Hexo</code> 站点目录下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>打开 <code>Hexo</code> 站点下的 <code>_config.yml</code> ,添加如下配置：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># feed</span><br><span class="line"># Dependencies: https://github.com/hexojs/hexo-generator-feed</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br></pre></td></tr></table></figure>

<h4 id="4-6-友情链接"><a href="#4-6-友情链接" class="headerlink" title="4.6 友情链接"></a>4.6 友情链接</h4><p>打开 <code>themes/next/_config.yml</code> 文件,搜索关键字 <code>Blog rolls</code>：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_title: 友情链接 #标题</span><br><span class="line">links_layout: block #布局，一行一个连接</span><br><span class="line">#links_layout: inline</span><br><span class="line">links: #连接</span><br><span class="line">  baidu: http://example.com/</span><br><span class="line">  google: http://example.com/</span><br></pre></td></tr></table></figure>

<h4 id="4-7-配置解读"><a href="#4-7-配置解读" class="headerlink" title="4.7 配置解读"></a>4.7 配置解读</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment">#自动生成目录</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span> <span class="comment">#自动产生目录编号</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span> <span class="comment">#标题过长是否换行</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">false</span> <span class="comment"># 是否显示所有等级的目录项。</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc. You can set it in one post through `toc_max_depth` in Front-matter.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span> <span class="comment">#最大标题嵌套个数</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position.#侧边栏的位置</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Manual define the sidebar width. If commented, will be default for:</span></span><br><span class="line">  <span class="comment"># Muse | Mist: 320</span></span><br><span class="line">  <span class="comment"># Pisces | Gemini: 240</span></span><br><span class="line">  <span class="comment">#width: 300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar Display (only for Muse | Mist), available values:</span></span><br><span class="line">  <span class="comment">#  - post    expand on posts automatically. Default.</span></span><br><span class="line">  <span class="comment">#  - always  expand for all pages automatically.</span></span><br><span class="line">  <span class="comment">#  - hide    expand only when click on the sidebar toggle icon.</span></span><br><span class="line">  <span class="comment">#  - remove  totally remove sidebar including sidebar toggle.</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span> <span class="comment"># 侧边栏相对主菜单的像素距离</span></span><br><span class="line">  <span class="comment"># Enable sidebar on narrow view (only for Muse | Mist).</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">false</span> <span class="comment">#在手机上侧边栏是否显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回顶部</span></span><br><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> </span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>  <span class="comment">#侧边栏显示返回顶部信息,默认显示在页面右下方</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="comment">#显示百分比</span></span><br></pre></td></tr></table></figure>

<h3 id="5-页面设置"><a href="#5-页面设置" class="headerlink" title="5. 页面设置"></a>5. 页面设置</h3><h4 id="5-1-鼠标点击红心"><a href="#5-1-鼠标点击红心" class="headerlink" title="5.1 鼠标点击红心"></a>5.1 鼠标点击红心</h4><p>目前网上大多数文章都是在<code>themes/next/source/js/src</code> 下新建文件，但笔者写这篇文章时最新版Next已经没有<code>src</code>文件夹了 ，于是，我们可以在<code>themes/next/source/js/</code>下新建<code>clicklove.js</code>内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params">e,t,a</span>)</span>&#123;<span class="function"><span class="keyword">function</span> <span class="title">n</span>(<span class="params"></span>)</span>&#123;c(<span class="string">&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;</span>),o(),r()&#125;<span class="function"><span class="keyword">function</span> <span class="title">r</span>(<span class="params"></span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> e=<span class="number">0</span>;e&lt;d.length;e++)d[e].alpha&lt;=<span class="number">0</span>?(t.body.removeChild(d[e].el),d.splice(e,<span class="number">1</span>)):(d[e].y--,d[e].scale+=<span class="number">.004</span>,d[e].alpha-=<span class="number">.013</span>,d[e].el.style.cssText=<span class="string">&quot;left:&quot;</span>+d[e].x+<span class="string">&quot;px;top:&quot;</span>+d[e].y+<span class="string">&quot;px;opacity:&quot;</span>+d[e].alpha+<span class="string">&quot;;transform:scale(&quot;</span>+d[e].scale+<span class="string">&quot;,&quot;</span>+d[e].scale+<span class="string">&quot;) rotate(45deg);background:&quot;</span>+d[e].color+<span class="string">&quot;;z-index:99999&quot;</span>);requestAnimationFrame(r)&#125;<span class="function"><span class="keyword">function</span> <span class="title">o</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> t=<span class="string">&quot;function&quot;</span>==<span class="keyword">typeof</span> e.onclick&amp;&amp;e.onclick;e.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;t&amp;&amp;t(),i(e)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">i</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;div&quot;</span>);a.className=<span class="string">&quot;heart&quot;</span>,d.push(&#123;<span class="attr">el</span>:a,<span class="attr">x</span>:e.clientX<span class="number">-5</span>,<span class="attr">y</span>:e.clientY<span class="number">-5</span>,<span class="attr">scale</span>:<span class="number">1</span>,<span class="attr">alpha</span>:<span class="number">1</span>,<span class="attr">color</span>:s()&#125;),t.body.appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> a=t.createElement(<span class="string">&quot;style&quot;</span>);a.type=<span class="string">&quot;text/css&quot;</span>;<span class="keyword">try</span>&#123;a.appendChild(t.createTextNode(e))&#125;<span class="keyword">catch</span>(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(<span class="string">&quot;head&quot;</span>)[<span class="number">0</span>].appendChild(a)&#125;<span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span><span class="string">&quot;rgb(&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;,&quot;</span>+~~(<span class="number">255</span>*<span class="built_in">Math</span>.random())+<span class="string">&quot;)&quot;</span>&#125;<span class="keyword">var</span> d=[];e.requestAnimationFrame=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">setTimeout</span>(e,<span class="number">1e3</span>/<span class="number">60</span>)&#125;&#125;(),n()&#125;(<span class="built_in">window</span>,<span class="built_in">document</span>);</span><br></pre></td></tr></table></figure>

<p>然后在修改<code>themes/next/layout/_layout.swig</code> 文件末尾添加</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.clicklove %&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/clicklove.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意</p>
<blockquote>
<p>很多人配置正确但不显示的原因主要出在这里，也就是<code>src</code> 后面的文件链接错误，hexo中使用的是相对路径，也就是说,只要你不指定为绝对路径,设置的链接都将是<code>root+url</code>的形式，一般来说，大多数用户默认的<code>root</code> 都为<code>/</code> ，但是有些情况，例如设置了Git Page ,要修改<code>root</code>的路径，<code>root</code>路径我们可以在 <strong>站点配置文件</strong> 中找到：</p>
</blockquote>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">\## <span class="keyword">If</span> your site <span class="keyword">is</span> put <span class="keyword">in</span> a subdirectory, <span class="keyword">set</span> url <span class="keyword">as</span> <span class="string">&#x27;http://yoursite.com/child&#x27;</span> <span class="keyword">and</span> root <span class="keyword">as</span> <span class="string">&#x27;/child/&#x27;</span></span><br><span class="line">url: http:<span class="comment">//yoursite.com</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line"> trailing_index: <span class="keyword">true</span> # <span class="keyword">Set</span> <span class="keyword">to</span> <span class="keyword">false</span> <span class="keyword">to</span> <span class="keyword">remove</span> trailing <span class="string">&#x27;index.html&#x27;</span> <span class="keyword">from</span> permalinks</span><br><span class="line"> trailing_html: <span class="keyword">true</span> # <span class="keyword">Set</span> <span class="keyword">to</span> <span class="keyword">false</span> <span class="keyword">to</span> <span class="keyword">remove</span> trailing <span class="string">&#x27;.html&#x27;</span> <span class="keyword">from</span> permalinks</span><br></pre></td></tr></table></figure>

<p><img data-src="problem1.jpg"></p>
<p>上图就是在我设置了Git Page后 <code>root</code>路径的值，在这种情况下，我们在修改<code>themes/next/layout/_layout.swig</code> 文件时，<code>src</code> 的路径都应该加上<code>root</code> 的路径值，因此，在这种情况下代码应修改为：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.clicklove %&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/fa/js/clicklove.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>

<p>确定无误后最后在主题配置文件末尾添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示页面红心</span></span><br><span class="line"><span class="attr">clicklove:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外还有一个效果，跟那个红心是差不多的（只能选一个），首先在<code>themes/next/source/js/src</code>里面建一个叫<code>fireworks.js</code>的文件，代码如下：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[<span class="number">-1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length<span class="number">-1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">&quot;#F00&quot;</span>,a.radius=<span class="number">0.1</span>,a.alpha=<span class="number">0.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">0.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">&quot;easeOutExpo&quot;</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">&quot;linear&quot;</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">&quot;easeOutExpo&quot;</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="built_in">this</span>,i=<span class="built_in">arguments</span>;<span class="built_in">clearTimeout</span>(a),a=<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">&quot;.fireworks&quot;</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">&quot;2d&quot;</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">&quot;mousedown&quot;</span>,colors=[<span class="string">&quot;#FF1461&quot;</span>,<span class="string">&quot;#18FF92&quot;</span>,<span class="string">&quot;#5A87FF&quot;</span>,<span class="string">&quot;#FBF38C&quot;</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">&quot;px&quot;</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">&quot;px&quot;</span>,canvasEl.getContext(<span class="string">&quot;2d&quot;</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">&quot;sidebar&quot;</span>!==e.target.id&amp;&amp;<span class="string">&quot;toggle-sidebar&quot;</span>!==e.target.id&amp;&amp;<span class="string">&quot;A&quot;</span>!==e.target.nodeName&amp;&amp;<span class="string">&quot;IMG&quot;</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>,setCanvasSize,!<span class="number">1</span>)&#125;<span class="string">&quot;use strict&quot;</span>;<span class="function"><span class="keyword">function</span> <span class="title">updateCoords</span>(<span class="params">e</span>)</span>&#123;pointerX=(e.clientX||e.touches[<span class="number">0</span>].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[<span class="number">0</span>].clientY-canvasEl.getBoundingClientRect().top&#125;<span class="function"><span class="keyword">function</span> <span class="title">setParticuleDirection</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">var</span> t=anime.random(<span class="number">0</span>,<span class="number">360</span>)*<span class="built_in">Math</span>.PI/<span class="number">180</span>,a=anime.random(<span class="number">50</span>,<span class="number">180</span>),n=[<span class="number">-1</span>,<span class="number">1</span>][anime.random(<span class="number">0</span>,<span class="number">1</span>)]*a;<span class="keyword">return</span>&#123;<span class="attr">x</span>:e.x+n*<span class="built_in">Math</span>.cos(t),<span class="attr">y</span>:e.y+n*<span class="built_in">Math</span>.sin(t)&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">createParticule</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=colors[anime.random(<span class="number">0</span>,colors.length<span class="number">-1</span>)],a.radius=anime.random(<span class="number">16</span>,<span class="number">32</span>),a.endPos=setParticuleDirection(a),a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">createCircle</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a=&#123;&#125;;<span class="keyword">return</span> a.x=e,a.y=t,a.color=<span class="string">&quot;#F00&quot;</span>,a.radius=<span class="number">0.1</span>,a.alpha=<span class="number">0.5</span>,a.lineWidth=<span class="number">6</span>,a.draw=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">Math</span>.PI,!<span class="number">0</span>),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=<span class="number">1</span>&#125;,a&#125;<span class="function"><span class="keyword">function</span> <span class="title">renderParticule</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> t=<span class="number">0</span>;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;<span class="function"><span class="keyword">function</span> <span class="title">animateParticules</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">for</span>(<span class="keyword">var</span> a=createCircle(e,t),n=[],i=<span class="number">0</span>;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;<span class="attr">targets</span>:n,<span class="attr">x</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.x&#125;,<span class="attr">y</span>:<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="keyword">return</span> e.endPos.y&#125;,<span class="attr">radius</span>:<span class="number">0.1</span>,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">&quot;easeOutExpo&quot;</span>,<span class="attr">update</span>:renderParticule&#125;).add(&#123;<span class="attr">targets</span>:a,<span class="attr">radius</span>:anime.random(<span class="number">80</span>,<span class="number">160</span>),<span class="attr">lineWidth</span>:<span class="number">0</span>,<span class="attr">alpha</span>:&#123;<span class="attr">value</span>:<span class="number">0</span>,<span class="attr">easing</span>:<span class="string">&quot;linear&quot;</span>,<span class="attr">duration</span>:anime.random(<span class="number">600</span>,<span class="number">800</span>)&#125;,<span class="attr">duration</span>:anime.random(<span class="number">1200</span>,<span class="number">1800</span>),<span class="attr">easing</span>:<span class="string">&quot;easeOutExpo&quot;</span>,<span class="attr">update</span>:renderParticule,<span class="attr">offset</span>:<span class="number">0</span>&#125;)&#125;<span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">e,t</span>)</span>&#123;<span class="keyword">var</span> a;<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> n=<span class="built_in">this</span>,i=<span class="built_in">arguments</span>;<span class="built_in">clearTimeout</span>(a),a=<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;e.apply(n,i)&#125;,t)&#125;&#125;<span class="keyword">var</span> canvasEl=<span class="built_in">document</span>.querySelector(<span class="string">&quot;.fireworks&quot;</span>);<span class="keyword">if</span>(canvasEl)&#123;<span class="keyword">var</span> ctx=canvasEl.getContext(<span class="string">&quot;2d&quot;</span>),numberOfParticules=<span class="number">30</span>,pointerX=<span class="number">0</span>,pointerY=<span class="number">0</span>,tap=<span class="string">&quot;mousedown&quot;</span>,colors=[<span class="string">&quot;#FF1461&quot;</span>,<span class="string">&quot;#18FF92&quot;</span>,<span class="string">&quot;#5A87FF&quot;</span>,<span class="string">&quot;#FBF38C&quot;</span>],setCanvasSize=debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;canvasEl.width=<span class="number">2</span>*<span class="built_in">window</span>.innerWidth,canvasEl.height=<span class="number">2</span>*<span class="built_in">window</span>.innerHeight,canvasEl.style.width=<span class="built_in">window</span>.innerWidth+<span class="string">&quot;px&quot;</span>,canvasEl.style.height=<span class="built_in">window</span>.innerHeight+<span class="string">&quot;px&quot;</span>,canvasEl.getContext(<span class="string">&quot;2d&quot;</span>).scale(<span class="number">2</span>,<span class="number">2</span>)&#125;,<span class="number">500</span>),render=anime(&#123;<span class="attr">duration</span>:<span class="number">1</span>/<span class="number">0</span>,<span class="attr">update</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;ctx.clearRect(<span class="number">0</span>,<span class="number">0</span>,canvasEl.width,canvasEl.height)&#125;&#125;);<span class="built_in">document</span>.addEventListener(tap,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="string">&quot;sidebar&quot;</span>!==e.target.id&amp;&amp;<span class="string">&quot;toggle-sidebar&quot;</span>!==e.target.id&amp;&amp;<span class="string">&quot;A&quot;</span>!==e.target.nodeName&amp;&amp;<span class="string">&quot;IMG&quot;</span>!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!<span class="number">1</span>),setCanvasSize(),<span class="built_in">window</span>.addEventListener(<span class="string">&quot;resize&quot;</span>,setCanvasSize,!<span class="number">1</span>)&#125;;</span><br></pre></td></tr></table></figure>

<p>打开<code>themes/next/layout/_layout.swig</code>,在<code>&lt;/body&gt;</code>上面写下如下代码：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.fireworks %&#125;</span><span class="xml">   <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">class</span>=<span class="string">&quot;fireworks&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span>    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//cdn.bootcss.com/animejs/2.2.0/anime.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/src/fireworks.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br></pre></td></tr></table></figure>

<p>打开主题配置文件，在里面最后写下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Fireworks</span></span><br><span class="line"><span class="attr">fireworks:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="5-2-添加动态背景"><a href="#5-2-添加动态背景" class="headerlink" title="5.2 添加动态背景"></a>5.2 添加动态背景</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置动态背景</span></span><br><span class="line"><span class="comment"># Canvas-nest</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-nest</span></span><br><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile or not</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">&quot;0,0,255&quot;</span> <span class="comment"># RGB values, use `,` to separate</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.5</span> <span class="comment"># the opacity of line: 0~1</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">170</span> <span class="comment"># the number of lines</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JavaScript 3D library.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-three</span></span><br><span class="line"><span class="attr">three:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">delay:</span> <span class="literal">false</span> <span class="comment"># Set true to further delay loading</span></span><br><span class="line">  <span class="attr">three_waves:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">canvas_lines:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">canvas_sphere:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Canvas-ribbon</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon</span></span><br><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">size:</span> <span class="number">300</span> <span class="comment"># The width of the ribbon</span></span><br><span class="line">  <span class="attr">alpha:</span> <span class="number">0.6</span> <span class="comment"># The transparency of the ribbon</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># The display level of the ribbon</span></span><br></pre></td></tr></table></figure>

<p>新版Next已经支持了上面三种动态背景方式，大家想用哪种就将该项的<code>enable</code> 设为 <code>true</code>,具体效果大家自己尝试，一般用的是第一种。</p>
<p>当然，指明要用那种，但是Next没有自带该动画的包，我们要自己下载，链接就在注释中<code># Dependencies</code> 项后面 ，例如我下载第一种：</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">git clone <span class="symbol">https:</span>/<span class="regexp">/github.com/theme</span>-<span class="keyword">next</span>/theme-<span class="keyword">next</span>-canvas-nest themes/<span class="keyword">next</span>/source/<span class="class"><span class="keyword">lib</span>/<span class="title">canvas</span>-<span class="title">nest</span></span></span><br></pre></td></tr></table></figure>

<p>链接后的是指定下载后放到的文件夹名，大家要注意是放在<code>lib</code> 下且文件夹名字应该和上面的设置项名字一样。</p>
<h5 id="个人使用了canvas-ribbon的背景，且优先使用cdn引入"><a href="#个人使用了canvas-ribbon的背景，且优先使用cdn引入" class="headerlink" title="个人使用了canvas-ribbon的背景，且优先使用cdn引入"></a>个人使用了<code>canvas-ribbon</code>的背景，且优先使用cdn引入</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_ribbon:</span></span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"> <span class="attr">size:</span> <span class="number">300</span> <span class="comment"># The width of the ribbon</span></span><br><span class="line"> <span class="attr">alpha:</span> <span class="number">0.4</span> <span class="comment"># The transparency of the ribbon</span></span><br><span class="line"> <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># The display level of the ribbon</span></span><br></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">\<span class="comment"># Internal version: 1.0.0</span></span><br><span class="line">canvas_ribbon: <span class="regexp">//</span>cdn.jsdelivr.net<span class="regexp">/gh/</span>theme-<span class="keyword">next</span><span class="regexp">/theme-next-canvas-    ribbon@1/</span>canvas-ribbon.js</span><br><span class="line">\<span class="comment"># canvas_ribbon:</span></span><br></pre></td></tr></table></figure>

<h4 id="5-3-博客底部基本布局"><a href="#5-3-博客底部基本布局" class="headerlink" title="5.3 博客底部基本布局"></a>5.3 博客底部基本布局</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 博客底部布局</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="comment">#since: 2015 #设置建站时间，不设置则默认为当前年份</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">heart</span>  <span class="comment"># 作者图标，默认为author，自定义的图标需来自fontawesome中</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span>  <span class="comment"># 图标是否闪动</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#808080&quot;</span> <span class="comment"># 图标颜色</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="string">小白</span> <span class="comment">#设置底部显示的名字，默认为站点配置文件的author名字</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 是否显示 Powered By Hexo</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span> <span class="comment"># 是否显示 Hexo 版本</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 是否显示主题信息</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span> <span class="comment"># 是否显示主题版本</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian ICP information for Chinese users. See: http://www.beian.miit.gov.cn</span></span><br><span class="line">  <span class="attr">beian:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span> <span class="comment"># 是否显示网站备案信息</span></span><br><span class="line">    <span class="attr">icp:</span></span><br></pre></td></tr></table></figure>

<h4 id="5-4-底部显示busuanzi博客访客-访问次数统计"><a href="#5-4-底部显示busuanzi博客访客-访问次数统计" class="headerlink" title="5.4 底部显示busuanzi博客访客/访问次数统计"></a>5.4 底部显示busuanzi博客访客/访问次数统计</h4><p>修改主题配置文件内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不蒜子统计功能</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 是否开启busuanzi统计功能</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span> <span class="comment"># 是否统计总访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span> <span class="comment"># 访客数图标</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span> <span class="comment"># 是否显示同级总访问次数</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span> <span class="comment"># 总访问次数的图标</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span> <span class="comment"># 是否显示单个文章查看次数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span> <span class="comment"># 文章被查看次数的图标</span></span><br></pre></td></tr></table></figure>

<h4 id="5-5-右上角显示Github标识"><a href="#5-5-右上角显示Github标识" class="headerlink" title="5.5 右上角显示Github标识"></a>5.5 右上角显示Github标识</h4><p>修改主题配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `Follow me on GitHub` banner in the top-right corner.</span></span><br><span class="line"><span class="comment"># Github 跳转图标</span></span><br><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 功能开关</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/yourname</span> <span class="comment"># Github主页地址</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span> <span class="comment"># 鼠标悬停显示的文字</span></span><br></pre></td></tr></table></figure>

<h4 id="5-6-接入网易云播放器"><a href="#5-6-接入网易云播放器" class="headerlink" title="5.6 接入网易云播放器"></a>5.6 接入网易云播放器</h4><p>首先在网易云音乐网页端搜索你想播放的音乐（有版权保护的不行）</p>
<p>在网易云客户端点击生成外链播放器，得到外链的html代码：</p>
<p>后我们将代码粘贴到一个合适的位置，建议在侧边栏，对应的文件是<code>themes/next/layout/_macro/sidebar.swig</code> ，不同的位置效果呈现的效果不同，例如我的：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;site-overview-wrap sidebar-panel&#123;% if not display_toc or toc(page.content).length &lt;= 1 %&#125; sidebar-panel-active&#123;% endif %&#125;&quot;</span>&gt;</span>         <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;site-overview&quot;</span>&gt;</span>            </span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; <span class="name"><span class="builtin-name">partial</span></span>(<span class="name">&#x27;_partials/sidebar/site-overview.swig&#x27;</span>, &#123;&#125;, &#123;cache: theme.cache.enable&#125;) &#125;&#125;</span><span class="xml">                      </span></span><br><span class="line"><span class="xml">    &#123;% for inject_item in theme.injects.sidebar %&#125;             </span></span><br><span class="line"><span class="xml">    </span><span class="template-variable">&#123;&#123; <span class="name"><span class="builtin-name">partial</span></span>(<span class="name">inject_item.layout</span>, inject_item.locals, inject_item.options) &#125;&#125;</span><span class="xml">           &#123;% endfor %&#125;         </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>         </span></span><br><span class="line"><span class="xml"><span class="comment">&lt;!--网易云链接--&gt;</span>         </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="5-7-浏览页面的时候显示当前浏览进度"><a href="#5-7-浏览页面的时候显示当前浏览进度" class="headerlink" title="5.7 浏览页面的时候显示当前浏览进度"></a>5.7 浏览页面的时候显示当前浏览进度</h4><p>打开 <code>themes/next/_config.yml</code> ,搜索关键字 <code>scrollpercent</code> ,把 <code>false</code> 改为 <code>true</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Scroll percent label in b2t button</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>

<p>如果想把 <code>top</code>按钮放在侧边栏,打开 <code>themes/next/_config.yml</code> ,搜索关键字 <code>b2t</code> ,把 <code>false</code> 改为 <code>true</code>。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Back to top in sidebar</span><br><span class="line">  b2t: true</span><br><span class="line"></span><br><span class="line">  # Scroll percent label in b2t button</span><br><span class="line">  scrollpercent: true</span><br></pre></td></tr></table></figure>

<h4 id="5-8-添加顶部加载条"><a href="#5-8-添加顶部加载条" class="headerlink" title="5.8 添加顶部加载条"></a>5.8 添加顶部加载条</h4><p>打开 <code>themes/next/_config.yml</code> ，搜索关键字 <code>pace</code> ,设置为 <code>true</code> ,可以更换加载样式：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Dependencies: https:<span class="regexp">//gi</span>thub.com<span class="regexp">/theme-next/</span>theme-<span class="keyword">next</span>-pace</span><br></pre></td></tr></table></figure>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Progress bar in the top during page loading.</span><br><span class="line">pace: true</span><br><span class="line"># Themes list:</span><br><span class="line">#pace-theme-big-counter</span><br><span class="line">#pace-theme-bounce</span><br><span class="line">#pace-theme-barber-shop</span><br><span class="line">#pace-theme-center-atom</span><br><span class="line">#pace-theme-center-circle</span><br><span class="line">#pace-theme-center-radar</span><br><span class="line">#pace-theme-center-simple</span><br><span class="line">#pace-theme-corner-indicator</span><br><span class="line">#pace-theme-fill-left</span><br><span class="line">#pace-theme-flash</span><br><span class="line">#pace-theme-loading-bar</span><br><span class="line">#pace-theme-mac-osx</span><br><span class="line">#pace-theme-minimal</span><br><span class="line"># For example</span><br><span class="line"># pace_theme: pace-theme-center-simple</span><br><span class="line">pace_theme: pace-theme-flash #替换更换样式</span><br></pre></td></tr></table></figure>

<h4 id="5-9-自定义鼠标样式"><a href="#5-9-自定义鼠标样式" class="headerlink" title="5.9 自定义鼠标样式"></a>5.9 自定义鼠标样式</h4><p>打开 <code>themes/next/source/css/_custom/custom.styl</code> ,在里面写下如下代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// 鼠标样式</span><br><span class="line">  * &#123;</span><br><span class="line">      cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important</span><br><span class="line">  &#125;</span><br><span class="line">  :active &#123;</span><br><span class="line">      cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>其中 url 里面必须是 ico 图片，ico 图片可以上传到网上（我是使用七牛云图床），然后获取外链，复制到 url 里就行了</p>
<h3 id="6-文章内容相关"><a href="#6-文章内容相关" class="headerlink" title="6 文章内容相关"></a>6 文章内容相关</h3><h4 id="6-1-文章摘要显示（显示阅读全文按钮）"><a href="#6-1-文章摘要显示（显示阅读全文按钮）" class="headerlink" title="6.1 文章摘要显示（显示阅读全文按钮）"></a>6.1 文章摘要显示（显示阅读全文按钮）</h4><ul>
<li><p>自动形成摘要模式</p>
<p>打开主题配置文件，修改内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span> <span class="comment"># 截取的内容长度</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># Read more button</span></span><br><span class="line"><span class="comment"># If true, the read more button would be displayed in excerpt section.</span></span><br><span class="line"><span class="attr">read_more_btn:</span> <span class="literal">true</span> <span class="comment"># 是否显示阅读全文按钮  </span></span><br></pre></td></tr></table></figure>

<p>但是这样的方式不够自由，我们可以使用如下方式：</p>
</li>
</ul>
<h4 id="6-2-代码块设置"><a href="#6-2-代码块设置" class="headerlink" title="6.2 代码块设置"></a>6.2 代码块设置</h4><p>使用参照如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码块设置</span></span><br><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="comment"># 代码块主题, 可选的值为 normal; night; night eighties; night blue; night bright</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span></span><br><span class="line">  <span class="comment"># Add copy_button on codeblock</span></span><br><span class="line">  <span class="comment"># 显示复制按钮</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span>  <span class="comment"># 按钮显示格式</span></span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>代码块样式的具体内容可以查看<a href="http://theme-next.iissnan.com/theme-settings.html#syntax-highlight-scheme">官方文档</a></p>
<h4 id="6-3-添加打赏"><a href="#6-3-添加打赏" class="headerlink" title="6.3 添加打赏"></a>6.3 添加打赏</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Reward (Donate)</span></span><br><span class="line"><span class="comment"># 打赏设置</span></span><br><span class="line"><span class="attr">reward_settings:</span></span><br><span class="line">  <span class="comment"># If true, reward would be displayed in every article by default.</span></span><br><span class="line">  <span class="comment"># You can show or hide reward in a specific article throuth `reward: true | false` in Front-matter.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span> <span class="comment"># 功能开关</span></span><br><span class="line">  <span class="attr">animation:</span> <span class="literal">true</span> <span class="comment"># 动画</span></span><br><span class="line">  <span class="comment">#comment: Donate comment here.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="comment">#wechatpay: /images/wechatpay.png # 微信捐赠二维码图片</span></span><br><span class="line">  <span class="comment">#alipay: /images/alipay.png # 支付宝捐赠二维码图片</span></span><br><span class="line">  <span class="comment">#bitcoin: /images/bitcoin.png # 比特币</span></span><br></pre></td></tr></table></figure>

<h4 id="6-4-添加版权信息"><a href="#6-4-添加版权信息" class="headerlink" title="6.4 添加版权信息"></a>6.4 添加版权信息</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/share-your-work/licensing-types-examples</span></span><br><span class="line"><span class="comment"># Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line"><span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span> <span class="comment"># 许可协议</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span> <span class="comment"># 侧边栏显示</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span> <span class="comment"># 文章底部显示</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<p>注意</p>
<blockquote>
<p>版权信息中的本文链接 由主题配置中的   <code>url</code>   控制</p>
</blockquote>
<h4 id="6-5-自定义文章底部版权声明"><a href="#6-5-自定义文章底部版权声明" class="headerlink" title="6.5 自定义文章底部版权声明"></a>6.5 自定义文章底部版权声明</h4><p>效果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">作者：Dragonstyle</span><br><span class="line">链接：http://www.dragonstyle.win/2017/09/06/Android-Studio个人设置/</span><br><span class="line">來源：简书</span><br><span class="line">版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处！</span><br></pre></td></tr></table></figure>

<p>在目录 <code>themes/next/layout/_macro/</code> 下添加 <code>my-copyright.swig</code> ,内容如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% if page.copyright %&#125;</span><br><span class="line">&lt;div class=&quot;my_post_copyright&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!-- JS库 sweetalert 可修改路径 --&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:mm:ss&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:mm:ss&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &lt;span class=&quot;copy-path&quot;  title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot;  aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt;  </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt; </span><br><span class="line">    var clipboard = new Clipboard(&#x27;.fa-clipboard&#x27;);</span><br><span class="line">    clipboard.on(&#x27;success&#x27;, $(function()&#123;</span><br><span class="line">      $(&quot;.fa-clipboard&quot;).click(function()&#123;</span><br><span class="line">        swal(&#123;   </span><br><span class="line">          title: &quot;&quot;,   </span><br><span class="line">          text: &#x27;复制成功&#x27;,   </span><br><span class="line">          html: false,</span><br><span class="line">          timer: 500,   </span><br><span class="line">          showConfirmButton: false</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>在目录 <code>themes/next/source/css/_common/components/post/</code> 下添加 <code>my-post-copyright.styl</code>,内容如下:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.my_post_copyright &#123;</span><br><span class="line">  width: 85%;</span><br><span class="line">  max-width: 45em;</span><br><span class="line">  margin: 2.8em auto 0;</span><br><span class="line">  padding: 0.5em 1.0em;</span><br><span class="line">  border: 1px solid #d3d3d3;</span><br><span class="line">  font-size: 0.93rem;</span><br><span class="line">  line-height: 1.6em;</span><br><span class="line">  word-break: break-all;</span><br><span class="line">  background: rgba(255,255,255,0.4);</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright p&#123;margin:0;&#125;</span><br><span class="line">.my_post_copyright span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 5.2em;</span><br><span class="line">  color: #333333; // title color</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .raw &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  border-bottom:0;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a:hover &#123;</span><br><span class="line">  color: #0593d3; // link color</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright:hover .fa-clipboard &#123;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .post-url:hover &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 1em;</span><br><span class="line">  +mobile()&#123;display:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path:hover &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 <code>themes/next/layout/_macro/post.swig</code> ,在代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;% include &#x27;wechat-subscriber.swig&#x27; %&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line"> &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>之前添加增加如下代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">      &#123;% if not is_index %&#125;</span><br><span class="line">        &#123;% include &#x27;my-copyright.swig&#x27; %&#125;</span><br><span class="line">      &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>修改 <code>themes/next/source/css/_common/components/post/post.styl</code> 文件，在最后一行增加代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">@import &quot;my-post-copyright&quot;</span><br></pre></td></tr></table></figure>

<p>设置新建文章自动开启</p>
<p><code>copyright</code>,即新建文章自动显示自定义的版权声明,设置 <code>your site/scaffolds/post.md</code>文件</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">categories:</span><br><span class="line">copyright: true #新增,开启</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="6-6-添加图片"><a href="#6-6-添加图片" class="headerlink" title="6.6 添加图片"></a>6.6 添加图片</h4><ol>
<li><p><strong>设置站点配置<code>_config.yml</code></strong>:将<code>post_asset_folder: false</code>改为<code>post_asset_folder: true</code></p>
</li>
<li><p><strong>安装插件</strong>：在hexo根目录打开Git Bash,执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>运行<code>hexo n &quot;XXXXXX&quot;</code></strong>,生成XXXXX.md博文时就会在<code>/source/_posts</code>目录下生成XXXXXX的文件夹，将你想在XXXXX博文中插入的照片放置到这个同名文件夹中即可，图片的命名随意。</p>
</li>
<li><p><strong>添加图片</strong>:在想添加的位置写入<code>![](图片名字.图片格式)</code>,例如<code>![](1.png)</code></p>
</li>
</ol>
<h4 id="6-7-添加文章结束提示语"><a href="#6-7-添加文章结束提示语" class="headerlink" title="6.7 添加文章结束提示语"></a>6.7 添加文章结束提示语</h4><blockquote>
<p>提示：原文章中此处出现问题</p>
</blockquote>
<p><img data-src="problem2.png"></p>
<p><strong>核心代码</strong>：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> not is_index %&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;color: #ccc;font-size:14px;display:flex;justify-content:center;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display:inline-block;&quot;</span>&gt;</span>------ 今天只会更爱哈尼 <span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color:#f17c67;margin:0 5px;display:inline-block;animation: iconAnimate 1.33s ease-in-out infinite;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-heart&quot;</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;display:inline-block;&quot;</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span>The End of This Article------<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果你想简单一点实现，直接复制这段代码，然后将其插入到 <code>themes/next/layout/_macro/post.swig</code> 文件的如下位置：</li>
</ul>
<p><img data-src="problem2-1.png"></p>
<p>当然，我们大多时候对功能都需要一个灵活性，也就是可以开关。为了实现这样的效果，我们先在<code>themes/next/layout/_macro/</code> 新建 <code>passage-end-tag.swig</code> 文件，将上面的 <strong>核心代码</strong> 添加进去。<br>然后我们修改<code>themes/next/layout/_macro/post.swig</code> 文件 ，将上面简单实现的代码替换成：</p>
<figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 文章结束表示语--&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> not is_index %&#125;</span></span><br><span class="line"><span class="xml">        </span><span class="template-tag">&#123;% <span class="name"><span class="name">include</span></span> &#x27;passage-end-tag.swig&#x27; %&#125;</span></span><br><span class="line"><span class="xml">      </span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>然后，我们在主题配置文件末尾添加：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文章结束提示语</span></span><br><span class="line"><span class="attr">passage_end_tag:</span> </span><br><span class="line"> <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>我们就可以在这里将其设为<code>true</code> 或 <code>false</code> 来控制其显示。</p>
<blockquote>
<p>个人在配置的时候，使用<code>&lt;i class=&quot;fa fa-heart-o&quot; aria-hidden=&quot;true&quot;&gt;</code>一直不被解析，没找到原因，换了一个图标就显示了</p>
</blockquote>
<blockquote>
<p>另外一个问题，如果出现乱码的情况<br><strong>解决办法</strong>：首先是把乱码部分对应的文件用写字板打开，转换其编码格式为<code>UTF-8</code></p>
</blockquote>
<blockquote>
<p>最后一个应该注意的是，结束语是居中显示，需要注意左右两面内容的实际长度一致，否则很丑</p>
</blockquote>
<h4 id="6-8-添加博客字数和阅读时间统计功能"><a href="#6-8-添加博客字数和阅读时间统计功能" class="headerlink" title="6.8 添加博客字数和阅读时间统计功能"></a>6.8 添加博客字数和阅读时间统计功能</h4><p>首先在站点根目录下配置依赖：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-symbols-<span class="keyword">count</span>-<span class="built_in">time</span> <span class="comment">--save</span></span><br></pre></td></tr></table></figure>

<p>然后再站点配置文件中加入以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span> <span class="comment">#是否统计字数</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span> <span class="comment">#是否统计阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span> <span class="comment">#是否统计总字数</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span> <span class="comment">#是否统计总阅读时长</span></span><br></pre></td></tr></table></figure>

<p>最后在主题配置文件中修改为以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字数及访问时间统计</span></span><br><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">separated_meta:</span> <span class="literal">true</span>  <span class="comment">#分隔线</span></span><br><span class="line">  <span class="attr">item_text_post:</span> <span class="literal">true</span>  <span class="comment">#文章中的显示是否显示文本</span></span><br><span class="line">  <span class="attr">item_text_total:</span> <span class="literal">true</span>       <span class="comment">#网页底部的显示是否显示文本</span></span><br><span class="line">  <span class="attr">awl:</span> <span class="number">2</span> <span class="comment">#平均每个字符的长度</span></span><br><span class="line">  <span class="attr">wpm:</span> <span class="number">275</span> <span class="comment"># 设定每分钟可阅读的字符数</span></span><br></pre></td></tr></table></figure>

<h4 id="6-9-修改-tag-图标"><a href="#6-9-修改-tag-图标" class="headerlink" title="6.9 修改 tag 图标"></a>6.9 修改 tag 图标</h4><p>默认的 <code>tag</code> 样式为 <code>#</code> 不带图标，我们可以改成使用图标</p>
<p>新版Next 已经帮我们集成了这个功能，我们只要在主题配置文件中修改：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Use icon instead of the symbol # to indicate the tag at the bottom of the post </span></span><br><span class="line"><span class="comment"># 使用标签图标 </span></span><br><span class="line"><span class="attr">tag_icon:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="6-10-设置博客摘要显示"><a href="#6-10-设置博客摘要显示" class="headerlink" title="6.10 设置博客摘要显示"></a>6.10 设置博客摘要显示</h4><p>首先我们需要开启摘要功能，修改主题配置文件：参考该<a href="https://jiangding1990.github.io/2017/04/25/Hexo%E4%BD%BF%E7%94%A8NexT%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%A1%B5%E6%98%BE%E7%A4%BA%E6%96%87%E7%AB%A0%E6%91%98%E8%A6%81%E6%96%B9%E6%B3%95/">方法</a></p>
<h5 id="solution-1-在文章中使用进行手动截断-推荐"><a href="#solution-1-在文章中使用进行手动截断-推荐" class="headerlink" title="solution 1     在文章中使用进行手动截断(推荐)"></a>solution 1     在文章中使用进行手动截断(<strong>推荐</strong>)</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="solution-2-在文章中的front-matter中添加description，并提供文章摘要"><a href="#solution-2-在文章中的front-matter中添加description，并提供文章摘要" class="headerlink" title="solution 2     在文章中的front-matter中添加description，并提供文章摘要"></a>solution 2     在文章中的<code>front-matter</code>中添加<code>description</code>，并提供文章摘要</h5><p>这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。使用这种方法也可以实现首页文章部分显示的效果</p>
<p>方法如下图所示：</p>
<p><img data-src="problem3.png"></p>
<h5 id="solution-3-自动生成摘要"><a href="#solution-3-自动生成摘要" class="headerlink" title="solution 3     自动生成摘要"></a>solution 3     自动生成摘要</h5><p>想要自动生成文章摘要，需在<code>主题配置</code>文件中添加以下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>

<p>其中的<code>length</code>值为摘要所截取的字符长度。</p>
<h4 id="6-11-设置文章英文链接"><a href="#6-11-设置文章英文链接" class="headerlink" title="6.11 设置文章英文链接"></a>6.11 设置文章英文链接</h4><p>hexo生成的默认文章链接格式为<code>： :year/:month/:day/:title/</code>，这种默认的配置缺点很明显，当文件名是中文的时候url链接里就有中文出现。<br> 可以通过添加<code>urlname</code>字段实现文章的链接为英文，在md文件的Front-matter区域新增<code>urlname</code>属性，值为文章的英文title，参考如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">---</span></span><br><span class="line"><span class="selector-tag">title</span>: 基于<span class="selector-tag">Hexo</span>+<span class="selector-tag">Next</span>的主题优化总结</span><br><span class="line"><span class="selector-tag">urlname</span>: <span class="selector-tag">summary-of-theme-optimization-based-on-hexo</span>&amp;<span class="selector-tag">next</span></span><br><span class="line"><span class="selector-tag">date</span>: 2019<span class="selector-tag">-07-12</span> 20<span class="selector-pseudo">:01</span><span class="selector-pseudo">:26</span></span><br><span class="line"><span class="selector-tag">categories</span>:</span><br><span class="line">  <span class="selector-tag">-</span> 工具</span><br><span class="line"><span class="selector-tag">tags</span>: </span><br><span class="line">  <span class="selector-tag">-</span> <span class="selector-tag">Hexo</span></span><br><span class="line"><span class="selector-tag">---</span></span><br></pre></td></tr></table></figure>

<p>再将博客配置文件下的<code>permalink</code>值改为：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:urlname/</span></span><br></pre></td></tr></table></figure>

<h4 id="6-12-Markdown首行缩进"><a href="#6-12-Markdown首行缩进" class="headerlink" title="6.12 Markdown首行缩进"></a>6.12 Markdown首行缩进</h4><p>在段落开头，输入以下字符，然后紧跟着输入文本即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&amp;<span class="selector-id">#160</span>; &amp;<span class="selector-id">#160</span>; &amp;<span class="selector-id">#160</span>; &amp;<span class="selector-id">#160</span>;</span><br></pre></td></tr></table></figure>

<h4 id="6-13-Markdown转义字符"><a href="#6-13-Markdown转义字符" class="headerlink" title="6.13 Markdown转义字符"></a>6.13 Markdown转义字符</h4><p>md中用到的主要可能有语法意义的非空白符号有：\ ` * _ { } [ ] ( ) # + - . !<br> 在正常段落中要原样输出以上符号，一般需要加反斜杠\在前（连续两个反斜杠输出一个反斜杠。</p>
<h4 id="6-14-修改文章间分割线"><a href="#6-14-修改文章间分割线" class="headerlink" title="6.14 修改文章间分割线"></a>6.14 修改文章间分割线</h4><p>打开 <code>themes/next/source/css/_common/components/post/post-eof.styl</code> ,修改：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.posts-expand &#123;</span><br><span class="line">  .post-eof &#123;</span><br><span class="line">    display: block;</span><br><span class="line">  //  margin: $post-eof-margin-top auto $post-eof-margin-bottom;  </span><br><span class="line">    width: 0%; //分割线长度</span><br><span class="line">    height: 0px; // 分割线高度</span><br><span class="line">    background: $grey-light;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-15-博文置顶"><a href="#6-15-博文置顶" class="headerlink" title="6.15 博文置顶"></a>6.15 博文置顶</h4><p>打开 <code>Hexo</code> 站点下 <code>node_modules/hexo-generator-index/lib/generator.js</code> 文件。代码全部替换为：(next 5.1以后主题已自带此功能)</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;;</span><br><span class="line">var pagination = require(&#x27;hexo-pagination&#x27;);</span><br><span class="line">module.exports = function(locals)&#123;</span><br><span class="line">  var config = this.config;</span><br><span class="line">  var posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class="line">            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; // 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">  var paginationDir = config.pagination_dir || &#x27;page&#x27;;</span><br><span class="line">  return pagination(&#x27;&#x27;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&#x27;index&#x27;, &#x27;archive&#x27;],</span><br><span class="line">    format: paginationDir + &#x27;/%d/&#x27;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>打开文章添加top字段,设置数值，数值越大文章越靠前：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: layout</span><br><span class="line">title: 标签1</span><br><span class="line">date: 2017-08-18 15:41:18</span><br><span class="line">tags: 标签1</span><br><span class="line">top: 100</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h4 id="6-16-文章顶部显示更新时间"><a href="#6-16-文章顶部显示更新时间" class="headerlink" title="6.16 文章顶部显示更新时间"></a>6.16 文章顶部显示更新时间</h4><p>打开主题配置文件 <code>_config.yml</code> ,搜索关键字 <code>updated_at</code> 设置为 <code>true</code> ：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Post meta display settings</span><br><span class="line">post_meta:</span><br><span class="line">  item_text: true</span><br><span class="line">  created_at: true</span><br><span class="line">  updated_at: ture</span><br><span class="line">  categories: true</span><br></pre></td></tr></table></figure>

<p>编辑文章,增加关键字<code>updated</code>（next可以根据文章改变时间自动更改）</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout: layout</span><br><span class="line">title: 关于</span><br><span class="line">date: 2017-08-18 15:41:18</span><br><span class="line">updated: 2017-09-05 20:18:54 #手动添加更新时间</span><br></pre></td></tr></table></figure>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Tool &amp; Platform</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ES3-ES5</title>
    <url>/2020/10/20/es3-es5/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>总结了一些ES3-ES5的基本语法知识</p>
<p>–  数据类型</p>
<p>–  内置对象</p>
<p>–  定时器</p>
</blockquote>
<a id="more"></a>

<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><p><strong>请注意：ES6的数据类型有8种</strong></p>
<p>在ES5的时候，我们认知的数据类型确实是 6种：<strong>Number、String、Boolean、undefined、object、Null</strong>。</p>
<p>ES6 中新增了一种 <code>Symbol</code> 。<strong>这种类型的对象永不相等，即始创建的时候传入相同的值，可以解决属性名冲突的问题，做为标记。</strong></p>
<p><em>Chrome67版本</em>  中还出现了一种 <code>bigInt</code>。 Javascript 中的<strong>任意精度整数，可以安全存储和操作大整数。即始超出 Number 能够表示的安全整数范围。</strong></p>
<p><span style="color:red;font-weight:bold;">JS 的数据类型有几种？</span></p>
<p> 8种。Number、String、Boolean、Null、undefined、object、symbol、bigInt</p>
<p><span style="color:red;font-weight:bold;">Object 中包含了哪几种类型？</span></p>
<p>其中包含了Data、function、Array等，这三种是常规用的。</p>
<p><span style="color:red;font-weight:bold;">JS的基本类型和引用类型有哪些呢？</span></p>
<p>基本类型（单类型）：除Object。 String、Number、boolean、null、undefined。</p>
<p>引用类型：object。里面包含的 function、Array、Date。</p>
<p><span style="color:red;font-weight:bold;">null 和 undefined 有什么区别？</span></p>
<p><code>Null</code> 只有一个值，是 null。不存在的对象。</p>
<p><code>Undefined</code> 只有一个值，是undefined。没有初始化；undefined 是从 null 中派生出来的。</p>
<p> <em>简单理解就是</em>：undefined 是没有定义的，null 是定义了但是为空。</p>
<p><span style="color:red;font-weight:bold;">null 不存在的原因是什么？如何解决？</span></p>
<p>不存在的原因是：</p>
<p>​         1､方法不存在</p>
<p>​         2､对象不存在</p>
<p>​         3､字符串变量不存在</p>
<p>​         4､接口类型对象没初始化 </p>
<p>解决方法：</p>
<p>​         做判断处理的时候，放在设定值的最前面</p>
<p><span style="color:red;font-weight:bold;">== 和 === 有什么区别，什么场景下使用？</span></p>
<p><strong>双等号==（相同）：</strong> </p>
<p>（1）如果两个值类型相同，再进行三个等号(===)的比较</p>
<p>（2）如果两个值类型不同，也有可能相等，需根据以下规则进行类型转换在比较：</p>
<p>　　　　1）如果一个是null，一个是undefined，那么相等</p>
<p>　　　　2）如果一个是字符串，一个是数值，把字符串转换成数值之后再进行比较</p>
<p><strong>三等号===（严格相同）:</strong></p>
<p>（1）如果类型不同，就一定不相等</p>
<p>（2）如果两个都是数值，并且是同一个值，那么相等；如果其中至少一个是NaN，那么不相等。（判断一个值是否是NaN，只能使用isNaN( ) 来判断）</p>
<p>（3）如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等。</p>
<p>（4）如果两个值都是true，或是false，那么相等</p>
<p>（5）如果两个值都引用同一个对象或是函数，那么相等，否则不相等</p>
<p>（6）如果两个值都是null，或是undefined，那么相等</p>
<p><em>简单理解就是</em>  当进行双等号比较时候： 先检查两个操作数数据类型，如果相同， 则进行<code>===</code>比较， 如果不同， 则愿意为你进行一次类型转换， 转换成相同类型后再进行比较， 而<code>===</code>比较时， 如果类型不同，直接就是false</p>
<p><span style="color:red;font-weight:bold;">对象可以比较吗？</span></p>
<p>对象是可以比较，遍历比较key 和 value就行， <code>Object.is(value1, value2)</code></p>
<p><span style="color:red;font-weight:bold;">如何判断数据类型？</span></p>
<p>1､<code>typeof</code> 操作符（通用：上面有内容有讲到）</p>
<p>2､<code>toString ( )</code>  将其他类型转成 string 的方法</p>
<p>  支持：number、boolean、string、object </p>
<p>  不支持：null 、undefined</p>
<p>3､<code>toLocaleString ( )</code>  把数组转成本地字符串 </p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> arr = [<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>];</span><br><span class="line">  arr.toLocaleString()</span><br><span class="line">&lt;- <span class="string">&quot;1,2,3,4&quot;</span></span><br></pre></td></tr></table></figure>

<p>4､检测数组类型的方法      </p>
<p>   ① <code>instanceof</code>  操作符</p>
<p>   ②对象的 <code>constructor</code> 属性</p>
<p>   ③ <code>Array.isArray( )</code> 检验值是否为数组</p>
<br>

<h2 id="二、内置对象"><a href="#二、内置对象" class="headerlink" title="二、内置对象"></a>二、内置对象</h2><p>在JS里，一切皆为或者皆可以被用作对象。可通过new一个对象或者直接以字面量形式创建变量（如<code>var i=&quot;aaa&quot;</code>)，所有变量都有对象的性质。</p>
<p><strong>注意：通过字面量创建的对象在调用属性和方法时会被对象包装器暂时包装成一个对象，具有对象的性质。</strong>如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;我不是一个真的对象&quot;</span>;</span><br><span class="line">alert(str.length);   <span class="comment">//str被暂时包装成一个String对象，可调用该对象的属性和方法</span></span><br></pre></td></tr></table></figure>

<p>不过这并不意味着它就是一个对象了，<code>typeof(str)的值为仍String</code>。</p>
<p>而通过new的对象，如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;aaa&quot;</span>)；</span><br><span class="line"><span class="keyword">typeof</span>(<span class="string">&quot;str&quot;</span>)==<span class="built_in">Object</span>;<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>下面为所有内置对象（其实除了Math及全局对象，其余的为构造函数）   </p>
<h3 id="1、全局对象"><a href="#1、全局对象" class="headerlink" title="1、全局对象"></a>1、全局对象</h3><p><strong>属性:</strong></p>
<ul>
<li><p>Infinity   指定一个正负无穷大的数值</p>
</li>
<li><p>NaN    指定一个 “非数字” 值</p>
</li>
<li><p>undefined  指定一个未被赋值的变</p>
<p><strong>方法:</strong></p>
</li>
<li><p>decodeURI()    为加密的URI进行解码</p>
</li>
<li><p>decodeURIComponent() 为加密的URI组件解码</p>
</li>
<li><p>encodeURI()    将字符串加密为URI</p>
</li>
<li><p>encodeURIComponent() 将字符串加密为URI组件</p>
</li>
<li><p>escape(string)   加密一个字符串</p>
</li>
<li><p>使用escape()对一个字符串进行解码</p>
</li>
<li><p>eval_r(string)    判断一个字符串并将其以脚本代码的形式执行</p>
</li>
<li><p>isFinite(number)   检测一个值是否为一个有限数字,返回True或False</p>
</li>
<li><p>isNaN(string)   检测一个值是否不是一个有限数字</p>
</li>
<li><p>Number()     将一个对象的值转换为一个数字</p>
</li>
<li><p>parseFloat(string)  将一个字符串解析为一个浮点数字</p>
</li>
<li><p>parseInt(string)   将一个字符串解析为一个整数,不是四舍五入操作,而是切尾</p>
</li>
<li><p>String(object)   将一个对象值转换为一个字符串</p>
</li>
<li><p>number(object)</p>
</li>
</ul>
<h3 id="2、Number"><a href="#2、Number" class="headerlink" title="2、Number"></a>2、Number</h3><p><strong>属性:</strong></p>
<ul>
<li>MAX_VALUE    The largest possible value a number in JavaScript can have 1.7976931348623157E+308</li>
<li>MIN_VALUE    The smallest possible value a number in JavaScript can have 5E-324</li>
<li>NaN     Equal to a value that is not a number.</li>
<li>NEGATIVE_INFINITY A value that is less than MIN_VALUE.</li>
<li>POSOTIVE_INFINITY A value that is greater than MAX_VALUE.</li>
<li>prototype    A static property of the Number object</li>
</ul>
<p><strong>方法:</strong></p>
<ul>
<li>toString    Returns a string representing the specified object</li>
<li>valueOf()   返回数学对象的原始值</li>
</ul>
<h3 id="3、Boolean"><a href="#3、Boolean" class="headerlink" title="3、Boolean"></a>3、Boolean</h3><p><strong>属性:</strong></p>
<ul>
<li>constructor 所建立对象的函数参考</li>
<li>prototype  能够为对象加入的属性和方法</li>
</ul>
<p><strong>方法:</strong></p>
<ul>
<li>toSource()  显示对象的源代码</li>
<li>toString()  将布尔值转换为字符串,并且返回结果</li>
<li>valueOf()  返回布尔对象的原始值</li>
</ul>
<h3 id="4、String"><a href="#4、String" class="headerlink" title="4、String"></a>4、String</h3><p><strong>属性:</strong></p>
<ul>
<li>constructor 所建立对象的函数参考</li>
<li>prototype  能够为对象加入的属性和方法</li>
<li>length   返回字符串的字符长度</li>
</ul>
<p><strong>方法 :</strong></p>
<blockquote>
<p>anchor(“name”)用来把字符串转换为HTML锚点标记内(&lt;A NAME=&gt;)</p>
<p>big()   把字符串中的文本变成大字体(<code>&lt;BIG&gt;</code>)</p>
<p>blink()   把字符串中的文本变成闪烁字体(<code>&lt;BLINK&gt;</code>)</p>
<p>bold()   把字符串中的文本变成黑字体(<code>&lt;B&gt;</code>)</p>
<p>fixed()   把字符串中的文本变成固定间距字体,即电报形式(<code>&lt;TT&gt;</code>)</p>
<p>fontcolor(color)设置字符串中文本的颜色(<code>&lt;FONT COLOR=&gt;</code>)</p>
<p>Fontsize(size) 把字符串中的文本变成指定大小(<code>&lt;FONTSIZE=&gt;</code>)</p>
<p>italics()  把字符串中的文本变成斜字体(<code>&lt;I&gt;</code>)</p>
<p>Link(url)用来把字符串转换-HTML链接标记中(<code>&lt;A HREF=&gt;</code>)</p>
<p>small()   把字符串中的文本变成小字体(<code>&lt;SMALL&gt;</code>)</p>
<p>strike()   把字符串中的文本变成划掉字体(<code>&lt;STRIKE&gt;</code>)</p>
<p>sub()   把字符串中的文本变成下标(subscript)字体(<code>&lt;SUB&gt;</code>)</p>
<p>sup()   把字符串中的文本变成上标(superscript)字体(<code>&lt;SUP&gt;</code>)</p>
</blockquote>
<ul>
<li>charAt(index) 返回指定索引处的字符</li>
<li>charCodeAt(index)返回一个整数,该整数表示String对象中指定位置处的字符的Unicode编码</li>
<li>concat(string2)连接两条或多条字符串</li>
<li>fromCharCode(num1, num2, …, numN)获取指定的Unicode值并返回字符串</li>
<li>indexOf(searchString, startIndex) 返回字符串中第一个出现指定字符串的位置</li>
<li>lastlndexOf(searchString, startIndex) 返回字符串中最后一个出现指定字符串的位置</li>
<li>match(regex) 在字符串中查找指定值</li>
<li>replace(regex, newString)将字符串中的某些字符替换成其它字符</li>
<li>search(regex) 针对某执行值对字符串进行查找</li>
<li>slice(startIndex, endIndex)将部分字符抽出并在新的字符串中返回剩余部分</li>
<li>split(delimiter)将字符串分配为数组</li>
<li>substr(startIndex, length) 从startIndex取,取length个字符</li>
<li>substring(startIndex, endIndex) 从startIndex和endIndex之间的字符,不包括endIndex</li>
<li>toLowerCase() 把字符串中的文本变成小写</li>
<li>toUpperCase() 把字符串中的文本变成大写</li>
<li>toSource()  显示对象的源代码</li>
<li>valueOf()  返回字符串对象的原始值</li>
</ul>
<h3 id="5、Array"><a href="#5、Array" class="headerlink" title="5、Array"></a>5、Array</h3><p><strong>属性:</strong></p>
<ul>
<li>constructor 所建立对象的函数参考</li>
<li>prototype  能够为对象加入的属性和方法</li>
<li>index   For an array created by a regular expression match, the zero-based index of the match in the string.</li>
<li>input   For an array created by a regular expression match, reflects the original string against which the regular expression was matched.</li>
<li>length   获取数组元素的个数,即最大下标加1</li>
</ul>
<p><strong>方法:</strong></p>
<ul>
<li>concat(array1,arrayn)将两个或两个以上的数组值连接起来,合并后返回结果</li>
<li>join(string) 将数组中元素合并为字符串,string为分隔符.如省略参数则直接合并,不再分隔</li>
<li>pop()   移除数组中的最后一个元素并返回该元素</li>
<li>push(value) 在数组的末尾加上一个或多个元素,并且返回新的数组长度值</li>
<li>reverse()  颠倒数组中元素的顺序,反向排列</li>
<li>shift()   移除数组中的第一个元素并返回该元素</li>
<li>slice(start,end)   可从已有的数组中返回选定的元素</li>
<li>sort(compare Function) 在未指定排序号的情况下,按照元素的字母顺序排列,如果不是字符串类型则转换成字符串再排序,返回排序后的数组</li>
<li>splice()   为数组删除并添加新的元素</li>
<li>toSource()  显示对象的源代码</li>
<li>toString()  将数组所有元素返回一个字符串,其间用逗号分隔</li>
<li>unshift(value)为数组的开始部分加上一个或多个元素,并且返回该数组的新长度</li>
<li>valueOf()  返回数组对象的原始值</li>
</ul>
<h3 id="6、Object"><a href="#6、Object" class="headerlink" title="6、Object"></a>6、Object</h3><p><strong>属性:</strong></p>
<ul>
<li>constructor Specifies the function that creates an object’s prototype.</li>
<li>prototype  Allows the addition of properties to all objects.</li>
</ul>
<h3 id="7、Function"><a href="#7、Function" class="headerlink" title="7、Function"></a>7、Function</h3><p><strong>属性:</strong></p>
<ul>
<li>arguments  An array corresponding to the arguments passed to a function.</li>
<li>arity   Indicates the number of arguments expected by the function.</li>
<li>caller   Specifies which function called the current function.</li>
<li>prototype  Allows the addition of properties to a Function object.</li>
</ul>
<p><strong>方法:</strong></p>
<ul>
<li>toString   Returns a string representing the specified object.</li>
</ul>
<h3 id="8、Date"><a href="#8、Date" class="headerlink" title="8、Date"></a>8、Date</h3><p><strong>属性:</strong></p>
<ul>
<li>constructor   所建立对象的函数参考</li>
<li>prototype    能够为对象加入的属性和方法</li>
</ul>
<p><strong>方法:</strong></p>
<ol>
<li>getDay()    返回一周中的第几天(0-6)</li>
<li>getYear()    返回年份.2000年以前为2位,2000(包含)以后为4位</li>
<li>getFullYear()   返回完整的4位年份数</li>
<li>getMonth()   返回月份数(0-11)</li>
<li>getDate()    返回日(1-31)</li>
<li>getHours()    返回小时数(0-23)</li>
<li>getMinutes()   返回分钟(0-59)</li>
<li>getSeconds()   返回秒数(0-59)</li>
<li>getMilliseconds() 返回毫秒(0-999)</li>
<li>getUTCDay()   依据国际时间来得到现在是星期几(0-6)</li>
<li>getUTCFullYear()  依据国际时间来得到完整的年份</li>
<li>getUTCMonth()   依据国际时间来得到月份(0-11)</li>
<li>getUTCDate()   依据国际时间来得到日(1-31)</li>
<li>getUTCHours()   依据国际时间来得到小时(0-23)</li>
<li>getUTCMinutes()  依据国际时间来返回分钟(0-59)</li>
<li>getUTCSeconds()  依据国际时间来返回秒(0-59)</li>
<li>getUTCMilliseconds()依据国际时间来返回毫秒(0-999)</li>
<li>getTime()    返回从1970年1月1号0:0:0到现在一共花去的毫秒数</li>
<li>getTimezoneoffset() 返回时区偏差值,即格林威治平均时间(GMT)与运行脚本的计算机所处时区设置之间相差的分钟数)</li>
<li>parse(dateString)  返回在Date字符串中自从1970年1月1日00:00:00以来的毫秒数</li>
<li>setYear(yearInt)  设置年份.2位数或4位数</li>
<li>setFullYear(yearInt)设置年份.4位数</li>
<li>setMonth(monthInt) 设置月份(0-11)</li>
<li>setDate(dateInt)  设置日(1-31)</li>
<li>setHours(hourInt) 设置小时数(0-23)</li>
<li>setMinutes(minInt) 设置分钟数(0-59)</li>
<li>setSeconds(secInt) 设置秒数(0-59)</li>
<li>setMilliseconds(milliInt) 设置毫秒(0-999)</li>
<li>setUTCFullYear(yearInt) 依据国际时间来设置年份</li>
<li>setUTCMonth(monthInt) 依据国际时间来设置月(0-11)</li>
<li>setUTCDate(dateInt)   依据国际时间来设置日(1-31)</li>
<li>setUTCHours(hourInt)  依据国际时间来设置小时</li>
<li>setUTCMinutes(minInt) 依据国际时间来设置分钟</li>
<li>setUTCSeconds(secInt)  依据国际时间来设置秒</li>
<li>setUTCMilliseconds(milliInt)依据国际时间来设置毫秒</li>
<li>setTime(timeInt)  设置从1970年1月1日开始的时间.毫秒数</li>
<li>toGMTString()   根据格林威治时间将Date对象的日期(一个数值)转变成一个GMT时间字符串,如:Weds,15 June l997 14:02:02 GMT</li>
<li>toUTCString()   根据通用时间将一个Date对象的日期转换为一个字符串</li>
<li>toLocaleString()  把Date对象的日期(一个数值)转变成一个字符串,使用所在计算机上配置使用的特定日期格式</li>
<li>toSource()    显示对象的源代码</li>
<li>toString()    将日期对象转换为字符串</li>
<li>UTC(yyyy, mm, dd, hh, mm, ss, msec)返回从格林威治标准时间到指定时间的差距,单位为毫秒</li>
<li>valueOf()    返回日期对象的原始值</li>
</ol>
<h3 id="9、Math"><a href="#9、Math" class="headerlink" title="9、Math"></a>9、Math</h3><p><strong>属性:</strong></p>
<ul>
<li>constructor   所建立对象的函数参考</li>
<li>prototype    能够为对象加入的属性和方法</li>
<li>E      欧拉常量,自然对数的底(约等于2.718)</li>
<li>LN2     2的自然对数(约等于0.693)</li>
<li>LN10     10的自然对数(约等于2.302)</li>
<li>LOG2E     以2为底的e的对数.(约等于1.442)</li>
<li>LOG10E     以10为底的e的对数(约等于0.434)</li>
<li>PI      ∏的值(约等于3.14159)</li>
<li>SQRT1_2    1/2(0.5)的平方根(即l除以2的平方根,约等于o.707)</li>
<li>SQRT2     2的平方根(约等于1.414)</li>
</ul>
<p><strong>方法:</strong></p>
<ul>
<li>abs(x)   返回数字的绝对值</li>
<li>acos(x)  返回数字的反余弦值</li>
<li>asin(x)  返回数字的反正弦值</li>
<li>atan(x)  返回位于-PI/2 和 PI/2 的反正切值</li>
<li>atan2(y,x) 返回（x,y）位于 -PI 到 PI 之间的角度</li>
<li>ceil(x)  返回 x 四舍五入后的最大整数</li>
<li>cos(x)   返回一个数字的余弦值</li>
<li>exp(x)   返回 E^x 值</li>
<li>floor(x)  返回 x 四舍五入后的最小整数</li>
<li>log(x)   返回底数为E的自然对数</li>
<li>max(x,y)  返回 x 和 y 之间较大的数</li>
<li>min(x,y)  返回 x 和 y 之间较小的数</li>
<li>pow(x,y)  返回 y^x 的值</li>
<li>random()  返回位于 0 到 1 之间的随机函数</li>
<li>round(x)  四舍五入后取整</li>
<li>sin(x)   返回数字的正弦值</li>
<li>sqrt(x)  返回数字的平方根</li>
<li>tan(x)   返回一个角度的正切值</li>
<li>toSource() 显示对象的源代码</li>
<li>valueOf() 返回数学对象的原始值</li>
</ul>
<br>

<h3 id="另一角度对内置对象的解读"><a href="#另一角度对内置对象的解读" class="headerlink" title="另一角度对内置对象的解读"></a>另一角度对内置对象的解读</h3><blockquote>
<p>原文链接  <a href="https://segmentfault.com/a/1190000011467723">JS所有内置对象属性和方法汇总</a></p>
</blockquote>
<h4 id="JS三大对象"><a href="#JS三大对象" class="headerlink" title="JS三大对象"></a>JS三大对象</h4><p>对象，是任何一个开发者都无法绕开和逃避的话题，她似乎有些深不可测，但如此伟大和巧妙的存在，一定值得你去摸索、发现、征服。</p>
<p>我们都知道，JavaScript有3大对象，分别是<code>本地对象</code>、<code>内置对象</code>和<code>宿主对象</code>。</p>
<p>在此引用ECMA-262（ECMAScript的制定标准）对于他们的定义：</p>
<ul>
<li>本地对象<ul>
<li>与宿主无关，独立于宿主环境的ECMAScript实现提供的对象。</li>
<li>简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。</li>
<li>这些引用类型在运行过程中需要通过new来创建所需的实例对象。</li>
<li>包含：<code>Object</code>、<code>Array</code>、<code>Date</code>、<code>RegExp</code>、<code>Function</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code>等。</li>
</ul>
</li>
<li>内置对象<ul>
<li>与宿主无关，独立于宿主环境的ECMAScript实现提供的对象。</li>
<li>在 ECMAScript 程序开始执行前就存在，本身就是实例化内置对象，开发者无需再去实例化。</li>
<li>内置对象是本地对象的子集。</li>
<li>包含：<code>Global</code>和<code>Math</code>。</li>
<li>ECMAScript5中增添了<code>JSON</code>这个存在于全局的内置对象。</li>
</ul>
</li>
<li>宿主对象<ul>
<li>由 ECMAScript 实现的宿主环境提供的对象，包含两大类，一个是宿主提供，一个是自定义类对象。</li>
<li>所有非本地对象都属于宿主对象。</li>
<li>对于嵌入到网页中的JS来说，其宿主对象就是浏览器提供的对象，浏览器对象有很多，如<code>Window</code>和<code>Document</code>等。</li>
<li>所有的<code>DOM</code>和<code>BOM</code>对象都属于宿主对象。</li>
</ul>
</li>
</ul>
<blockquote>
<p>关于专业名词：本地对象也经常被叫做原生对象或内部对象，包含Global和Math在内的内置对象在《JavaScript高级程序设计》里也被叫做单体内置对象，很多时候，干脆也会直接把本地对象和内置对象统称为“内置对象”，也就是说除了宿主对象，剩下的都是ECMAScript的内部的“内置”对象。</p>
<p>声明：本文也将采取这种统称为“内置对象”的方式，比如文章标题。</p>
</blockquote>
<h4 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h4><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p><strong>constructor</strong><br><strong>prototype</strong></p>
<h5 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h5><p><strong>1、toString()</strong></p>
<p>功能：返回当前对象的字符串形式，返回值为String类型。</p>
<p>示例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>,true].toString(); <span class="regexp">//</span><span class="string">&quot;1,2,true&quot;</span></span><br><span class="line">(new Date()).toString(); <span class="regexp">//</span><span class="string">&quot;Sun Sep 24 2017 14:52:20 GMT+0800 (CST)&quot;</span></span><br><span class="line">(&#123;name:<span class="string">&#x27;ryan&#x27;</span>&#125;).toString(); <span class="regexp">//</span><span class="string">&quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法属于Object对象，由于所有的对象都”继承”了Object的对象实例，因此几乎所有的实例对象都可以使用该方法。</p>
<p>JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。</p>
</blockquote>
<p><strong>2、toLocaleString</strong></p>
<p>功能：返回当前对象的”本地化”字符串形式，以便于当前环境的用户辨识和使用，返回值为String类型。</p>
<p>示例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">(<span class="number">1234567</span>).<span class="keyword">to</span><span class="constructor">LocaleString()</span>; <span class="comment">//&quot;1,234,567&quot;</span></span><br><span class="line">(<span class="number">6.37588</span>).<span class="keyword">to</span><span class="constructor">LocaleString()</span>; <span class="comment">//&quot;6.376&quot;</span></span><br><span class="line">(<span class="keyword">new</span> <span class="constructor">Date()</span>).<span class="keyword">to</span><span class="constructor">LocaleString()</span>; <span class="comment">//&quot;2017/9/24 下午2:58:21&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>3、valueOf()</strong></p>
<p>功能：返回指定对象的原始值。</p>
<blockquote>
<p>JavaScript的许多内置对象都重写了该函数，以实现更适合自身的功能需要。因此，不同类型对象的valueOf()方法的返回值和返回值类型均可能不同。</p>
</blockquote>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p><strong>1、Object.assign(target, …sources)</strong></p>
<p>功能：把一个或多个源对象的可枚举、自有属性值复制到目标对象中，返回值为目标对象。<br>参数：</p>
<ul>
<li>目标对象（必须）</li>
<li>至少一个源对象（可选）</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> source1 = &#123;</span><br><span class="line">    b:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123;</span><br><span class="line">    c:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target,source1,source2);</span><br><span class="line"><span class="built_in">console</span>.log(target); <span class="comment">//&#123;a: 1, b: 2, c: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<p>拓展：自定义实现一个assign方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义一个assign方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="literal">null</span>)&#123;</span><br><span class="line">      throwError(<span class="string">&#x27;出错：Cannot convert undefined or null to object&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> target = <span class="keyword">new</span> <span class="built_in">Object</span>(target);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt; <span class="built_in">arguments</span>.length;i ++)&#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="built_in">arguments</span>[i];</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> source)&#123;</span><br><span class="line">        <span class="keyword">if</span>(source.hasOwnProperty(key))&#123;</span><br><span class="line">          <span class="comment">//若当前属性为源对象自有属性，则拷贝至目标对象</span></span><br><span class="line">          target[key] = source[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>2、Object.create(proto [,propertiesObject])</strong></p>
<p>功能：创建一个对象，其原型为prototype，同时可添加多个属性。<br>参数：</p>
<ul>
<li>proto(必须)：原型对象，可以为null表示没有原型。</li>
<li>descriptors(可选)：包含一个或多个属性描述符的对象。</li>
</ul>
<p>propertiesObject参数详解：</p>
<ul>
<li>数据属性<ul>
<li>value：值</li>
<li>writable：是否可修改属性的值</li>
<li>configurable：是否可通过delete删除属性，重新定义</li>
<li>enumerable：是否可for-in枚举</li>
</ul>
</li>
<li>访问属性<ul>
<li>get()：访问</li>
<li>set()：设置</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">&#x27;my name is &#x27;</span> + <span class="built_in">this</span>.name +<span class="string">&#x27;,my age is &#x27;</span> + <span class="built_in">this</span>.age);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;ryan&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">Object</span>.create(person,&#123;</span><br><span class="line">    age:&#123;</span><br><span class="line">      value: <span class="number">23</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    sex:&#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> sex + <span class="string">&#x27;士&#x27;</span>;&#125;,</span><br><span class="line">      set:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;sex = value;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  p.sex = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">  p.say(); <span class="comment">//&#x27;my name is ryan,my age is 23&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(p.sex); <span class="comment">//&#x27;男士&#x27;</span></span><br><span class="line">  p.sex = <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(p.sex); <span class="comment">//&#x27;女士&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：Object.create(proto [,propertiesObject]) 是E5中提出的一种新的对象创建方式，第一个参数是要继承的原型，如果不是一个子函数，可以传一个null，第二个可选参数是对象的属性描述符。</p>
</blockquote>
<p><strong>3、Object.defineProperty(obj, prop, descriptor)</strong></p>
<p>功能：在一个对象上定义一个新属性或修改一个现有属性，并返回该对象。</p>
<p>参数：</p>
<ul>
<li>obj（必须）：被操作的目标对象</li>
<li>prop（必须）：被定义或修改的目标属性</li>
<li>descriptor（必须）：属性的描述符</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;name&#x27;</span>,&#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    value: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">//&#x27;张三&#x27;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj[key]); <span class="comment">//无结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：在参数 descriptor中，如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined。</p>
</blockquote>
<p><strong>4、Object.defineProperties(obj, props)</strong></p>
<p>功能：在一个对象上定义一个或多个新属性或修改现有属性，并返回该对象。</p>
<p>参数：</p>
<ul>
<li>obj（必须）：被操作的目标对象</li>
<li>props（必须）：该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置</li>
</ul>
<p>示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> &#123;&#125;<span class="string">;</span></span><br><span class="line"><span class="string">Object.defineProperties(obj,&#123;</span></span><br><span class="line">    <span class="string">name:&#123;</span></span><br><span class="line">      <span class="attr">writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">      <span class="attr">configurable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">      <span class="attr">enumerable:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">age:&#123;</span></span><br><span class="line">      <span class="attr">writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">      <span class="attr">configurable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">      <span class="attr">enumerable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">      <span class="attr">value:</span> <span class="number">23</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="string">console.log(obj.name);</span> <span class="string">//&#x27;张三&#x27;</span></span><br><span class="line"><span class="string">console.log(obj.age);</span> <span class="string">//23</span></span><br><span class="line"><span class="string">for(var</span> <span class="string">key</span> <span class="string">in</span> <span class="string">obj)&#123;</span></span><br><span class="line">    <span class="string">console.log(obj[key]);</span> <span class="string">//23</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>5、Object.seal(obj) / Object.isSealed(obj)</strong><br>功能：密封对象，阻止其修改现有属性的配置特性，即将对象的所有属性的configurable特性设置为false（也就是全部属性都无法重新配置，唯独可以把writable的值由true改为false，即冻结属性），并阻止添加新属性，返回该对象。</p>
<p>参数：</p>
<ul>
<li>obj（必须）：被密封的对象</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;张三&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(obj);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isSealed(obj)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&#x27;李四&#x27;</span>; <span class="comment">//修改值成功</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">//&#x27;李四&#x27;</span></span><br><span class="line">obj.age = <span class="number">23</span>; <span class="comment">//无法添加新属性</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.age); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj,<span class="string">&#x27;name&#x27;</span>,&#123; </span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">&#125;); <span class="comment">//报错：Cannot redefine property: name</span></span><br></pre></td></tr></table></figure>

<p>补充：Object.isSealed(obj)用于判断目标对象是否被密封，返回布尔值。</p>
<blockquote>
<p>将一个对象密封后仅能保证该对象不被扩展且全部属性不可重配置，但是原属性值却是可以被修改的。</p>
</blockquote>
<p><strong>6、Object.freeze(obj) / Object.isFrozen(obj)</strong></p>
<p>功能：完全冻结对象，在seal的基础上，属性值也不可以修改，即每个属性的wirtable也被设为false。</p>
<p>参数：</p>
<ul>
<li>obj（必须）：被冻结的对象</li>
</ul>
<p>示例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">var obj = &#123;<span class="type">name</span>:<span class="string">&#x27;张三&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Object</span>.<span class="keyword">freeze</span>(obj);</span><br><span class="line">console.log(<span class="keyword">Object</span>.isFrozen(obj)); //<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">&#x27;李四&#x27;</span>; //修改值失败</span><br><span class="line">console.log(obj.name); //<span class="string">&#x27;张三&#x27;</span></span><br><span class="line">obj.age = <span class="number">23</span>; //无法添加新属性</span><br><span class="line">console.log(obj.age); //undefined</span><br><span class="line"></span><br><span class="line"><span class="keyword">Object</span>.defineProperty(obj,<span class="string">&#x27;name&#x27;</span>,&#123; </span><br><span class="line">    writable: <span class="keyword">true</span>,</span><br><span class="line">    configurable: <span class="keyword">true</span>,</span><br><span class="line">    enumerable: <span class="keyword">true</span></span><br><span class="line">&#125;); //报错：Cannot redefine property: <span class="type">name</span></span><br></pre></td></tr></table></figure>

<p>补充：Object.isFrozen(obj)用于判断目标对象是否被冻结，返回布尔值。</p>
<p><strong>7、getOwnPropertyDescriptor(obj, prop)</strong></p>
<p>功能：获取目标对象上某自有属性的配置特性（属性描述符），返回值为配置对象。</p>
<p>参数：</p>
<ul>
<li>obj(必须)：目标对象</li>
<li>prop(必须)：目标自有属性</li>
</ul>
<p>示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> &#123;&#125;<span class="string">;</span></span><br><span class="line"></span><br><span class="line"><span class="string">Object.defineProperty(obj,&#x27;name&#x27;,&#123;</span></span><br><span class="line">    <span class="attr">writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">    <span class="attr">configurable:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line">    <span class="attr">enumerable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">    <span class="attr">value:</span> <span class="string">&#x27;张三&#x27;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="string">var</span> <span class="string">prop</span> <span class="string">=</span> <span class="string">Object.getOwnPropertyDescriptor(obj,&#x27;name&#x27;);</span></span><br><span class="line"><span class="string">console.log(prop);</span> <span class="string">//&#123;value:</span> <span class="string">&quot;张三&quot;</span><span class="string">,</span> <span class="attr">writable:</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">enumerable:</span> <span class="literal">true</span><span class="string">,</span> <span class="attr">configurable:</span> <span class="literal">false</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>8、Object.getOwnPropertyNames(obj)</strong></p>
<p>功能：获取目标对象上的全部自有属性名（包括不可枚举属性）组成的数组。</p>
<p>参数：</p>
<ul>
<li>obj(必须)：目标对象</li>
</ul>
<p>示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> &#123;&#125;<span class="string">;</span></span><br><span class="line"><span class="string">obj.say</span> <span class="string">=</span> <span class="string">function()&#123;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="string">Object.defineProperties(obj,&#123;</span></span><br><span class="line">    <span class="string">name:&#123;</span></span><br><span class="line">      <span class="attr">writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">      <span class="attr">configurable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">      <span class="attr">enumerable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">    <span class="string">&#125;,</span></span><br><span class="line">    <span class="string">age:&#123;</span></span><br><span class="line">      <span class="attr">writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">      <span class="attr">configurable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line">      <span class="attr">enumerable:</span> <span class="literal">false</span><span class="string">,</span></span><br><span class="line">      <span class="attr">value:</span> <span class="number">23</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="string">var</span> <span class="string">arr</span> <span class="string">=</span> <span class="string">Object.getOwnPropertyNames(obj);</span></span><br><span class="line"><span class="string">console.log(arr);</span> <span class="string">//[&quot;say&quot;,</span> <span class="string">&quot;name&quot;</span><span class="string">,</span> <span class="string">&quot;age&quot;</span><span class="string">]</span></span><br></pre></td></tr></table></figure>

<p><strong>9、Object.getPrototypeOf(obj)</strong></p>
<p>功能：获取指定对象的原型，即目标对象的prototype属性的值。</p>
<p>参数：</p>
<ul>
<li>obj(必须)：目标对象</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(person); <span class="comment">//对象p的原型为person</span></span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">//Person &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> __ptoto__ = <span class="built_in">Object</span>.getPrototypeOf(p);</span><br><span class="line"><span class="built_in">console</span>.log(__ptoto__); <span class="comment">//Person &#123;name: &quot;张三&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>10、Object.setPrototypeOf(obj, proto)</strong></p>
<p>功能：设置目标对象的原型为另一个对象或null，返回该目标对象。</p>
<p>参数：</p>
<ul>
<li>obj(必须)：目标对象</li>
<li>proto(必须)：原型对象</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> proto = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj,proto); <span class="comment">//设置obj对象的原型</span></span><br><span class="line"></span><br><span class="line">proto.b = <span class="number">2</span>; <span class="comment">//为该原型对象添加属性</span></span><br><span class="line">proto.c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.c); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>解析：上述代码将proto对象设为obj对象的原型，所以从obj对象上可以顺利读取到proto 对象的属性，也就是原型链上的属性。</p>
<blockquote>
<p>Object.setPrototypeOf()方法的作用与__proto__相同，用来设置当前对象的原型指向的对象(prototype)。它是 ES6 正式推荐的设置原型对象的方法。</p>
</blockquote>
<p><strong>11、Object.keys(obj)</strong></p>
<p>功能：获取目标对象上所有可枚举属性组成的数组。</p>
<p>参数：</p>
<ul>
<li>obj(必须)：目标对象</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    type:<span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//以person对象为原型，创建obj对象</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(person,&#123;</span><br><span class="line">    sex:&#123;</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">false</span>, <span class="comment">//设置sex属性为不可枚举</span></span><br><span class="line">      value: <span class="string">&#x27;male&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>, <span class="comment">//设置age属性为可枚举</span></span><br><span class="line">      value: <span class="number">23</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  obj.name = <span class="string">&#x27;张三&#x27;</span>; <span class="comment">//自定义属性name默认为可枚举</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj.propertyIsEnumerable(<span class="string">&#x27;name&#x27;</span>)); <span class="comment">//true，成功验证name属性为可枚举</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//用for-in可获取obj上全部可枚举的属性（包括自有和原型链上的）</span></span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    arr.push(key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(arr); <span class="comment">//[&quot;age&quot;, &quot;name&quot;, &quot;type&quot;, &quot;say&quot;]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//用Object.keys()可获取obj上全部可枚举的自有属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// [&quot;age&quot;, &quot;name&quot;]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：Object.keys(obj)方法获取的集合和for-in遍历获取的不同在于，Object.keys()只获取目标对象上可枚举的自有属性，而for-in遍历会包含原型链上可枚举属性一并获取。</p>
<p>Object.keys()和Object.getOwnPropertyNames()的相同之处都是获取目标对象的自有属性，区别在于，后者会连同不可枚举的自有属性也一并获取组成数组并返回。</p>
</blockquote>
<p><strong>12、Object.preventExtensions(obj) / Object.isExtensible(obj)</strong></p>
<p>功能：使某一对象不可扩展，也就是不能为其添加新属性。</p>
<p>参数：</p>
<ul>
<li>obj(必须)：目标对象</li>
</ul>
<p>补充：Object.isExtensible(obj)方法用于判断一个对象是否可扩展，即是否可以添加新属性。</p>
<p>示例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  name: &#x27;张三&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>prevent<span class="constructor">Extensions(<span class="params">obj</span>)</span>; <span class="comment">//阻止obj的可扩展性</span></span><br><span class="line">console.log(<span class="module-access"><span class="module"><span class="identifier">Object</span>.</span></span>is<span class="constructor">Extensible(<span class="params">obj</span>)</span>); <span class="comment">//false，表明obj对象为不可扩展，即阻止成功</span></span><br><span class="line"></span><br><span class="line">obj.age = <span class="number">23</span>; <span class="comment">//默认添加失败</span></span><br><span class="line">console.log(obj.age); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h4><h5 id="Array-对象属性"><a href="#Array-对象属性" class="headerlink" title="Array 对象属性"></a>Array 对象属性</h5><p><strong>1、length</strong></p>
<p>设置或返回数组中元素的数目。</p>
<blockquote>
<p>设置 length 属性可改变数组的大小。如果设置的值比其当前值小，数组将被截断，其尾部的元素将丢失。如果设置的值比它的当前值大，数组将增大，新的元素被添加到数组的尾部，它们的值为 undefined。</p>
</blockquote>
<p><strong>2、constructor</strong></p>
<p>返回对创建此对象的数组函数的引用。</p>
<p><strong>3、prototype</strong></p>
<p>使您有能力向对象添加属性和方法。</p>
<h5 id="Array-对象方法"><a href="#Array-对象方法" class="headerlink" title="Array 对象方法"></a>Array 对象方法</h5><p><strong>1、concat()</strong></p>
<ul>
<li>用于连接两个或多个数组，该方法不会改变现有的数组，而是返回被连接数组的一个副本。</li>
<li>如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。</li>
</ul>
<p><strong>2、join()</strong></p>
<ul>
<li>把数组中的所有元素放入一个字符串，元素是通过指定的分隔符进行分隔的。</li>
<li>若省略了分隔符参数，则使用逗号作为分隔符。</li>
</ul>
<p><strong>3、push()</strong></p>
<ul>
<li>向数组的末尾添加一个或多个元素，并返回新的数组长度。</li>
</ul>
<p><strong>4、pop()</strong></p>
<ul>
<li>用于删除数组的最后一个元素，把数组长度减1，并返回被删除元素。</li>
<li>如果数组已经为空，则 pop() 不改变数组，并返回 undefined。</li>
</ul>
<p><strong>5、shift()</strong></p>
<ul>
<li>用于把数组的第一个元素从其中删除，并返回被移除的这个元素。</li>
<li>如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined。</li>
<li>该方法是直接修改原数组。</li>
</ul>
<p><strong>6、unshift()</strong></p>
<ul>
<li>向数组的开头添加一个或更多元素，并返回新的数组长度。</li>
<li>该方法是直接修改原数组。</li>
</ul>
<p><strong>7、reverse()</strong></p>
<ul>
<li>用于颠倒数组中元素的顺序。</li>
<li>该方法会直接修改原数组，而不会创建新数组。</li>
</ul>
<p><strong>8、sort()</strong></p>
<ul>
<li>用于对数组的元素进行排序。</li>
<li>该排序直接修改原数组，不生成副本。</li>
<li>该方法接受一个可选参数，若未使用参数，将按字母顺序对数组元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</li>
<li>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：<ul>
<li>若 a 小于 b，排序后 a 应该在 b 之前，则返回一个小于 0 的值。</li>
<li>若 a 等于 b，则返回 0。</li>
<li>若 a 大于 b，则返回一个大于 0 的值。</li>
</ul>
</li>
</ul>
<p><strong>9、slice(start [,end])</strong></p>
<ul>
<li>截取原数组从start到end位置（不包含它）元素组成的子数组。</li>
<li>该方法返回一个新数组，不会修改原数组。</li>
<li>若未指定end参数，那么截取尾巴直到原数组最后一个元素（包含它）。</li>
</ul>
<p><strong>10、splice(index,howmany [,item1,item2…])</strong></p>
<ul>
<li>删除从 index 处开始的hownamy个元素，并且用可选参数列表中声明的一个或多个值来替换那些被删除的元素。</li>
<li>该方法返回的是含有被删除的元素组成的数组，若无被删元素，则返回空数组。</li>
<li>若参数只有index，那么原数组将从index开始删除直至结尾。</li>
<li>该方法直接修改原数组。</li>
</ul>
<p>map():返回一个新的Array，每个元素为调用func的结果</p>
<p>filter():返回一个符合func条件的元素数组</p>
<p>some():返回一个boolean，判断是否有元素是否符合func条件</p>
<p>every():返回一个boolean，判断每个元素是否符合func条件</p>
<p>forEach():没有返回值，只是针对每个元素调用func</p>
<p>reduce()：reduce方法有两个参数，第一个参数是一个callback，用于针对数组项的操作；第二个参数则是传入的初始值，这个初始值用于单个数组项的操作。需要注意的是，reduce方法返回值并不是数组，而是形如初始值的经过叠加处理后的操作。</p>
<h4 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h4><p>Date对象：封装一个时间点，提供操作时间的API。Date对象中封装的是从1970年1月1日0点至今的毫秒数。</p>
<p><strong>创建Date对象4种方式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">//获取客户端的当前系统时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date - <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;1994/02/04 03:23:55&quot;</span>); <span class="comment">//创建自定义时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>(yyyy, MM, dd, hh, mm, ss); <span class="comment">//创建自定义时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oldDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&quot;1994/02/04&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newDate = <span class="keyword">new</span> <span class="built_in">Date</span>(oldDate); <span class="comment">//复制一个时间对象</span></span><br></pre></td></tr></table></figure>

<p><strong>获取日期类型时间戳：</strong><code>Date.getTime()</code>  或者  <code>+Date</code></p>
<p><strong>日期API</strong></p>
<p>日期分量：FullYear、Month、Date、Day、Hours、Minutes、Seconds、Milliseconds。<br>每一个日期分量都有一个<code>get</code>和<code>set</code>方法（除了Day没有set方法），分别用于获取和设置时间对象。</p>
<blockquote>
<p>日期的单位及范围:</p>
<p>年FullYear (无范围)<br>月Month (0<del>11, 0开始,没有12)<br>日Date (1</del>31, 和现实生活一样)<br>星期Day (0<del>6, 0是星期日,没有7)<br>时Hours (0</del>23. 0开始，没有24)<br>分Minutes (0<del>59)<br>秒Seconds (0</del>59)<br>毫秒MilliSeconds</p>
</blockquote>
<h4 id="RegExp类型"><a href="#RegExp类型" class="headerlink" title="RegExp类型"></a>RegExp类型</h4><h5 id="RegExp对象属性"><a href="#RegExp对象属性" class="headerlink" title="RegExp对象属性"></a>RegExp对象属性</h5><p><strong>1、global</strong></p>
<ul>
<li>描述：RegExp 对象是否具有标志 g，即全局匹配。</li>
<li>值：true或false。</li>
</ul>
<p><strong>2、ignoreCase</strong></p>
<ul>
<li>描述：RegExp 对象是否具有标志 i，即忽略大小写。</li>
<li>值：一个整数，它声明的是上一次匹配文本之后的第一个字符的位置。</li>
</ul>
<p><strong>3、lastIndex</strong></p>
<ul>
<li>描述：lastIndex用于规定下次匹配的起始位置。</li>
<li>值：true或false。</li>
</ul>
<blockquote>
<p>不具有标志 g 和不表示全局模式的 RegExp 对象不能使用 lastIndex 属性。</p>
</blockquote>
<h5 id="RegExp对象方法"><a href="#RegExp对象方法" class="headerlink" title="RegExp对象方法"></a>RegExp对象方法</h5><p><strong>1、compile()</strong></p>
<ul>
<li>compile() 方法用于在脚本执行过程中编译正则表达式。</li>
<li>compile() 方法也可用于改变和重新编译正则表达式。</li>
</ul>
<p><strong>2、exec()</strong></p>
<ul>
<li>功能：用于检索字符串中的正则表达式的匹配。</li>
<li>参数：string，必须，要检索的字符串。</li>
<li>返回值：返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</li>
</ul>
<p><strong>3、test()</strong></p>
<ul>
<li>功能：用于检测一个字符串是否匹配某个模式。</li>
<li>参数：string，必须，要检索的字符串。</li>
<li>返回值：true或者false。</li>
</ul>
<blockquote>
<p>注意：支持正则表达式的 String 对象的方法有：search()、match()、replace()和split()。</p>
</blockquote>
<h4 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h4><h5 id="Function对象属性"><a href="#Function对象属性" class="headerlink" title="Function对象属性"></a>Function对象属性</h5><p><strong>1、arguments</strong></p>
<ul>
<li>arguments.length：获取函数实参的个数</li>
<li>arguments.callee：获取函数对象本身的引用</li>
<li>arguments.callee.length：获取函数形参的个数</li>
</ul>
<blockquote>
<p>Javascrip中每个函数都会有一个Arguments对象实例arguments，它引用着函数的实参，可以用数组下标的方式”[]”引用每个实际传入的参数。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">a,b,c</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">//2</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>],<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">//hello world</span></span><br><span class="line">&#125;</span><br><span class="line">say(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="Function对象方法"><a href="#Function对象方法" class="headerlink" title="Function对象方法"></a>Function对象方法</h5><p><strong>1、toString()</strong></p>
<ul>
<li>功能：将函数体转换成对应的字符串。</li>
</ul>
<h4 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h4><p>常用方法：</p>
<p><strong>1、toString()</strong></p>
<ul>
<li>功能：根据布尔值返回字符串 “true” 或 “false”。</li>
</ul>
<blockquote>
<p>注释：在 Boolean 对象被用于字符串环境中时，此方法会被自动调用。</p>
</blockquote>
<p><strong>2、valueOf()</strong></p>
<ul>
<li>功能：返回 Boolean 对象的原始值。</li>
</ul>
<h4 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h4><p>常用方法：</p>
<p><strong>1、toString()</strong></p>
<p>功能：将Number数值转换为字符串，该方法接受一个可选参数基数，若省略该参数，则默认基数为10，即十进制。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = <span class="number">10</span>;</span><br><span class="line">console.log(<span class="built_in">num</span>.toString(<span class="number">2</span>)); <span class="comment">//1010</span></span><br></pre></td></tr></table></figure>

<p><strong>2、toLocaleString()</strong><br>功能：把一个 Number 对象转换为本地格式的字符串。</p>
<p><strong>3、valueOf()</strong><br>功能：返回一个 Number 对象的基本数字值。</p>
<blockquote>
<p>valueOf() 方法通常由 JavaScript 在后台自动进行调用，而不是显式地处于代码中。</p>
</blockquote>
<h4 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h4><h5 id="String对象属性"><a href="#String对象属性" class="headerlink" title="String对象属性"></a>String对象属性</h5><p><strong>1、length</strong></p>
<p>功能：String 对象的 length 属性声明了该字符串中的字符数。</p>
<h5 id="String对象方法"><a href="#String对象方法" class="headerlink" title="String对象方法"></a>String对象方法</h5><p><strong>1、charAt()</strong></p>
<ul>
<li>功能：返回指定位置的字符。</li>
<li>参数：必须，为目标字符的下标位置。</li>
</ul>
<blockquote>
<p>若参数 index 不在 0 与 string.length 之间，该方法将返回一个空字符串。</p>
</blockquote>
<p><strong>2、charCodeAt()</strong></p>
<ul>
<li>功能：返回在指定的位置的字符的 Unicode 编码。</li>
<li>参数：必须，为目标字符的下标位置。</li>
</ul>
<blockquote>
<p>若参数 index 不在 0 与 string.length 之间，该方法将返回NaN。</p>
</blockquote>
<p><strong>3、indexOf()</strong></p>
<ul>
<li>功能：检索字符串，返回指定子字符串在字符串中首次出现的位置。</li>
<li>参数1：检索目标子字符串，必须。</li>
<li>参数2：在字符串中开始检索的位置，可选。其合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</li>
</ul>
<blockquote>
<p>注意：indexOf() 方法对大小写敏感！<br>注意：如果要检索的字符串值没有出现，则该方法返回 -1。</p>
</blockquote>
<p><strong>4、lastIndexOf()</strong></p>
<ul>
<li>功能：从后向前搜索字符串，返回指定子字符串在字符串中首次出现的位置。</li>
<li>参数1：检索目标子字符串，必须。</li>
<li>参数2：在字符串中开始检索的位置，可选。其合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的最后一个字符开始检索。</li>
</ul>
<p><strong>5、match()</strong></p>
<ul>
<li>功能：返回指定位置的字符。</li>
<li>参数：必须，规定要检索的字符串值或待匹配的 RegExp 对象。</li>
<li>返回值：存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。</li>
</ul>
<blockquote>
<p>如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。index 属性声明的是匹配文本的起始字符在 stringObject 中的位置，input 属性声明的是对 stringObject 的引用。</p>
<p>如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。若没有找到任何匹配的子串，则返回 null。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">var s = <span class="string">&#x27;hello21 world21&#x27;</span>;</span><br><span class="line">console.log(s.match(<span class="regexp">/\d&#123;2&#125;/</span>)); <span class="regexp">//</span>[ <span class="string">&#x27;21&#x27;</span>, index: <span class="number">5</span>, input: <span class="string">&#x27;hello21 world21&#x27;</span> ]</span><br><span class="line"></span><br><span class="line">var s = <span class="string">&#x27;hello21 world21&#x27;</span>;</span><br><span class="line">console.log(s.match(<span class="regexp">/\d&#123;2&#125;/g</span>)); <span class="regexp">//</span>[ <span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;21&#x27;</span> ]</span><br></pre></td></tr></table></figure>

<p><strong>6、replace()</strong></p>
<ul>
<li>功能：在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</li>
<li>参数1：regexp/substr，必须，规定子字符串或要匹配的 RegExp 对象。</li>
<li>参数2：replacement，必须，用于替换的字符串值。</li>
<li>返回值：替换后的一个新字符串。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello world hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.replace(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;hi&#x27;</span>)); <span class="comment">//hi world hello</span></span><br><span class="line"><span class="built_in">console</span>.log(s.replace(<span class="regexp">/hello/</span>,<span class="string">&#x27;hi&#x27;</span>)); <span class="comment">//hi world hello</span></span><br><span class="line"><span class="built_in">console</span>.log(s.replace(<span class="regexp">/hello/g</span>,<span class="string">&#x27;hi&#x27;</span>)); <span class="comment">//hi world hi</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>replace方法返回一个新字符串，并不会修改原字符串。</p>
</blockquote>
<p><strong>7、search()</strong></p>
<ul>
<li>功能：用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。</li>
<li>参数：regexp/substr，必须，规定子字符串或要匹配的 RegExp 对象。</li>
<li>返回值：原字符串中第一次匹配到目标字符串的起始位置。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello world hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.search(<span class="string">&#x27;hello&#x27;</span>)); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(s.search(<span class="regexp">/hello/g</span>)); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(s.search(<span class="regexp">/hello2/</span>)); <span class="comment">//-1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>search()方法不执行全局匹配，它将忽略标志 g。也就是说，它只匹配一次。若没匹配到结果，则返回-1。</p>
</blockquote>
<p><strong>8、toLowerCase() &amp; toUpperCase()</strong></p>
<ul>
<li>功能：把字符串转换为小写/大写。</li>
<li>返回值：一个新的字符串。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.toLowerCase()); <span class="comment">//hello world</span></span><br><span class="line"><span class="built_in">console</span>.log(s.toUpperCase()); <span class="comment">//HELLO WORLD</span></span><br></pre></td></tr></table></figure>

<p><strong>9、concat()</strong></p>
<ul>
<li>功能：用于连接两个或多个字符串。</li>
<li>语法：stringObject.concat(stringX,stringX,…,stringX)</li>
<li>参数：</li>
<li>返回值：衔接后的一个新字符串。</li>
</ul>
<blockquote>
<p>concat方法不会修改原字符串。<br>stringObject.concat() 与 Array.concat() 很相似。<br>通常使用 “ + “ 运算符来进行字符串的连接运算通常会更简便一些。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var</span> s<span class="number">1</span> = &#x27;hello &#x27;;</span><br><span class="line"><span class="attribute">var</span> s<span class="number">2</span> = &#x27;world &#x27;;</span><br><span class="line"><span class="attribute">var</span> s<span class="number">3</span> = &#x27;<span class="number">233</span>&#x27;;</span><br><span class="line"><span class="attribute">console</span>.log(s<span class="number">1</span>.concat(s<span class="number">2</span>,s<span class="number">3</span>)); //hello world <span class="number">233</span></span><br></pre></td></tr></table></figure>

<p><strong>10、split()</strong></p>
<ul>
<li>功能：用于把一个字符串分割成字符串数组，是 Array.join( ) 的逆操作。</li>
<li>参数1：separator，必须，字符串或正则表达式，从该参数指定的地方分割原字符串。</li>
<li>参数2：howmany，可选，指定返回数组的最大长度。</li>
<li>返回值：一个字符串数组。</li>
</ul>
<p>示例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">var s = <span class="string">&#x27;hi baby&#x27;</span>;</span><br><span class="line">console.log(s.split(<span class="string">&#x27;&#x27;</span>)); <span class="regexp">//</span>[ <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;y&#x27;</span> ]</span><br><span class="line">console.log(s.split(<span class="string">&#x27; &#x27;</span>));  <span class="regexp">//</span>[ <span class="string">&#x27;hi&#x27;</span>, <span class="string">&#x27;baby&#x27;</span> ]</span><br><span class="line">console.log(s.split(<span class="string">&#x27;b&#x27;</span>)); <span class="regexp">//</span>[ <span class="string">&#x27;hi &#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;y&#x27;</span> ]</span><br></pre></td></tr></table></figure>

<p><strong>11、slice()</strong></p>
<ul>
<li>功能：截取字符串的某个部分，并以新的字符串返回被提取的部分。</li>
<li>参数1：截取的起始位置，必须。</li>
<li>参数2：截取的结束位置，可选。</li>
<li>返回值：截取部分，一个新的字符串。</li>
</ul>
<blockquote>
<p>注意：String.slice() 与 Array.slice() 相似。<br>slice方法的两个参数接受负值，若为负数，则该参数规定的是从字符串的尾部开始算起的位置。也就是说，-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推。<br>若未指定第二个参数，则默认截取至字符串的末尾。<br>slice方法不修改原字符串。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var s = <span class="string">&#x27;hi baby&#x27;</span>;</span><br><span class="line">console.log(s.slice(<span class="number">3</span>)); <span class="comment">//baby</span></span><br><span class="line">console.log(s.slice(<span class="number">1</span>,<span class="number">5</span>)); <span class="comment">//i ba</span></span><br><span class="line">console.log(s.slice(<span class="number">-4</span>)); <span class="comment">//baby</span></span><br><span class="line">console.log(s.slice(<span class="number">-4</span>,<span class="number">-2</span>)); <span class="comment">//ba</span></span><br></pre></td></tr></table></figure>

<p><strong>12、substr()</strong></p>
<ul>
<li>功能：截取从指定下标开始的指定数目的字符。</li>
<li>参数1：start，必须，截取的起始位置，接受负值。</li>
<li>参数2：length，可选，截取字符串的长度，若未指定，则默认截取到原字符串的末尾。</li>
<li>返回值：截取部分，一个新的字符串。</li>
</ul>
<blockquote>
<p>注意：ECMAscript 没有对该方法进行标准化，因此不建议使用它。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = &#x27;hi baby&#x27;;</span><br><span class="line">console.<span class="built_in">log</span>(s.<span class="built_in">substr</span>(3)); <span class="comment">//baby</span></span><br><span class="line">console.<span class="built_in">log</span>(s.<span class="built_in">substr</span>(3,2)); <span class="comment">//ba</span></span><br><span class="line">console.<span class="built_in">log</span>(s.<span class="built_in">substr</span>(-3,2)); <span class="comment">//ab</span></span><br></pre></td></tr></table></figure>

<p><strong>13、substring()</strong></p>
<ul>
<li>功能：截取字符串中介于两个指定下标之间的字符。</li>
<li>参数1：start，必须，截取的起始位置。</li>
<li>参数2：end，可选，截取的结束位置，若未指定，则默认截取到原字符串的末尾。</li>
<li>返回值：截取部分，一个新的字符串。</li>
</ul>
<p>示例：</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">var s = <span class="string">&#x27;hi baby&#x27;</span>;</span><br><span class="line">console.<span class="keyword">log</span>(s.<span class="keyword">substring</span>(<span class="number">3</span>)); <span class="comment">//baby</span></span><br><span class="line">console.<span class="keyword">log</span>(s.<span class="keyword">substring</span>(<span class="number">3</span>,<span class="number">5</span>)); <span class="comment">//ba</span></span><br><span class="line">console.<span class="keyword">log</span>(s.<span class="keyword">substring</span>(<span class="number">5</span>,<span class="number">3</span>)); <span class="comment">//ba</span></span><br><span class="line">console.<span class="keyword">log</span>(s.<span class="keyword">substring</span>(<span class="number">3</span>,<span class="number">3</span>)); <span class="comment">//&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：与 slice() 和 substr() 方法不同的是，substring() 不接受负的参数。<br>如果参数 start 与 stop 相等，那么该方法返回的一个空串。<br>如果 start 比 stop 大，那么该方法在提取子串之前会先交换这两个参数。</p>
</blockquote>
<h4 id="Global对象（全局对象）"><a href="#Global对象（全局对象）" class="headerlink" title="Global对象（全局对象）"></a>Global对象（全局对象）</h4><blockquote>
<p>关于全局对象：全局对象只是一个对象，而不是类。既没有构造函数，也无法实例化一个新的全局对象。</p>
</blockquote>
<h5 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h5><p><strong>Infinity</strong><br>代表正的无穷大的数值。</p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">console.log(<span class="number">6</span>/<span class="number">0</span>); <span class="comment">//Infinity</span></span><br><span class="line">console.log(<span class="number">-6</span>/<span class="number">0</span>); <span class="comment">//-Infinity</span></span><br><span class="line">console.log(<span class="number">0</span>/<span class="number">0</span>); <span class="comment">//NaN</span></span><br><span class="line">console.log(<span class="number">1.7976931348623157E+10308</span>); <span class="comment">//Infinity</span></span><br><span class="line">console.log(<span class="number">-1.7976931348623157E+10308</span>); <span class="comment">//-Infinity</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Infinity代表了超出JavaScript处理范围的数值。也就是说JS无法处理的数值都是Infinity。实践证明，JS所能处理的最大值是1.7976931348623157e+308，而最小值是5e-324。</p>
</blockquote>
<p><strong>NaN</strong><br>代表非数字的值。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Number</span>(<span class="string">&#x27;100&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Number</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//100</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(a)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(b)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：请使用 isNaN() 方法来判断一个值是否是数字，原因是 NaN 与所有值都不相等，包括它自己。</p>
</blockquote>
<p><strong>Undefined</strong><br>代表未定义的值。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === <span class="literal">undefined</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(b === <span class="literal">undefined</span>); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(c == <span class="literal">undefined</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：判断一个变量是否未定义，只能用 === undefined 运算来测试，因为 == 运算符会认为 undefined 值等价于 null，即undefined == null会返回true。</p>
<p>注释：null 表示无值，而 undefined 表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性。</p>
</blockquote>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p><strong>1、encodeURI(URIString)</strong></p>
<p>功能：将字符串作为URI进行编码，返回值为URIstring 的副本。</p>
<p>参数：</p>
<ul>
<li>URIString(必须)：一个待编码的字符串。</li>
</ul>
<p>示例：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">console.log(encode<span class="constructor">URI(&#x27;<span class="params">http</span>:<span class="operator">/</span><span class="operator">/</span><span class="params">www</span>.<span class="params">baidu</span>.<span class="params">com</span>&#x27;)</span>); <span class="comment">//http://www.baidu.com</span></span><br><span class="line">console.log(encode<span class="constructor">URI(&#x27;<span class="params">http</span>:<span class="operator">/</span><span class="operator">/</span><span class="params">www</span>.<span class="params">baidu</span>.<span class="params">com</span><span class="operator">/</span><span class="params">my</span> <span class="params">mind</span>&#x27;)</span>); <span class="comment">//http://www.baidu.com/my%20mind</span></span><br><span class="line">console.log(encode<span class="constructor">URI(&#x27;,<span class="operator">/</span>?:@&amp;=+$#&#x27;)</span>); <span class="comment">//,/?:@&amp;=+$#</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。</p>
<p>该方法的目的是对 URI 进行完整的编码，因此对以下在 URI 中具有特殊含义的 ASCII 标点符号，encodeURI() 函数是不会进行转义的：;/?:@&amp;=+$,#</p>
<p>提示：如果 URI 组件中含有分隔符，比如 ? 和 #，则应当使用 encodeURIComponent() 方法分别对各组件进行编码。</p>
</blockquote>
<p><strong>2、encodeURIComponent(URIString)</strong></p>
<p>功能：将字符串作为URI组件进行编码，返回值为URIstring的副本。</p>
<p>该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。</p>
<p>其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。</p>
<p>参数：</p>
<ul>
<li>URIString(必须)：一个待编码的字符串。</li>
</ul>
<p>示例：</p>
<blockquote>
<p>encodeURI和encodeURIComponent的区别：</p>
<p>它们都是编码URL，唯一区别就是编码的字符范围，其中encodeURI方法不会对下列字符编码 ASCII字母、数字、<del>!@#$&amp;*()=:/,;?+’<br>encodeURIComponent方法不会对下列字符编码 ASCII字母、数字、</del>!*()’<br>所以encodeURIComponent比encodeURI编码的范围更大。<br>实际例子来说，encodeURIComponent会把 http:// 编码成 http%3A%2F%2F 而encodeURI却不会。</p>
</blockquote>
<p>使用场景：</p>
<ul>
<li>当你需要编码整个URL，然后使用这个URL，则使用encodeURI。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">console.log(encode<span class="constructor">URI(&#x27;<span class="params">http</span>:<span class="operator">/</span><span class="operator">/</span><span class="params">www</span>.<span class="params">baidu</span>.<span class="params">com</span><span class="operator">/</span><span class="params">home</span><span class="operator">/</span><span class="params">some</span> <span class="params">other</span> <span class="params">thing</span>&#x27;)</span>);</span><br><span class="line"><span class="comment">//编码后为：http://www.baidu.com/home/some%20other%20thing; 其中，空格被编码成了%20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//但是如果你用了encodeURIComponent</span></span><br><span class="line">console.log(encode<span class="constructor">URIComponent(&#x27;<span class="params">http</span>:<span class="operator">/</span><span class="operator">/</span><span class="params">www</span>.<span class="params">baidu</span>.<span class="params">com</span><span class="operator">/</span><span class="params">home</span><span class="operator">/</span><span class="params">some</span> <span class="params">other</span> <span class="params">thing</span>&#x27;)</span>);</span><br><span class="line"><span class="comment">//http%3A%2F%2Fwww.baidu.com%2Fhome%2Fsome%20other%20thing 连 &quot;/&quot; 都被编码了，整个URL已经没法用了</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当你需要编码URL中的参数时，那么使用encodeURIComponent。</li>
</ul>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> param = <span class="string">&quot;http://www.baidu.com/home/&quot;</span>; <span class="comment">//param为参数</span></span><br><span class="line">param = <span class="built_in">encodeURIComponent</span>(param);</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">url</span> = <span class="string">&quot;http://www.baidu.com?next=&quot;</span> + param;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">url</span>) <span class="comment">//&#x27;http://www.baidu.com?next=http%3A%2F%2Fwww.baidu.com%2Fhome%2F&#x27;</span></span><br><span class="line"><span class="comment">//显然，参数中的 &quot;/&quot; 被编码了，而如果用encodeURI肯定要出问题，因为后面的/是需要编码的。</span></span><br></pre></td></tr></table></figure>

<p>补充：相应的，存在decodeURI()和decodeURIComponent是用来解码的，逆向操作。</p>
<p><strong>3、parseInt(string,radix)</strong></p>
<p>功能：解析一个字符串，并返回一个整数。</p>
<p>参数：</p>
<ul>
<li>string(必须)：待解析的字符串</li>
<li>radix(可选)：表示要解析的数字的基数。该值介于 2 ~ 36 之间。<br>如果省略该参数或其值为 0，则数字将以 10 为基础来解析。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;10&#x27;</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;11&#x27;</span>,<span class="number">9</span>)); <span class="comment">//10 (9+1)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;11&#x27;</span>,<span class="number">2</span>)); <span class="comment">//3 (2+1)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;17&#x27;</span>,<span class="number">8</span>)); <span class="comment">//15 (8+7)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;1f&#x27;</span>,<span class="number">16</span>)); <span class="comment">//31 (16+15)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;010&#x27;</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(<span class="string">&#x27;0x0011&#x27;</span>)); <span class="comment">//17</span></span><br></pre></td></tr></table></figure>

<p><strong>4、parseFloat()</strong></p>
<p>功能：解析一个字符串，并返回一个浮点数。<br>该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止。</p>
<p>参数：</p>
<ul>
<li>string(必须)：待解析的字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;10&#x27;</span>)); <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;10.00&#x27;</span>)); <span class="comment">//10 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;10.33&#x27;</span>)); <span class="comment">//10.33</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27; 60 &#x27;</span>)); <span class="comment">//60 首尾的空格会忽略</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;23 34 45&#x27;</span>)); <span class="comment">//23 中间的空格不会忽略，会中断</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;23 years&#x27;</span>)); <span class="comment">//23</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(<span class="string">&#x27;i am 23&#x27;</span>)); <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：开头和结尾的空格是允许的。如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN。如果只想解析数字的整数部分，请使用 parseInt() 方法。</p>
</blockquote>
<p><strong>5、isFinite(number)</strong></p>
<p>功能：用于检查其参数是否是无穷大。</p>
<p>参数：</p>
<ul>
<li>number(必须)：待检测数字。<br>如果 number 是有限数字（或可转换为有限数字），那么返回 true。否则，如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。</li>
</ul>
<p>示例：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="number">123</span>)); //<span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="number">-1.23</span>)); //<span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="number">5</span><span class="number">-2</span>)); //<span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="number">0</span>)); //<span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="number">0</span>/<span class="number">0</span>)); //<span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(<span class="string">&#x27;Hello&#x27;</span>)); //<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p><strong>6、isNaN(number)</strong></p>
<p>功能：用于检查其参数是否为非数字值。</p>
<p>参数：</p>
<ul>
<li>number(必须)：待检测数字。<br>如果 number 是非数字值 NaN（或者能被转换成NaN），返回 true，否则返回 false。</li>
</ul>
<p>示例：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">123</span>)); //<span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">-1.23</span>)); //<span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">5</span><span class="number">-2</span>)); //<span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">0</span>)); //<span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">0</span>/<span class="number">0</span>)); //<span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&#x27;Hello&#x27;</span>)); //<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：isNaN() 函数通常用于检测 parseFloat() 和 parseInt() 的结果，以判断它们表示的是否是合法的数字。当然也可以用 isNaN() 函数来检测算数错误，比如用 0 作除数的情况。</p>
</blockquote>
<p><strong>7、Number(object)</strong></p>
<p>功能：把对象的值转换为数字。</p>
<p>参数：</p>
<ul>
<li>object(必须)：待转换的对象。<br>如果参数是 Date 对象，Number() 返回从1970年1月1日至今的毫秒数，即时间戳。如果对象的值无法转换为数字，那么 Number() 函数返回 NaN。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>))); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="comment">//1506266494726</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;999&#x27;</span>))); <span class="comment">//999</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;999 888&#x27;</span>))); <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<p><strong>8、String(object)</strong></p>
<p>功能：把对象的值转换为字符串。</p>
<p>参数：</p>
<ul>
<li>object(必须)：待转换的对象。</li>
</ul>
<p>示例：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>))); <span class="regexp">//</span><span class="string">&#x27;true&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>))); <span class="regexp">//</span><span class="string">&#x27;false&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="keyword">new</span> <span class="built_in">Date</span>())); <span class="regexp">//</span><span class="string">&#x27;Sun Sep 24 2017 23:25:43 GMT+0800 (CST)&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;999&#x27;</span>))); <span class="regexp">//</span><span class="string">&#x27;999&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;999 888&#x27;</span>))); <span class="regexp">//</span><span class="string">&#x27;999 888&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(<span class="number">12345</span>)); <span class="regexp">//</span><span class="string">&#x27;12345&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><p>常用方法：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>abs<span class="literal">()</span>; <span class="comment">//取绝对值</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>ceil<span class="literal">()</span>; <span class="comment">//向上取整</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>floor<span class="literal">()</span>; <span class="comment">//向下取整</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>round<span class="literal">()</span>; <span class="comment">//四舍五入取整</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>random<span class="literal">()</span>; <span class="comment">//生成0~1间的随机数(&gt;0)</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>max(x,y); <span class="comment">//取x、y中较大的那个</span></span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(x,y); <span class="comment">//取x、y中较小的那个</span></span><br></pre></td></tr></table></figure>

<h4 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h4><p>我们常说的对象字面量其实不是JSON对象，但是有真正的JSON对象。</p>
<p>两者完全不一样概念，在新版的浏览器里JSON对象已经被原生的内置对象了，目前有2个静态方法：JSON.parse用来将JSON字符串反序列化成对象，JSON.stringify用来将对象序列化成JSON字符串。</p>
<p>老版本的浏览器不支持这个对象，但你可以通过json2.js来实现同样的功能。</p>
<h5 id="JSON对象方法"><a href="#JSON对象方法" class="headerlink" title="JSON对象方法"></a>JSON对象方法</h5><p><strong>1、JSON.parse()</strong></p>
<ul>
<li>功能：将字符串反序列化成对象</li>
<li>参数：JSON字符串</li>
<li>返回值：对象</li>
</ul>
<p>示例：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">var jsonString = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;ryan&quot;&#125;&#x27;</span>; <span class="regexp">//</span>JSON字符串（比如从AJAX获取字符串信息）</span><br><span class="line">var obj = JSON.parse(jsonString); <span class="regexp">//</span>将字符串反序列化成对象</span><br><span class="line">console.log(obj); <span class="regexp">//</span>&#123; name: <span class="string">&#x27;ryan&#x27;</span> &#125;</span><br><span class="line">console.log(obj.name == <span class="string">&#x27;ryan&#x27;</span>); <span class="regexp">//</span>true</span><br></pre></td></tr></table></figure>

<p><strong>2、JSON.stringify()</strong></p>
<ul>
<li>功能：将一个对象解析为JSON字符串</li>
<li>参数：对象</li>
<li>返回值：JSON字符串</li>
</ul>
<p>示例：</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">var</span> obj = &#123;<span class="built_in">na</span><span class="symbol">me:</span>&#x27;ryan&#x27;,a<span class="symbol">ge:23</span>&#125;;</span><br><span class="line"><span class="built_in">var</span> jsonString = JSON.stringify(obj);</span><br><span class="line">console.log(jsonString); //&#x27;&#123;<span class="string">&quot;name&quot;</span><span class="symbol">:</span><span class="string">&quot;ryan&quot;</span>,<span class="string">&quot;age&quot;</span><span class="symbol">:23</span>&#125;&#x27;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="三、定时器"><a href="#三、定时器" class="headerlink" title="三、定时器"></a>三、定时器</h2><blockquote>
<p>巩固定时器的使用，顺便复习一下JS运行机制（上次提到它在  <a href="https://hammerzer.github.io/2020/10/07/JS-basic-concept-sec/">JS基础概念二</a>  ）</p>
</blockquote>
<h3 id="setTimeout-和-setTnterval"><a href="#setTimeout-和-setTnterval" class="headerlink" title="setTimeout 和 setTnterval"></a>setTimeout 和 setTnterval</h3><p><code>setTimeout</code>和<code>setInterval</code>的语法相同。它们都有两个参数，一个是将要执行的<strong>代码字符串</strong>或者<strong>函数</strong>，还有一个是<strong>以毫秒为单位的时间间隔</strong>，当过了那个时间段之后就将执行那段代码。<strong>它返回一个整数，表示定时器timer的编号，可以用来取消该定时器。</strong></p>
<p>虽然表面上看来setTimeout只能应用在on-off方式的动作上，不过可以通过创建一个函数循环重复调用setTimeout，以实现重复的操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">showTime();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  alert(<span class="string">&quot;The time is: &quot;</span> + today.toString());</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="string">&quot;showTime()&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦调用了这个函数，那么就会每隔5秒钟就显示一次时间。如果使用setInterval，则相应的代码如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="string">&quot;showTime()&quot;</span>, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showTime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  alert(<span class="string">&quot;The time is: &quot;</span> + today.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="setTimeout的妙用：防止循环超时"><a href="#setTimeout的妙用：防止循环超时" class="headerlink" title="setTimeout的妙用：防止循环超时"></a>setTimeout的妙用：防止循环超时</h3><p>JS是单线程的，一个代码块里面的代码，只能按顺序从上到下执行，所以如果中间有一块代码，执行起来非常耗时，就会导致下面的代码无法执行，出现浏览器假死的状态。</p>
<p>JS的耗时操作，常见的有两种 <strong>1.向服务器发起请求  2.对数组的循环操作</strong> （当然，还有一种，就是把1和2合在一起，叫做 在循环操作里面向服务器发出请求，哈哈哈，实际项目里面经常有人这么干）</p>
<p>解决这两种耗时操作的思路都是一样的——<strong>异步编程</strong>。JS的异步编程，并不是多线程，因为正如上面所说的，JS是单线程的。JS的异步，直观上的理解，就是<strong>延时和回调</strong>。</p>
<ul>
<li>对于第一种耗时情况，我们采用的是<strong>ajax异步请求</strong>，待耗时的请求返回结果时，进行回调操作。</li>
<li>对于第二种耗时情况，则可以使用本文即将介绍的方法，setTimeout延时调用，<strong>进行数组分块处理</strong>。</li>
</ul>
<p><span style="color:red;">那么，真正的问题来了：假设我们要处理一个大小为100的数组，对于数组中每个元素，都需要执行大量的处理，每个元素大约需要1s的处理时间；并且<strong>我们认为，程序后面的代码，不会依赖于我们对这个数组的处理结果。</strong></span></p>
<p>于是就有了下面这段代码，以两种方式来处理这个数组<strong>一种是常规方式，一种是setTimeout的数组分块处理</strong></p>
<p>同样地也可以用<code>promise</code>处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> processTime = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//常规操作</span></span><br><span class="line">tcCircle();</span><br><span class="line"><span class="comment">//注释上面的代码 放开下面注释 以执行setTimeout数组分块操作</span></span><br><span class="line"><span class="comment">//tcCircleUseSetTimeout();</span></span><br><span class="line"><span class="comment">//time consuming circle</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tcCircle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    process(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//页面标题栏一直转圈 且下面的语句迟迟无法执行</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;important process&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;finish!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tcCircleUseSetTimeout</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ele = arr.shift();</span><br><span class="line">    process(ele);</span><br><span class="line">    <span class="keyword">if</span>(arr.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="built_in">arguments</span>.callee,<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;important process&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;finish!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">ele</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;process&quot;</span>+(++processTime));</span><br><span class="line">  <span class="comment">//模拟长时间的处理过程</span></span><br><span class="line">  sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">sleepTime</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start=<span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().getTime()-start&gt;sleepTime)&#123;</span><br><span class="line">      <span class="keyword">break</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="再谈理解JS运行机制"><a href="#再谈理解JS运行机制" class="headerlink" title="再谈理解JS运行机制"></a>再谈理解JS运行机制</h3><p><code>JavasScript</code>引擎是基于事件驱动和单线程执行的，JS引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个JS线程在运行程序，即主线程。</p>
<blockquote>
<p>通俗的说：JS在同一时间内只能做一件事，这也常被称为 “阻塞式执行”。</p>
</blockquote>
<p>那么单线程的<code>JavasScript</code>是怎么实现“非阻塞执行”呢？</p>
<p><span style="color:red;">异步容易实现非阻塞，所以在JavaScript中对于耗时的操作或者时间不确定的操作，使用异步就成了必然的选择。<br>诸如事件点击触发回调函数、ajax通信、计时器这种异步处理是如何实现的呢？</span></p>
<p>答：<strong>任务队列</strong></p>
<blockquote>
<p>任务队列：一个先进先出的队列，它里面存放着各种事件和任务。</p>
</blockquote>
<p>所有任务可以分成两种，一种是<strong>同步任务（synchronous）</strong>，<strong>另一种是异步任务</strong>（asynchronous）。</p>
<p><strong>同步任务</strong></p>
<blockquote>
<p>同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</p>
</blockquote>
<ul>
<li>输出</li>
<li>如：console.log()</li>
<li>变量的声明</li>
<li>同步函数：如果在函数返回的时候，调用者就能够拿到预期的返回值或者看到预期的效果，那么这个函数就是同步的。</li>
</ul>
<p><strong>异步任务</strong></p>
<ul>
<li>setTimeout和setInterval</li>
<li>DOM事件</li>
<li>Promise</li>
<li>process.nextTick</li>
<li>fs.readFile</li>
<li>http.get</li>
<li>异步函数：如果在函数返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</li>
</ul>
<p>除此之外，任务队列又分为<strong>macro-task（宏任务）与micro-task（微任务）</strong>，在ES5标准中，它们被分别称为task与job。</p>
<p><strong>宏任务</strong></p>
<ol>
<li>I/O</li>
<li>setTimeout</li>
<li>setInterval</li>
<li>setImmdiate</li>
<li>requestAnimationFrame</li>
</ol>
<p><strong>微任务</strong></p>
<ol>
<li>process.nextTick</li>
<li>Promise</li>
<li>Promise.then</li>
<li>MutationObserver</li>
</ol>
<p><strong>宏任务和微任务的执行顺序</strong></p>
<p>一次事件循环中，先执行宏任务队列里的一个任务，再去执行同步任务，然后把微任务队列里的所有任务执行完毕，再开启下一个<code>event loop</code>去宏任务队列取下一个宏任务执行。</p>
<blockquote>
<p>注：在当前的微任务没有执行完成时，是不会执行下一个宏任务的。<br></p>
</blockquote>
<p><span style="color:red;font-weight:bold;">seTimeout运行机制</span></p>
<p>setTimeout 和 setInterval的运行机制是将指定的代码移出本次执行，等到下一轮 Event Loop 时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮 Event Loop 时重新判断。</p>
<p>这意味着，setTimeout指定的代码，必须等到本次执行的所有同步代码都执行完，才会执行。</p>
<p><strong>异步队列执行的时间</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(i);</span><br><span class="line">     &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 隔1s后一起输出：4 4 4 4</span></span><br></pre></td></tr></table></figure>

<p>执行到异步任务的时候，会直接放到异步队列中吗？答案是不一定的。</p>
<p>因为浏览器有个定时器（timer）模块，定时器到了执行时间才会把异步任务放到异步队列。<br><code>for循环体</code>执行的过程中并没有把setTimeout放到异步队列中，只是交给定时器模块了。4个循环体执行速度非常快（不到1毫秒）。定时器到了设置的时间才会把setTimeout语句放到异步队列中。</p>
<blockquote>
<p>即使setTimeout设置的执行时间为0毫秒，也按4毫秒算。</p>
</blockquote>
<p>这就解释了上题为什么会连续输出四个4的原因。</p>
<blockquote>
<p>HTML5 标准规定了setTimeout()的第二个参数的最小值，即最短间隔，不得低于4毫秒。如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。</p>
</blockquote>
<p><span style="color:blue">利用闭包实现 <code>setTimeout</code> 间歇调用</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">     (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(j);</span><br><span class="line">         &#125;, <span class="number">1000</span> * i)</span><br><span class="line">     &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 会隔1s输出一个值，分别是：0 1 2 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>此方法巧妙利用IIFE声明即执行的函数表达式来解决闭包造成的问题。</li>
<li>将var改为let，使用了ES6语法。</li>
</ul>
<p>这里也可以用setInterval()方法来实现间歇调用。</p>
<p><span style="color:blue;">利用JS中基本类型的参数传递是按值传递的特征实现</span></p>
<p>实现原理：传过去的i值被复制</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> output = <span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">1000</span> * i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">     output(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 隔1s输出一个值，分别是：0 1 2 3</span></span><br></pre></td></tr></table></figure>

<p><span style="color:blue;">基于Promise的解决方案</span></p>
<p>优点：提高了代码的可读性。</p>
<p><strong>注意：</strong>如果没有处理Promise的reject，会导致错误被丢进黑洞。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> tasks = [];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> output = <span class="function">(<span class="params">i</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line"> resolve();</span><br><span class="line"> &#125;, <span class="number">1000</span> * i);</span><br><span class="line"> </span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//生成全部的异步操作</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"> tasks.push(output(i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步操作完成后，输出最后的i</span></span><br><span class="line"><span class="built_in">Promise</span>.all(tasks).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(i);</span><br><span class="line"> &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行后：会隔1s输出一个值，分别是：0 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>

<p><span style="color:blue;">使用ES7中的async await特性的解决方案（推荐）</span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">timeountMS</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">setTimeout</span>(resolve, timeountMS);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123; <span class="comment">//声明即执行的async</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">         <span class="built_in">console</span>.log(i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">await</span> sleep(<span class="number">1000</span>);</span><br><span class="line">     <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// 执行后，会隔1s输出一个值，分别是：0 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>


<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 基础概念</title>
    <url>/2020/09/22/JS-basic-concept/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>回顾一些JavaScript基本概念</p>
<p>–  JS 白屏</p>
<p>–  JS FOUC 原理</p>
<p>–  async  await  defer</p>
<p>–  原型链</p>
<p>–  函数this指针</p>
</blockquote>
<a id="more"></a>

<h2 id="一、JS-白屏"><a href="#一、JS-白屏" class="headerlink" title="一、JS 白屏"></a>一、JS <code>白屏</code></h2><h3 id="白屏原因"><a href="#白屏原因" class="headerlink" title="白屏原因"></a>白屏原因</h3><ol>
<li>在弱网络下(2G网路或者GPRS网络) ,网络延迟，JS加载延迟 ,会阻塞页面</li>
<li>客户端存在bug，缓存模块错乱，不缓存js等后来挂起的文件，以及乱缓存index.html</li>
</ol>
<h3 id="白屏优化实践"><a href="#白屏优化实践" class="headerlink" title="白屏优化实践"></a>白屏优化实践</h3><blockquote>
<p>待补充</p>
</blockquote>
<h2 id="二、JS-FOUC-原理"><a href="#二、JS-FOUC-原理" class="headerlink" title="二、JS FOUC 原理"></a>二、JS <code>FOUC</code> 原理</h2><p><strong>浏览器样式闪烁</strong></p>
<p>如果使用import方法对css进行导入,会导致某些页面在Windows 下的<code>Internet Explorer</code>出现一些奇怪的现象：<strong>以无样式显示页面内容的瞬间闪烁</strong></p>
<p>这种现象称之为<code>文档样式短暂失效</code>(Flash of Unstyled Content)，简称为<code>FOUC</code>.</p>
<p><strong>原因大致为：</strong></p>
<ol>
<li>使用import方法导入样式表。</li>
<li>将样式表放在页面底部</li>
<li>有几个样式表，放在html结构的不同位置。</li>
</ol>
<blockquote>
<p>其实原理很清楚：</p>
<p>当样式表晚于结构性html 加载，当加载到此样式表时，页面将停止之前的渲染。此样</p>
<p>式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。</p>
</blockquote>
<p><strong>解决方法：</strong>使用link标签将样式表放在文档head中</p>
<h2 id="三、async-await-defer"><a href="#三、async-await-defer" class="headerlink" title="三、async   await   defer"></a>三、async   await   defer</h2><h3 id="3-1-async"><a href="#3-1-async" class="headerlink" title="3.1 async"></a>3.1 async</h3><p>带<code>async</code>关键字的函数，是声明异步函数，返回值是promise对象，如果<code>async</code>关键字函数返回的不是promise，会自动用Promise.resolve()包装。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<p>返回值为 <code>Promise &#123;&lt;resolved&gt;: &quot;test&quot;&#125;</code>。</p>
<h3 id="3-2-await"><a href="#3-2-await" class="headerlink" title="3.2 await"></a>3.2 await</h3><p><code>await</code>等待右侧表达式的结果，这个结果是promise对象或者其他值。</p>
<ul>
<li>如果它等到的不是一个 promise 对象，那 <code>await</code> 表达式的运算结果就是它等到的东西。</li>
<li>如果它等到的是一个 promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 promise 对象 resolve，然后得到 resolve 的值，作为 <code>await</code> 表达式的运算结果。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;test&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> test();</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>由于<code>test()</code>造成的阻塞，<code>console.log(&#39;end&#39;)</code>会等到两秒后执行</p>
<p>所以为了避免造成阻塞，await 必须用在 async 函数中，async 函数调用不会造成阻塞。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(<span class="string">&quot;test&quot;</span>), <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> test();</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">test2();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>先执行console.log(‘end’)，两秒后执行console.log(‘test’)</p>
<p>如果await用在普通函数中，会报错，如下：</p>
<p><img data-src="js-concept-await.png"></p>
<h3 id="3-3-async-await的执行顺序"><a href="#3-3-async-await的执行顺序" class="headerlink" title="3.3 async/await的执行顺序"></a>3.3 async/await的执行顺序</h3><p>遇到await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，继续执行await后面的代码。以下面的代码分析：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;start test1&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> test2());</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;end test1&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;test2&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="string">&#x27;return test2 value&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">test1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start async&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">    &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end async&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>执行的结果</p>
<p><img data-src="js-concept-await-demo.png"></p>
<ul>
<li>首先执行宏任务，执行<code>test1</code>函数，执行<code>console.log(&#39;start test1&#39;)</code></li>
<li>遇到<code>await</code>，先执行右边<code>test2中的console.log(&#39;test2&#39;)</code>，中断了后面的代码，执行<code>test1</code>外面的同步代码</li>
<li>执行<code>console.log(&#39;start async&#39;)</code></li>
<li>遇到<code>setTimeout</code>，推到到下个宏任务队列中</li>
<li>执行Promise里面的同步代码<code>console.log(&#39;promise1&#39;)</code></li>
<li>运行到<code>promise().then</code>，发现是promise对象，推到微任务队列中</li>
<li>执行<code>console.log(&#39;end async&#39;)</code></li>
<li><code>test1</code>外面的同步代码执行结束后，回到<code>test1</code>中，<code>console.log(await test2())</code>执行完成后**<u>返回Promise</u>** {<code>&lt;resolved&gt;</code>: “return test2 value”}，是promise对象，推到微任务队列中</li>
<li>此时第一个宏任务结束，执行所有的微任务，因为微任务队列先进先出，所以先执行<code>console.log(&#39;promise2&#39;)</code>，后执行<code>console.log(&#39;return test2 value&#39;)</code></li>
<li>执行test2完成后，后面的代码不再阻塞，执行<code>console.log(&#39;end test1&#39;)</code></li>
<li>执行下个宏任务，即执行<code>console.log(&#39;setTimeout&#39;)</code></li>
</ul>
<p><strong>补充下有关宏任务和微任务的知识</strong></p>
<p>宏任务和微任务都是队列，宏任务有<code>script</code>、<code>setTimeout</code>、<code>setInterval</code>等，微任务有<code>Promise.then catch finally</code>、<code>process.nextTick</code>等，宏任务和微任务的关系如下：</p>
<p><img data-src="js-await-task.jpg"></p>
<h3 id="3-4-async-await的优缺点"><a href="#3-4-async-await的优缺点" class="headerlink" title="3.4 async/await的优缺点"></a>3.4 async/await的优缺点</h3><p><strong>1. 优点</strong></p>
<p>相对于<code>promise</code>，<code>async/await</code>处理 then 的调用链，代码要清晰很多，几乎和同步代码一样</p>
<p><strong>2. 缺点</strong></p>
<p>滥用 await 可能会导致性能问题，因为 await 会阻塞代码</p>
<h3 id="3-5-处理reject"><a href="#3-5-处理reject" class="headerlink" title="3.5 处理reject"></a>3.5 处理reject</h3><p><strong>1. try/catch</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> function fn() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                reject(<span class="string">&#x27;err3&#x27;</span>);</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err)&#123;</span><br><span class="line">        alert(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<p><strong>2. catch</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> function fn() &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">(resolve, re    ject)</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            reject(<span class="string">&#x27;err&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn().<span class="keyword">catch</span>(alert)</span><br></pre></td></tr></table></figure>



<h3 id="3-6-脚本加载标志-async-defer"><a href="#3-6-脚本加载标志-async-defer" class="headerlink" title="3.6 脚本加载标志 async  defer"></a>3.6 脚本加载标志 <code>async</code>  <code>defer</code></h3><ol>
<li><p><span style="color:red;"><code>&lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></span></p>
<p>没有 <code>defer</code> 或 <code>async</code>，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。</p>
</li>
<li><p><span style="color:red;"><code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code></span></p>
<p>有 <code>async</code>，加载和渲染后续文档元素的过程将和 <code>script.js</code> 的加载与执行并行进行（异步）</p>
</li>
<li><p><span style="color:red;"><code>&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code></span></p>
<p>有 <code>defer</code>，加载后续文档元素的过程将和 <code>script.js</code> 的加载并行进行（异步），但是 <code>script.js</code> 的执行要在所有元素解析完成之后，<code>DOMContentLoaded</code> 事件触发之前完成</p>
</li>
</ol>
<p>然后从实用角度来说呢，首先把所有脚本都丢到 <code>&lt;/body&gt;</code> 之前是最佳实践，因为对于旧浏览器来说这是唯一的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。</p>
<p><img data-src="js-defer-1.jpg"></p>
<p>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p>
<p><strong>此图告诉我们以下几个要点：</strong></p>
<ol>
<li><em>defer</em> 和 <em>async</em> 在网络读取（下载）这块儿是一样的，都是异步的（相较于 HTML 解析）</li>
<li>差别在于脚本下载完之后何时执行，显然 <em>defer</em> 是最接近我们对于应用脚本加载和执行的要求的</li>
<li>关于 <em>defer</em>，此图未尽之处在于它是按照加载顺序执行脚本的，这一点要善加利用</li>
<li><em>async</em> 则是一个乱序执行的主，反正对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行</li>
<li>仔细想想，<em>async</em> 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics</li>
</ol>
<blockquote>
<p>一图胜千言</p>
</blockquote>
<p><img data-src="js-defer-2.jpg"></p>
<h2 id="四、原型链"><a href="#四、原型链" class="headerlink" title="四、原型链"></a>四、原型链</h2><blockquote>
<p>膜拜这位简书大佬   <a href="https://www.jianshu.com/p/116ea3be6ef5">彻底理解js的原型链</a></p>
<p>写的太牛博以至于我只能转载  </p>
<p>–  本文主要参考了<a href="https://link.jianshu.com/?t=https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">MDN文档</a>和<a href="https://link.jianshu.com/?t=https://www.zhihu.com/question/34183746">知乎讨论</a>。</p>
</blockquote>
<h3 id="由浅入深的理解原型链"><a href="#由浅入深的理解原型链" class="headerlink" title="由浅入深的理解原型链"></a>由浅入深的理解原型链</h3><p>在js中，大部分东西都是对象，数组是对象，函数也是对象，对象更加是对象。<strong>不管我们给数组和函数定义什么内容，它们总是有一些相同的方法和属性</strong>。比如说hasOwnProperty()，toString()等：</p>
<p><img data-src="chrome.png"></p>
<p><strong>这说明一个对象所拥有的属性不仅仅是它本身拥有的属性，它还会从其他对象中继承一些属性。当js在一个对象中找不到需要的属性时，它会到这个对象的父对象上去找，以此类推，这就构成了对象的原型链</strong>。理解js的原型链对使用js的对象非常有帮助。</p>
<blockquote>
<p>Chrome强大的控制台可以显示出每一个对象所有的属性！包括prototype、__proto__、constructor等</p>
</blockquote>
<p>让我们通过一个例子由浅到深地理解原型链：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">_name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = _name;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.show = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;I am &#x27;</span>, <span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo(<span class="string">&#x27;obj1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="keyword">new</span> Foo(<span class="string">&#x27;obj2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">f1.show();  <span class="comment">//  I am obj1</span></span><br><span class="line">f2.show();  <span class="comment">//  I am obj2</span></span><br></pre></td></tr></table></figure>

<p>这是我们经常使用的创建对象的方式，将共同的方法放到Foo.prototype中，所有实例都共有这个方法了。</p>
<p>这是怎么实现的呢？我们看下面这张图的第一行：</p>
<p><img data-src="prototype.jpg"></p>
<h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p><strong>先只用看第一行</strong></p>
<p>我们定义的show函数在Foo.prototype中，当我们执行<code>f1.show()</code>时，js发现f1本身没有show这个属性，所以它就到f1的原型（也就是<code>__proto__</code>指向的对象）去找，找到了就可以调用。</p>
<blockquote>
<p>注：每个对象都有一个方法<code>hasOwnProperty()</code>来检查对象本身是否有某个属性，如果有则返回true；如果这个属性在它的原型链上或原型链上都没有，则返回false；</p>
</blockquote>
<p>图片第一行告诉了我们4点：</p>
<ol>
<li><strong>所有函数都有一个prototype指针</strong>，指向原型对象，如图中的Foo的prototype指针。prototype指针的意义是，当我们使用这个构造函数new出新对象的时候，<strong>新对象的原型是谁</strong>。</li>
<li><strong>构造函数的prototype所指向的原型对象</strong>有一个constructor指针，指回构造函数。如图中Foo.prototype的constructor指针指向Foo。constructor指针有助于我们找到一个对象的构造函数是谁。</li>
<li>__proto__<strong>每个对象都有</strong>，js在new一个对象的时候，会将它的__proto__指向<strong>构造函数的prototype指向的那个对象</strong>。在上图中，f1、f2这些实例对象的__proto__都指向了Foo.prototype。</li>
<li>如果一个对象的__proto__指向了另一个对象，那么前者就继承了后者的所有属性。</li>
</ol>
<blockquote>
<p>请注意<code>__proto__</code>与prototype的区别！<code>__proto__</code>才是真正连接原型链的东西，而prototype只是构造函数的一个指针属性而已。</p>
</blockquote>
<h4 id="Js原生对象的继承关系"><a href="#Js原生对象的继承关系" class="headerlink" title="Js原生对象的继承关系"></a>Js原生对象的继承关系</h4><p><strong>理解了这个小例子我们就可以往图片的下面看了，它展示了js原生对象的继承关系是怎么样的。</strong></p>
<p>我们先看看Foo的原型吧！Foo是一个函数，它的构造函数是js内部的function Function()，Function的prototype指向了一个对象Function.prototype，因此Foo的<code>__proto__</code>就指向了<code>Function.prototype</code>，如图。</p>
<blockquote>
<p>所有的函数都以function Function()为构造函数，因此，所有函数<strong>（包括function Function()和function Object()）</strong>的<code>__proto__</code>都指向Function.prototype这个对象，这个对象中定义了所有函数都共有的方法，比如call()、apply()等。</p>
</blockquote>
<p>我们继续深入下去，Function.prototype这个对象，它就是一个普通的对象，它的构造函数是js内置的function Object()，function Object()的prototype指向Object.prototype，因此Function.prototype.<code>__proto__</code>就指向Object.prototype，这个对象中定义了所有对象共有的属性，比如我们之前说的hasOwnProperty()和toString()等。</p>
<blockquote>
<p>同理，Foo.prototype和其他自定义的对象也是<code>__proto__</code>指向Object.prototype对象，就不需要说明了。</p>
</blockquote>
<p>Object.prototype就是原型链的终点了，它的<code>__proto__</code>是null，js查找属性时，如果到这里还没有找到，那就是<code>undefined</code>了。</p>
<p>到这里就不难理解为什么我们说在js中，函数也是对象了，它就是继承自对象的！</p>
<h3 id="由原型链到继承和对象声明"><a href="#由原型链到继承和对象声明" class="headerlink" title="由原型链到继承和对象声明"></a>由原型链到继承和对象声明</h3><blockquote>
<p>转载自<a href="https://www.cnblogs.com/xfcao/p/10029731.html">JS中原型链的理解</a></p>
</blockquote>
<p><code>new</code>操作符具体干了什么呢?其实很简单，就干了三件事情。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">var obj  = &#123;&#125;;</span><br><span class="line">obj.__proto__ = <span class="module-access"><span class="module"><span class="identifier">Base</span>.</span></span>prototype;</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Base</span>.</span></span>call(obj);</span><br></pre></td></tr></table></figure>

<ul>
<li>第一行，我们创建了一个空对象obj</li>
<li>第二行，我们将这个空对象的__proto__成员指向了Base函数对象prototype成员对象</li>
<li>第三行，我们将Base函数对象的this指针替换成obj，然后再调用Base函数，于是我们就给obj对象赋值了一个id成员变量，这个成员变量的值是”base”，关于call函数的用法。</li>
</ul>
<p>在谈原型链之前，我们首先要了解自定义函数与 Function 之间是什么关系，而构造函数、原型和实例之间又存在什么千丝万缕的关系呢？</p>
<p>其实，所有的函数都是 <code>Function</code> 的实例。</p>
<p>在构造函数上都有一个原型属性 <code>prototype</code>，该属性也是一个对象；那么在原型对象上有一个 <code>constructor</code> 属性，该属性指向的就是构造函数；而实例对象上有一个 <code>_proto_</code> 属性，<span style="color:red;font-weight:bold;">该属性也指向原型对象，并且该属性不是标准属性，不可以用在编程中，该属性用于浏览器内部使用</span>。</p>
<h4 id="1-构造函数、原型和实例之间的关系"><a href="#1-构造函数、原型和实例之间的关系" class="headerlink" title="1.  构造函数、原型和实例之间的关系"></a>1.  构造函数、原型和实例之间的关系</h4><p> <strong><code>_proto_</code></strong></p>
<ul>
<li>在函数里有一个属性prototype</li>
<li>由该函数创建的对象默认会连接到该属性上</li>
</ul>
<p><strong>prototype 与 <code>_proto_</code> 的关系</strong></p>
<ul>
<li><code>_proto_</code>是站在对象角度来说的</li>
<li>prototype 是站在构造函数角度来说的</li>
</ul>
<h5 id="①-Object"><a href="#①-Object" class="headerlink" title="①+Object"></a>①+Object</h5><p><img data-src="prototype-1.png"></p>
<h5 id="②-Function-Object-Array"><a href="#②-Function-Object-Array" class="headerlink" title="②+Function+Object+Array"></a>②+Function+Object+Array</h5><p><img data-src="prototype-2.png"></p>
<p>接下来再来讨论什么是原型链。其实，就是有限的实例对象和原型之间组成有限链，就是用来实现共享属性和继承的。下面，我们看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// 对象是有原型对象的</span></span><br><span class="line"><span class="comment">// 原型对象也有原型对象</span></span><br><span class="line"><span class="comment">// obj._proto_._proto_._proto_</span></span><br><span class="line"><span class="comment">// 原型对象也有原型对象，对象的原型对象一直往上找，会找到一个null</span></span><br><span class="line"><span class="comment">// 原型链示例</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="comment">// arr -&gt; Array.prototype -&gt; Object.prototype -&gt; null</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">// o -&gt; Object.prototype -&gt; null;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name1 = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name2 = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo2.prototype = <span class="keyword">new</span> Foo1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo3.prototype = <span class="keyword">new</span> Foo2();</span><br><span class="line"><span class="keyword">var</span> foo3 = <span class="keyword">new</span> Foo3();</span><br><span class="line"><span class="built_in">console</span>.dir(foo3);</span><br></pre></td></tr></table></figure>

<p><img data-src="prototype-3.png"></p>
<p><img data-src="prototype-4.png"></p>
<h4 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h4><h5 id="2-1-原型继承"><a href="#2-1-原型继承" class="headerlink" title="2.1 原型继承"></a>2.1 原型继承</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span>(<span class="params">color</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//   var tiger = new Tiger(&#x27;yellow&#x27;);</span></span><br><span class="line"><span class="comment">//   console.log(tiger.color);</span></span><br><span class="line"><span class="comment">//   console.log(tiger.name);  //undefined</span></span><br><span class="line"><span class="comment">//   Tiger.prototype = new Animal(&#x27;老虎&#x27;);   //一种方式</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.name = <span class="string">&#x27;大老虎&#x27;</span>;   <span class="comment">//第二种方式</span></span><br><span class="line"><span class="keyword">var</span> tiger = <span class="keyword">new</span> Tiger(<span class="string">&#x27;yellow&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(tiger.color);</span><br><span class="line"><span class="built_in">console</span>.log(tiger.name);</span><br></pre></td></tr></table></figure>

<p><strong>值得注意的是，这里存在两个主要的问题：</strong></p>
<p> ①它不方便给父级类型传递参数；</p>
<p> ②父级类型当中的引用类型被所有的实例共享</p>
<h5 id="2-2-ES5-提供了Object-create-方法来实现继承"><a href="#2-2-ES5-提供了Object-create-方法来实现继承" class="headerlink" title="2.2 ES5 提供了Object.create() 方法来实现继承"></a>2.2 ES5 提供了Object.create() 方法来实现继承</h5><p>这种方法是ES5的新特性，其实就是<strong>复制继承</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">————做兼容</span><br><span class="line"><span class="comment">//shim垫片</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.create)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.create(obj);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">        Foo.prototype = obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-3-拷贝继承"><a href="#2-3-拷贝继承" class="headerlink" title="2.3 拷贝继承"></a>2.3 拷贝继承</h5><p>初始化 <code>obj</code> 时，生成相应的 <code>__proto__</code>；通过此函数获取继承属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.extend = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">        <span class="built_in">this</span>[k] = obj[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-借用构造函数继承"><a href="#2-4-借用构造函数继承" class="headerlink" title="2.4 借用构造函数继承"></a>2.4 借用构造函数继承</h5><p>被借用的构造函数中原型上的成员没有被借过来</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mouse</span>(<span class="params">nickname</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    Animal.call(<span class="built_in">this</span>,<span class="string">&#x27;老鼠&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.nickname = nickname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> Mouse(<span class="string">&#x27;杰瑞&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(m.name);</span><br><span class="line"><span class="built_in">console</span>.log(m.nickname);</span><br></pre></td></tr></table></figure>

<p><strong>存在的问题：</strong>可以解决原型继承当中传参问题，但是父类型当中的原型对象上的成员（属性和方法）不能被继承到</p>
<h5 id="2-5-组合继承"><a href="#2-5-组合继承" class="headerlink" title="2.5 组合继承"></a>2.5 组合继承</h5><p>——prototype对象是有动态性的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">   Person.call(<span class="built_in">this</span>,name);</span><br><span class="line">   <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Student.prototype = <span class="keyword">new</span> Person();</span><br><span class="line">Student.prototype.contructor = Student;</span><br><span class="line">Student.prototype.showAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = <span class="keyword">new</span> Student(<span class="string">&#x27;张三&#x27;</span>,<span class="number">12</span>);</span><br><span class="line">stu.showName();</span><br><span class="line">stu.showAge();</span><br></pre></td></tr></table></figure>

<p>【原型继承+借用构造函数继承】它的特点就是属性每个实例一份，方法共享</p>
<p><strong>【小结】</strong>套用一句很粗暴的话，所谓原型链就是找妈的一种行为方式，就可以理解为人是人他妈生的，妖是妖他妈生的。原型链的核心其实就只有一个：属性共享和独立的控制，当你的对象实例需要独立的属性，所有做法的本质都是在对象实例里面创建属性。若不考虑太多，你大可以在Person里面直接定义你所需要独立的属性来覆盖掉原型的属性。总之，使用原型继承的时候，要对于原型中的属性要特别注意，因为他们都是牵一发而动全身的存在。现在最常用的方法是<strong>组合模式</strong>。</p>
<h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><h5 id="3-1-原型链"><a href="#3-1-原型链" class="headerlink" title="3.1 原型链"></a>3.1 原型链</h5><p>  <strong>1）构造函数、原型和实例的关系</strong></p>
<p>​    ①构造函数都有一个属性prototype，这个属性是一个对象（Object的实例）</p>
<p>​    ②原型对象prototype里面有一个constructor属性，该属性指向原型对象所属的构造函数</p>
<p>​    ③实例对象都有一个_proto_属性，该属性也指向构造函数的原型对象，它是一个非标准属性，不可以用于编程，它是用于浏览器自己使用的</p>
<p>  <strong>2）prototype与_proto_的关系</strong></p>
<p>​    ①prototype是构造函数的属性</p>
<p>​    ②<code>_proto_</code>是实例对象的属性</p>
<p>​          ——这两者都指向同一个对象</p>
<p>  <u>【总结】</u></p>
<p>​      i）函数也是对象，对象不一定是函数；</p>
<p>​      ii）对象的本质：无序的键值对集合；键值对当中的值可以是任意数据类型的值</p>
<p>​      iii）对象就是一个容器，这个容器当中放的是（属性和方法）</p>
<p>  <strong>3）属性搜索</strong></p>
<p>  　　① 在访问对象的某个成员的时候会先在对象中找是否存在</p>
<p>  　　② 如果当前对象中没有就在构造函数的原型对象中找</p>
<p>  　　③ 如果原型对象中没有找到就到原型对象的原型上找</p>
<p>  　　④ 知道<code>Object</code>的原型对象的原型是null为止</p>
<h5 id="3-2-Function"><a href="#3-2-Function" class="headerlink" title="3.2 Function"></a>3.2 Function</h5><p><strong>——所有函数都是Function的实例</strong></p>
<p>  ①本地对象：独立于宿主环境（浏览器）的对象</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">——  包括<span class="built_in">Object</span>、<span class="built_in">Array</span>、<span class="built_in">Date</span>、<span class="built_in">RegExp</span>、<span class="built_in">Function</span>、<span class="built_in">Error</span>、<span class="built_in">Number</span>、<span class="built_in">String</span>、<span class="built_in">Boolean</span></span><br></pre></td></tr></table></figure>

<p>  ②内置对象——包括Math、Global（window，在js中就是全局变量），使用的时候不需要new</p>
<p>  ③宿主对象——包括<code>自定义对象</code>、<code>DOM</code>、<code>BOM</code></p>
<h4 id="4-回顾-new-操作符的使用过程"><a href="#4-回顾-new-操作符的使用过程" class="headerlink" title="4. 回顾 new 操作符的使用过程"></a>4. 回顾 <code>new</code> 操作符的使用过程</h4><blockquote>
<p>参考<a href="https://www.cnblogs.com/kevin2chen/p/6418327.html">JS中new一个对象的过程</a></p>
</blockquote>
<p>使用new关键字调用函数（<strong>new</strong> ClassA**(…)**）的具体步骤：</p>
<p><strong>4.1 创建空对象；</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>4.2 设置新对象的constructor属性为构造函数的名称，设置新对象的<code>__proto__</code>属性指向构造函数的prototype对象；</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj.__proto__ = ClassA.prototype;</span><br></pre></td></tr></table></figure>

<p><strong>4.3 使用新对象调用函数，函数中的this被指向新实例对象：</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">ClassA</span>.</span></span>call(obj);　　<span class="comment">//&#123;&#125;.构造函数(); </span></span><br></pre></td></tr></table></figure>

<p><strong>4.4 将初始化完毕的新对象地址，保存到等号左边的变量中</strong></p>
<p>注意：若构造函数中返回this或返回值是基本类型（number、string、boolean、null、undefined）的值，则返回新实例对象；若返回值是引用类型的值，则实际返回值为这个引用类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="built_in">this</span>.foo = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> test();                     <span class="comment">//test中的this指新对象，并未改变全局的foo属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.foo);          <span class="comment">// &quot;bar&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> test().foo);      <span class="comment">// &quot;foo&quot;;</span></span><br></pre></td></tr></table></figure>

<p><strong>优先级问题：</strong></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">优先级由高到低</a>：小括号(xxx) —&gt; 属性访问.  —&gt; new foo() —-&gt; foo()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>); </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//先从.属性访问符号开始往前面找一个最近的对象，同时注意new Foo()优先于Foo();</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="keyword">new</span> Foo.getName();<span class="comment">//3;===new (Foo.getName)();返回Foo.getName类型的实例</span></span><br><span class="line"><span class="keyword">var</span> b=<span class="keyword">new</span> Foo().getName();<span class="comment">//2;===(new Foo()).getName()；返回undefined</span></span><br><span class="line"><span class="keyword">var</span> c=<span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();<span class="comment">//2;===new (new Foo().getName)();返回Foo.getName类型的实例</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().getTime();<span class="comment">//===((new Date()).getTime)()</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Date</span>).getTime();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>.getTime();<span class="comment">//Uncaught TypeError: Date(...).getTime is not a function；===new (Date.getTime)()</span></span><br></pre></td></tr></table></figure>

<h3 id="原型链相关实践应用"><a href="#原型链相关实践应用" class="headerlink" title="原型链相关实践应用"></a>原型链相关实践应用</h3><blockquote>
<p>两道很不错的，而且讲的很完美的试题。</p>
<p>转载自  <a href="https://www.jianshu.com/p/ae7afb5ba420">陌上寒</a></p>
</blockquote>
<h4 id="五条原型原则"><a href="#五条原型原则" class="headerlink" title="五条原型原则"></a>五条原型原则</h4><ol>
<li>所有的引用类型（数组，对象，函数）都具有对象特性，即可自由扩展属性（除了null以外）</li>
<li>所有的引用类型（数组，对象，函数），都有一个<em>proto</em>属性，属性值是一个普通的对象    （隐式原型）</li>
<li>所有的函数，都有一个prototype属性，属性值也是一个普通的对象</li>
<li>所有的引用类型（数组，对象，函数），<em>proto</em>属性值指向他构造函数的prototype属性值</li>
<li>当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的<em>proto</em>(即它的构造函数的prototype)中寻找</li>
</ol>
<h4 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a) &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">A.prototype.a = <span class="number">1</span>;</span><br><span class="line">B.prototype.a = <span class="number">1</span>;</span><br><span class="line">C.prototype.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> A().a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> B().a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> C(<span class="number">2</span>).a);</span><br></pre></td></tr></table></figure>

<p>我们一起拆解一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一个构造函数A</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">//新建一个构造函数B，并添加一个自有属性a，属性a的值取决于传入的参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建一个构造函数C，如果有参数，则添加自有属性a，属性a的值为传入的参数值，</span></span><br><span class="line"><span class="comment">//如果没有传入参数，则构造函数C没有自有属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a) &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在A的原型对象上添加一个属性a，属性a的值是1，(两个同理)</span></span><br><span class="line">A.prototype.a = <span class="number">1</span>;</span><br><span class="line">B.prototype.a = <span class="number">1</span>;</span><br><span class="line">C.prototype.a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><strong>求A的实例下属性a的值即new A().a</strong></p>
<p>构造函数<code>function A()&#123;&#125;</code>,是没有自有属性的，没有怎么办？顺着原型链查找，我们找到构造函数A的原型对象<code>A.prototype</code>，<br> 因为<code>A.prototype.a = 1</code>;<br> 所以<code>console.log(new A().a);</code>输出1<br> 还可以这么拆解</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo =  <span class="keyword">new</span> A()</span><br><span class="line"><span class="built_in">console</span>.log(foo.a)</span><br></pre></td></tr></table></figure>

<p>同样的构造函数A下面找不到属性<code>a</code>，那就得顺着原型链查找，即<code>foo._proto_</code>我们知道<br> 五条原型原则的第四条</p>
<blockquote>
<p>4     所有的引用类型（数组，对象，函数），<em>proto</em>属性值值向他构造函数的prototype属性值</p>
</blockquote>
<p>所以我们得出<br> <code>foo._proto_===A.prototype</code><br> 因为已知条件<code>A.prototype.a = 1;</code><br> 最后在原型链上找到了属性a<br> 看图</p>
<p><img data-src="prototype-5.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> A().a)        <span class="comment">//1</span></span><br></pre></td></tr></table></figure>


<p> 如果这个理解了，那么下面的两个自然也就引刃而解</p>
<p><strong>求B的实例下属性a的值即new B().a</strong></p>
<p>我们知道B实例下是有属性a的，a的值等于传入的参数，因为创建B实例的时候没有传入参数所以最后输出==&gt;<code>undefined</code></p>
<p> <strong>注意</strong><br> 这里有个地方要说明一下<br> 由于构造函数B存在属性a，但是由于没有传入参数，导致属性a的值是<code>undefined</code>，<br> 后来又一次执行了   <code>B.prototype.a = 1;</code>，在B的原型上添加了属性a，并赋值为1，当查找属性或方法是，先查找自身，自身没有，再去原型链上的，如果在自身找到了，就会停止，<br> 这个例子中，我们找到了a但是a的值是undefined，<strong>undefined也是值</strong>，找到了就停止，尽管原型链上还有值，js也不会继续查找下去<br> 所以这个例子很经典，贴个图，感受一下</p>
<p><img data-src="prototype-6.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> B().a);        <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>求C的实例下属性a的值即new C(2).a</strong></p>
<p>如果👆两题都懂了，这个就是小case<br> 实例化一个构造函数C并传入参数2，因为有参数，所以，构造函数C存在自有属性a，并且属性a的值为2<br> <code>C.prototype.a = 1;</code><br> 在C的原型对象上添加一个属性a，并且赋值1<br> 然后就出现这样的情况，自有属性和原型属性都存在，这时候取值当然就是从自有属性中取啦<br> 来个图感受一下</p>
<p><img data-src="prototype-7.png"></p>
<p>所以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> C(<span class="number">2</span>).a);    <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p>在第二题开始之前我们很有必要先复习一下昨天的一个知识点？为什么说很有必要呢？因为这是一把🔑，它是解开这道题目的关键 <strong>instanceof</strong></p>
<blockquote>
<p>instanceof用于判断一个变量是否某个对象的实例</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.prototype.a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a()&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Function</span>.prototype.b = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;b()&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F();</span><br><span class="line">F.a();<span class="comment">//a()</span></span><br><span class="line">F.b();<span class="comment">//b()</span></span><br><span class="line">f.a();<span class="comment">//a()</span></span><br><span class="line">f.b();<span class="comment">//Uncaught TypeError: f.b is not a function</span></span><br></pre></td></tr></table></figure>

<p>F是个构造函数，而f是构造函数F的一个实例。<br>到<code>instanceof</code>发力的时候了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(F <span class="keyword">instanceof</span> <span class="built_in">Object</span>);</span><br><span class="line"><span class="built_in">console</span>.log(F <span class="keyword">instanceof</span> <span class="built_in">Function</span>);</span><br></pre></td></tr></table></figure>

<p>所以我们得出结论<br>F是<code>Object</code> 和 <code>Function</code>两个的实例，执行代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(F.prototype);</span><br></pre></td></tr></table></figure>

<p>看输出</p>
<p><img data-src="prototype-8.png"></p>
<p><strong>即F既能访问到a，也能访问到b。</strong><br>所以F.a() 输出 a()     F.b() 输出 b()<br>继续</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> F);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(f <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p><code>f</code> 并不是<code>Function</code>的实例，因为它本来就不是构造函数，所以就不能调用Function原型链上的相关属性和方法了，只能访问<code>Object</code>原型链。<br> 所以f.a() 输出  a()， 而f.b()就报错了。</p>
<p> 接下来，我们具体分析下，它们是如何按路径查找的：</p>
<ul>
<li>f.a()的查找路径: f自身: 没有 —&gt; <code>f._proto_(Object.prototype)</code>: 输出a()</li>
<li>f.b()的查找路径: f自身: 没有 —&gt; <code>f._proto_(Object.prototype)</code>: 没有 —&gt; <code>f._proto_._proto_</code> (<code>Object.prototype._proto_</code>): 因为找不到，所以报错</li>
<li>F.a()的查找路径: F自身: 没有 —&gt; <code>F._proto_(Function.prototype)</code>: 没有 —&gt; <code>F._proto_._proto_(Object.prototype)</code>: 输出 a()</li>
<li>F.b()的查找路径: F自身: 没有 —&gt; <code>F._proto_(Function.prototype)</code>: b()</li>
</ul>
<h2 id="五、函数this指针"><a href="#五、函数this指针" class="headerlink" title="五、函数this指针"></a>五、函数<code>this</code>指针</h2><blockquote>
<p>转载  <a href="https://www.cnblogs.com/zjjDaily/p/9482958.html">深入理解JS函数中this指针的指向</a></p>
<p>大神写的太牛掰，我无言补充，跪拜！</p>
</blockquote>
<p><strong>核心</strong>： </p>
<p><strong>函数在执行时，会在函数体内部自动生成一个<code>this</code>指针。<span style="color:red;">谁直接调用产生这个this指针的函数，this就指向谁。</span></strong></p>
<p>怎么理解指向呢，我认为指向就是等于。例如直接在js中输入下面的等式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>===<span class="built_in">window</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p> 情况不同，this指向的对象也不同。例如：</p>
<h3 id="1-函数声明的情况"><a href="#1-函数声明的情况" class="headerlink" title="1. 函数声明的情况"></a>1. 函数声明的情况</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bj=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);<span class="comment">//10</span></span><br><span class="line">    <span class="built_in">console</span>.log(bj);<span class="comment">//20</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj+bj);<span class="comment">//30</span></span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line"><span class="built_in">window</span>.add();</span><br></pre></td></tr></table></figure>

<p>（1） 执行了add（）之后，此时的this指向的是window对象，为什么呢？因为这时候add是全局函数，是通过window<strong>直接调用</strong>的。所以下面我专门写了个window.add()就是为了说明，全局函数的this都是指向的window。</p>
<p>（2） 就像alert（）自带的警告弹窗一样,window.alert（）执行之后也是一样的效果。所以只要是  window点  这种调用方式都可以省略掉，因此警告弹窗可以直接使用alert（）。</p>
<h3 id="2-函数表达式"><a href="#2-函数表达式" class="headerlink" title="2. 函数表达式"></a>2. 函数表达式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> zjj=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bj=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);<span class="comment">//10</span></span><br><span class="line">    <span class="built_in">console</span>.log(bj);<span class="comment">//30</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj+bj);<span class="comment">//40</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> zjj);<span class="comment">//function</span></span><br><span class="line">zjj();</span><br><span class="line"><span class="built_in">window</span>.zjj();</span><br></pre></td></tr></table></figure>

<p>（1） 执行了zjj（）之后，函数中的this也是指向window对象。原因和第一个是一样的，都是通过window这个对象<strong>直接调用</strong>。</p>
<h3 id="3-函数作为对象的属性去调用"><a href="#3-函数作为对象的属性去调用" class="headerlink" title="3. 函数作为对象的属性去调用"></a>3. 函数作为对象的属性去调用</h3><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">&quot;八戒&quot;</span>,</span><br><span class="line">    age:<span class="string">&quot;500&quot;</span>,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bj=<span class="number">40</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//就是obj这个对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);<span class="comment">//undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);<span class="comment">//八戒</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();</span><br><span class="line"><span class="built_in">window</span>.obj.say();    </span><br></pre></td></tr></table></figure>

<p>（1） 当obj.say（）被执行的时候，此时的this指向的是 obj 这个对象，为什么呢？因为say函数是通过obj这个对象<strong>直接调用</strong>的。</p>
<p>（2） 那有人可能会问了，obj对象实际上也是通过window对象调用的，为什么this不指向window呢？我认为是因为say这个函数是通过 <strong>obj</strong> 对象<strong>直接调用</strong>的，而没有通过 window 对象<strong>直接调用</strong>，因此this不会指向window。看下面的例子就明白了。</p>
<h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">&quot;八戒&quot;</span>,</span><br><span class="line">    age:<span class="number">500</span>,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//是obj这个对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);<span class="comment">//undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)<span class="comment">//八戒</span></span><br><span class="line">    &#125;,</span><br><span class="line">    action:&#123;</span><br><span class="line">        name:<span class="string">&quot;悟空&quot;</span>,</span><br><span class="line">        age:<span class="number">1000</span>,</span><br><span class="line">        say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//是action这个对象</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);<span class="comment">//undefined</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)<span class="comment">//悟空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();</span><br><span class="line">obj.action.say();</span><br><span class="line"><span class="built_in">window</span>.obj.action.say();</span><br></pre></td></tr></table></figure>

<p>（1） obj.say()执行之后，此时这个函数里的this指向的是obj对象，原因是因为say函数是通过obj<strong>直接调用</strong>的。</p>
<p>（2） obj.action.say()执行之后，此时这个函数里的this指向的是action对象，原因是因为say函数是通过action对象<strong>直接调用</strong>的。并没有通过obj<strong>直接调用</strong>。也没有通过 window <strong>直接调用</strong>，所以此时action对象中say函数里的的this指向并不会是obj或者window。</p>
<h4 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">&quot;八戒&quot;</span>,</span><br><span class="line">    age:<span class="number">500</span>,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//就是obj这个对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);<span class="comment">//undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)<span class="comment">//八戒</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">wk</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);<span class="comment">//10</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);<span class="comment">//这里显示的是为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        wk();        </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure>

<p>（1） 这种情况下，say函数里的this指针还是指向的obj，原因是因为say函数是通过obj<strong>直接调用</strong>。</p>
<p>（2） <span style="color:red;">但是这时候wk函数中的this就是指向的是window了。为什么呢？因为 wk（）函数在 say（）函数中，是属于普通函数调用，但是并没有通过say或者obj<strong>直接调用</strong>，只是自执行，这个时候，wk就是一个全局函数，因此该函数的this指向的就是window。</span></p>
<p>（3） 那为什么this.name是显示的为空呢？因为 window 对象中本身就有一个 name 值，并不是某处添加的，如果把name换成age，得到的就是undefined了。</p>
<p>（4） <span style="color:#F74A70">那怎样让wk（）函数中的this指向obj呢。<strong>一种方式</strong>就是在say函数中把say（）函数的this用变量保存起来，即 <code>var that=this;</code> 然后wk（）函数使用that就能达到指向obj的目的了。<strong>另外的方式是通过apply或者call来改变。</strong></span></p>
<p>（5）<span style="color:#EDC547;"> 那wk（）在这里能不能写成<code>window.wk()</code>呢？这样是不行的，会报错，<code>window.wk is not a function</code>。为什么不行呢，this不是指向window吗，为什么widow对象里灭有wk（）这个函数。。这个嘛，我也不知道，先留个坑，后面再来填</span></p>
<h4 id="例四"><a href="#例四" class="headerlink" title="例四"></a>例四</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">&quot;八戒&quot;</span>,</span><br><span class="line">    age:<span class="string">&quot;500&quot;</span>,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> bj=<span class="number">40</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);<span class="comment">//10</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);<span class="comment">//这里没有输出内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> elseObj=obj.say;</span><br><span class="line">elseObj();</span><br></pre></td></tr></table></figure>

<p> （1） 执行了<code>elseObj（）</code>函数之后，为什么say函数中的this却指向了window呢？首先要理解这句话：<strong>谁直接调用产生这个this指针的函数，this就指向谁</strong>。<strong>当<code>obj.say</code>赋值给<code>elseObj</code>的时候，elseObj只是一个函数，而并没有执行，因此this指针的指向并不明确</strong>，这个时候执行到 <code>var elseObj=obj.say</code>的 时候，整程序相当于：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> elseObj=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bj=<span class="number">40</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">elseObj();</span><br></pre></td></tr></table></figure>

<p> 　 这就和 <strong>第2种 函数表达式</strong>的情况一样了。所以，当执行elseObj（）的时候，this就指向window，this.obj为10，因为这时候elseObj（）是通过 window <strong>直接调用</strong>的</p>
<p>（2） this.name为空是因为 window 对象中本身就有一个 name 值，并不是某处添加的，如果把name换成其它的比如age，得到的就是undefined了，因为全局并没有age属性。</p>
<h4 id="例五"><a href="#例五" class="headerlink" title="例五"></a>例五</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">    name:<span class="string">&quot;八戒&quot;</span>,</span><br><span class="line">    age:<span class="number">500</span>,</span><br><span class="line">    say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);<span class="comment">//10</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);<span class="comment">//undefined</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say()();</span><br><span class="line"><span class="comment">//    var elseObj=obj.say();</span></span><br><span class="line"><span class="comment">//    elseObj();</span></span><br></pre></td></tr></table></figure>

<p>（1） obj.say（）（）为什么会有两个括号？因为obj.say（）执行之后返回的是一个函数，并没有执行，再加一个括号就是执行返回的那个匿名函数。</p>
<p>（2） 如果不习惯也可以使用上面注释的那种方式，是一样的效果。</p>
<p>（3） 执行了函数之后，为什么返回的函数中this是指向window的呢？那是因为执行obj.say（）的时候，只是一个函数，相当于就是注释里的第一行代码，这时候返回的函数并未被执行。当再加一个括号的时候，就是执行了返回的那个函数，这个时候返回的函数就相当于是一个全局函数，是通过window<strong>直接调用</strong>，因此this就是指向的是window。</p>
<h3 id="4-工厂模式中this的指向"><a href="#4-工厂模式中this的指向" class="headerlink" title="4. 工厂模式中this的指向"></a>4. 工厂模式中this的指向</h3><blockquote>
<p>工厂模式可以理解为在内部完成一个新对象的构建；而构造函数模式可以理解为工厂外派员工在外去完成一个新对象的构建。</p>
</blockquote>
<h4 id="例一-1"><a href="#例一-1" class="headerlink" title="例一"></a>例一</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a,b</span>)</span>&#123;　　 </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window对象</span></span><br><span class="line">    <span class="keyword">var</span> bj=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">var</span> sun=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    sun.one=a;</span><br><span class="line">    sun.two=b;</span><br><span class="line">    sun.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//是sun对象，&#123;one: 2, two: 3, say: ƒ()&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);<span class="comment">//undefined</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.one);<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wk=fun(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">wk.say();</span><br></pre></td></tr></table></figure>

<p> （1） 话说为什么叫工厂模式，我搞不太清楚，不过这个不重要，重要的是通过这个模式，在每次调用函数的时候，虽然每次都返回的是sun这个对象，但是每个对象都是不相似的，即使内容一样，比如 : (引用类型，其地址不同)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sf=fun(<span class="number">2</span>,<span class="number">3</span>); <span class="built_in">console</span>.log(sf===wk);     <span class="comment">//false </span></span><br></pre></td></tr></table></figure>

<p>（2） 那为什么say（）函数执行之后，this是指向返回的那个对象呢？这个很明显嘛，say（）是通过wk这个对象<strong>直接调用</strong>的，而wk是fun函数返回sun对象。所以这里的this就指向的是返回的对象。所以<code>this.bj = undefined</code>，因为返回的对象中没有bj属性。</p>
<p>（3） 我认为这种模式最重要的还是 <code>renturn sun</code>这个返回语句，这个是必不可少的。</p>
<p>（4） fun(a,b)这个函数中的this指向的是window，原因是执行 <code>var wk=fun(2,3);</code> 的时候，fun函数已经被执行了，并且<strong>直接调用</strong>它的就是window，所以这时的this是指向的window。</p>
<h4 id="例二-1"><a href="#例二-1" class="headerlink" title="例二"></a>例二</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a,b</span>)</span>&#123;　　 </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window对象</span></span><br><span class="line">    <span class="keyword">var</span> bj=<span class="number">20</span>;</span><br><span class="line">    <span class="keyword">var</span> sun=<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    sun.one=a;</span><br><span class="line">    sun.two=b;</span><br><span class="line">    sun.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//是sun对象，&#123;one: 2, two: 3, say: ƒ()&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//是window对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wk=fun(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> ss=wk.say();</span><br><span class="line">ss();</span><br></pre></td></tr></table></figure>

<p> （1） 为什么say函数中return 的函数中this是指向的window对象呢？首先，执行到 <code>var wk=fun(2,3);</code> 的时候<strong>，wk是一个对象。</strong>继续执行下一句代码，ss这时候是一个函数，就是通过say函数返回之后赋值的。这时候返回的函数还未执行，this指向并不明确。当执行到最后一句代码，ss（）函数执行了。这时候，<strong>ss函数就是一个全局函数</strong>，是通过window<strong>直接调用</strong>的。所以这时的this指向的是window。</p>
<p>（2） 如果say中返回的是一个对象，对象中又有个函数，像下面一样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sun.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//是sun对象，&#123;one: 2, two: 3, say: ƒ()&#125;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        wk:<span class="string">&quot;1&quot;</span>,</span><br><span class="line">        say:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候执行到ss.say()的时候，this指向的就是ss这个对象，即通过say函数返回的那个对象。<strong>原因还是一样，say函数是通过ss直接调用的，而ss对象是wk.say()返回的对象。</strong></p>
<h3 id="5-构造函数中this的指向"><a href="#5-构造函数中this的指向" class="headerlink" title="5. 构造函数中this的指向"></a>5. 构造函数中this的指向</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bj=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">this</span>.bj=<span class="number">30</span>;</span><br><span class="line">    <span class="built_in">this</span>.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//Add &#123;bj: 30, say: ƒ()&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.bj);<span class="comment">//30</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) ;<span class="comment">//Add &#123;bj: 30, say: ƒ()&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Add();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> obj);<span class="comment">//object</span></span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure>

<p> （1） 要明白构造函数的this指向，我们需要明白<strong>调用构造函数经历的步骤</strong>：<code>摘至JS高程 6.2.2节</code></p>
<p>　　a.  创建一个新对象。</p>
<p>　　b.  将构造函数的作用域赋给新对象（因此this就指向了这个新对象）。</p>
<p>　　c.  执行构造函数中的代码（为这个新对象添加属性）。</p>
<p>　　d.  返回新对象。</p>
<p>　　<span style="color:#1f6fb5;font-weight:bold;font-style:italic;">这个对new一个对象的解释，是最易懂的说法</span></p>
<p>（2） <strong>构造函数与工厂模式相比</strong>：</p>
<p>　　a.  没有显式的创建对象。</p>
<p>　　b.  没有return语句。</p>
<p>　　c.  直接将属性和方法赋值给 this 对象。</p>
<p>（3） 首先，<strong>obj.say()执行之后，say函数中this的指向是obj对象</strong>，这个很明显，不再赘述。在不用new操作符的时候，Add()函数里的this指向的就是window；但是使用了new操作符之后，Add()函数中 <code>console.log(this)</code> 这个this为什么是obj对象，而不是window呢？</p>
<p>​    这个原因我认为在js权威指南4.6节对象创建表达式和8.2.3构造函数使用中，有所说明。<strong>使用new操作符的时候，js先创建一个新的空对象，然后，js传入指定的参数并将这个新对象当做this的值来调用一个指定的函数。这个函数可以使用this来初始化这个新创建对象的属性。所以当使用new操作符之后，函数中的this指向的是新创建的对象。所以构造函数中的this就是指向new出来的那个对象。</strong></p>
<p>（5） 如果构造函数中有return语句，那么此时 <code>var obj=new Add();</code> obj就是return出来的内容，但是Add函数中的this还是指向的创建的新对象Add；</p>
<h3 id="6-原型对象中this的指向"><a href="#6-原型对象中this的指向" class="headerlink" title="6. 原型对象中this的指向"></a>6. 原型对象中this的指向</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bj=<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params"></span>)</span>&#123;　　</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//Add&#123;&#125;&#125;;</span></span><br><span class="line">    Add.prototype.bj=<span class="number">10</span>;</span><br><span class="line">    Add.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//Add&#123;&#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Add;<span class="comment">//没传参数可以省略括号</span></span><br><span class="line">obj.say()();</span><br></pre></td></tr></table></figure>

<p> （1） obj.say()()执行的时候，this指向的是window，<strong>这个还是因为obj.say()执行时返回的是一个函数</strong>，然后再加一个括号，就执行返回的这个函数，此时这个函数属于全局函数，所以，this会指向window</p>
<p>（2） Add()这个构造函数中的this指向的是Add{}，原因和上面构造函数中this的指向一样。</p>
<p>（3） <code>Add.prototype.say=function()&#123; console.log(this) &#125;</code> 这里面的this 也是指向的是Add{}，至于原因，我认为是因为say（）这个函数是通过obj直接调用的，所以this指向的是obj，所以是Add{}。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>　　<strong>要想判断函数中this的指向，只要知道谁直接调用产生this指针的函数，this就指向谁了</strong>。</p>
<p>　　<strong>只是要注意使用了new 操作符之后，构造函数内部的this指向的是新对象，通俗点讲就是new出来的新实例。</strong></p>
<h3 id="补充和挖坑"><a href="#补充和挖坑" class="headerlink" title="补充和挖坑"></a>补充和挖坑</h3><p>再来一个例子说明一下，通俗的理解一下this指针的指向：<strong>谁直接调用产生 this 指针的函数，这函数里的 this 指针就指向谁。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> factory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="string">&#x27;first-A&#x27;</span>;  </span><br><span class="line">  <span class="built_in">this</span>.b = <span class="string">&#x27;first-B&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.c = &#123;</span><br><span class="line">    a:<span class="string">&#x27;second-A&#x27;</span>,</span><br><span class="line">    b:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.a)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> factory().c.b(); <span class="comment">// second-A</span></span><br></pre></td></tr></table></figure>

<p>（1） 这个代码首先考的是运算符的优先级   <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">MDN运算符优先级 </a> </p>
<p>（2） <code>new的优先级</code>和 <code>点运算符等级</code>一样，从左至右执行，所以先执行 <code>new factory()</code> 然后再执行 <code>点运算符</code>。</p>
<p>（3） 执行了 new 操作之后，然后发现函数调用的优先级和成员访问运算符的优先级一样，然后遵循从左到右的执行方式。因此就先执行 成员访问运算符 .c</p>
<p>（4） 这时 .c 就是一个对象，然后再取 b 属性，是个函数。这个时候 this 指针已经产生， 而产生这个this指针的是b函数，而且是通过 c 调用的。<strong>因此此时 this 的指向就是 c 对象。所以最后打印出<code>second-A</code></strong></p>
<p>（5） 如果想要 c 里面的 b函数中 this指向的是 factory 实例。<strong>要么使用 bind.apply,call等方法来强行改变</strong>； <strong>要么就把 b 函数写成 es6箭头函数的方式</strong>。这样 b 函数就没有this指针，而 b 函数里面的this，就是上一级的 this。</p>
<p>然后再来说一下  <strong>回调函数  |  立即执行函数（IIFE）  | 点击事件</strong>  的 this 的指向</p>
<p>在这之前我们要知道：函数传参是按值传递，如果是<strong>基本数据类型</strong>，则是直接复制数据的值传过去；如果是<strong>引用类型</strong>，比如对象，函数这种，传递的就是该数据 <strong>在堆中存放的地址</strong>。 </p>
<p>那么，<span style="color:red;">回调函数就是传的 <strong>函数在堆中的地址</strong>，也就是说，<strong>回调函数中 this 的指向，决定于执行回调函数 时的执行上下文环境。</strong></span></p>
<p><strong>首先是 setTimeout，setInterval 这种类型的回调函数。</strong></p>
<h4 id="7-setTimeout的回调"><a href="#7-setTimeout的回调" class="headerlink" title="7. setTimeout的回调"></a>7. setTimeout的回调</h4><p><strong>例一</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>) </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>（1） 这是最最常用的常见的定时器用法，<strong>回调函数里的this指向的是window。</strong></p>
<p>（2） 由<code>setTimeout()</code>调用的代码运行在与所在函数完全分离的执行环境上。这会导致，这些代码中包含的 <code>this</code> 关键字在非严格模式会指向 <code>window</code> (或全局)对象，严格模式下为 <code>undefined</code>，这和所期望的<code>this</code>的值是不一样的。<strong>在严格模式下，setTimeout( )的回调函数里面的this仍然默认指向window对象， 并不是undefined</strong>。 这几句话是 MDN上，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout">setTimeout中 关于 this 的问题</a> 里对 this 指向的解释。</p>
<p>（3） 我的理解是：由于setTimeout属于宏任务，它的回调在延时之后才进入到主线程执行，而函数执行的时候才明确 this 的指向。执行的时候，由于没有设置内部this的指向。相当于是普通函数调用。所以会默认指向window</p>
<p><strong>例二</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    age:<span class="number">10</span>,</span><br><span class="line">    getage:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(obj.getage,<span class="number">1000</span>)   <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    obj.getage()  <span class="comment">// 10</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>（1） 第一个setTimeout，执行obj.getage 之后，<strong>相当于setTimeout的回调是一个匿名函数，执行的时候，函数内部未设置this的指向。相当于是普通函数调用</strong>。所以this默认指向<code>window</code>，所以结果是<code>undefined</code>。</p>
<p>（2） 第二个setTimeout，传给setTimeout的也是一个匿名回调函数，执行匿名函数，执行到 obj.getage() 的时候，getage函数里的this，指向的就是obj了，所以能打印出10。<strong>还是遵循 谁调用产生 this指针的函数，this就指向谁的规则</strong></p>
<h4 id="8-对于-数组的遍历方法-中的this"><a href="#8-对于-数组的遍历方法-中的this" class="headerlink" title="8. 对于 数组的遍历方法 中的this"></a>8. 对于 数组的遍历方法 中的<code>this</code></h4><p><strong>foreach，map，filter，some</strong>，每次 <code>callback</code> 函数被调用的时候，<code>this</code> 都会指向 最后一个参数 <code>thisArg</code> 的这个对象。如果省略了 <code>thisArg</code> 参数,或者赋值为<code> null</code> 或 <code>undefined</code>，则 this 指向全局对象 。在严格模式下则是undefined（未传值的时候）。如果用箭头函数的写法，就要看当前上一层的 this 指向的是哪里了</p>
<p>reduce 累加器的参数中并没有 thisArg 对象可以传，但是在回调函数中，this指向的是window。如果用箭头函数的写法，就要看当前上一层的 this 指向的是哪里了</p>
<h4 id="9-点击、移入移出等类似事件的回调函数-的-this-指向"><a href="#9-点击、移入移出等类似事件的回调函数-的-this-指向" class="headerlink" title="9. 点击、移入移出等类似事件的回调函数 的 this 指向"></a>9. 点击、移入移出等类似事件的回调函数 的 <code>this</code> 指向</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span>&gt;点我啊&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.dir(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 第一种调用方法</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    getDom(); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种调用方法</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = getDom()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种调用方法</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>,getDom)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四种调用方法</span></span><br><span class="line">&lt;button type=<span class="string">&quot;button&quot;</span> id=<span class="string">&quot;btn&quot;</span> onclick=<span class="string">&quot;console.log(this)&quot;</span>&gt;点我啊&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>console.log()会在浏览器控制台打印出信息</p>
<p>console.dir()可以显示一个对象的所有属性和方法</p>
</blockquote>
<p>（1） 第一种调用方法，this指向的是window。<strong>虽然在<code>function()&#123;&#125;</code> 回调函数里的 this 指向的是button这个DOM对象，但是getDom是在这里面调用的，和普通函数调用没什么区别</strong>。所以也指向window</p>
<p>（2） 第二种都不用点击，直接触发，this指向window。因为直接当做普通函数调用了。</p>
<p>（3） 第三种方法<strong>，this指向 button这个DOM对象</strong>。回调函数传入的是函数执行的地址，执行的时候相当于是在window环境下执行，所以getDom的this指向的是window</p>
<p>（4） 第四种方式，this指向 button 这个DOM对象。</p>
<p><img data-src="this-1.png"></p>
<p> <strong>当函数被用作事件处理函数时，它的<code>this</code>指向触发事件的元素（一些浏览器在使用非<code>addEventListener</code>的函数动态添加监听函数时不遵守这个约定）。 — MDN</strong></p>
<p><strong>对于 立即执行函数 IIFE 中 this的指向，指向的是window</strong></p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">function</span>()&#123;</span><br><span class="line"> console.log(<span class="name">this</span>) // window</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>到这里，我还是没搞懂下面这种情况：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">  age:<span class="number">10</span>,</span><br><span class="line">  say:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>)   <span class="comment">// window</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span>();</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure>

<p>get函数里的this指向的是window，因为get函数 独立调用，并没有为内部 this 明确指向。所以会指向 window 。如果是严格模式，则指向undefined。</p>
<h3 id="遗留问题解答一"><a href="#遗留问题解答一" class="headerlink" title="遗留问题解答一"></a>遗留问题解答一</h3><p>（1）既然 this 指向的是window，为什么get函数在window上不能访问？</p>
<p>（2）这种在函数内部定义并执行的方式，和立即执行函数有没有区别？</p>
<p>（3）词法分析的时候，这个函数是被怎样处理的？</p>
<hr>
<p>以前没搞懂为什么上面内部申明的 get（）方法不能在window上访问，其实很简单。</p>
<p>get函数是在say函数里面 创建的，也就是说，不管怎么调用，get函数的作用域都只能是在say函数里面。而get方法是自执行，并没有其它任何对象直接调用，所以this是指向window，但是作用域是say函数里面，却不是window。感觉和立即执行函数没区别。</p>
<p>不要理解成 this 指向window，产生这个this的函数就一定在window作用域上挂载。this指向 和 函数作用域 并不是相互的</p>
<p>由于js是采用的静态作用域（也叫词法作用域），这就意味着函数的执行依赖于函数定义的时候所产生（而不是函数调用的时候产生的）的变量作用域。</p>
<p>所以，函数的作用域是基于函数创建（可以理解为函数定义的时候）的地方，也就是函数在哪里创建，不管是否返回这个函数，或者返回带括号（已执行）的函数，都不用在意，只要知道是在哪里定义即创建的就知道函数的作用域是什么内容了。</p>
<p>在全局作用域中“定义”一个函数的时候，只会创建包含全局作用域的作用域链。只有“执行”该函数的时候，才会复制创建时的作用域，并将当前函数的局部作用域放在作用域链的顶端。</p>
<p>去取变量值的时候，首先看本函数里有没有该值，如果没有再到函数定义的外部去找</p>
<hr>
<h3 id="遗留问题解答二"><a href="#遗留问题解答二" class="headerlink" title="遗留问题解答二"></a>遗留问题解答二</h3><p>如果使用了严格模式，this的指向则是它进入执行环境时的值。不一定是undefined。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2.bind(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;)() === <span class="literal">undefined</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p> 如果未指定this，则是undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2() === <span class="literal">undefined</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6新特性及前沿</title>
    <url>/2020/10/22/new-features-and-frontiers-of-ES6/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>回顾一遍ES6新特性，黑黑！很官方的文档传送门-&gt;<a href="https://es6.ruanyifeng.com/#docs/intro">ECMAscript6</a></p>
<p>ES6  -&gt; ES2015  -&gt; 2015年6月份推出，并在推出之后ECMA表示以后每年的6月份都会推出一个版本(然后现在出现什么ES7、ES8、ES9….)，其实只是一个年份表示，小版本更新，只有ES2015才是大版本更新。</p>
<p>摘自<a href="https://es6.ruanyifeng.com/#README">阮一峰的ECMAScript</a></p>
<p>–  let/const 变量声明</p>
<p>–  解构赋值</p>
<p>–  字符串扩展</p>
<p>–  正则扩展</p>
<p>–  数值的扩展</p>
<p>–  函数的扩展</p>
<p>–  数组的扩展</p>
<p>–  对象的扩展</p>
</blockquote>
<a id="more"></a>

<h2 id="一、let-const-变量声明"><a href="#一、let-const-变量声明" class="headerlink" title="一、let/const 变量声明"></a>一、let/const 变量声明</h2><p>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p>
<blockquote>
<p><strong>JavaScript ES6中var、let、const分别什么时候使用？</strong></p>
<p>Answer：const一般在require一个模块的时候用或者定义一些全局常量。而let是限制了变量的作用域，保证变量不会去污染全局变量。所以尽量将var改为用let。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><code>for</code>循环的计数器，就很合适使用<code>let</code>命令。</p>
<p>如果使用<code>let</code>，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>另外，<code>for</code>循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure>

<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p><code>var</code>命令会发生“变量提升”现象，即变量可以在声明之前使用，值为<code>undefined</code>。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，<code>let</code>命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(bar); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<p><strong>“暂时性死区”也意味着<code>typeof</code>不再是一个百分之百安全的操作。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure>

<p>作为比较，如果一个变量根本没有被声明，使用<code>typeof</code>反而不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>有些“死区”比较隐蔽，不太容易发现。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>

<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">func() <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<p>因此，不能在函数内部重新声明参数。</p>
<h3 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h3><p>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = ...;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// ES5: I am inside!</span></span><br><span class="line"><span class="comment">// ES6: I am outside!-----?------实际情况：Uncaught TypeError: f is not a function    </span></span><br></pre></td></tr></table></figure>

<p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics">附录 B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a href="http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6">行为方式</a>。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于<code>var</code>，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>根据这三条规则，浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。上面的例子实际运行的代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am outside!&#x27;</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am inside!&#x27;</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>

<p>另外，还有一个需要注意的地方。<strong>ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一种写法，报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法，不报错</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一种写法没有大括号，所以不存在块级作用域，而<code>let</code>只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。</p>
<p><strong>函数声明也是如此，严格模式下，函数只能声明在当前作用域的顶层。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变；这意味着，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值，否则报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415</span>;</span><br><span class="line">PI <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p><code>const</code>实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，<code>const</code>只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<p><strong>如果真的想将对象冻结</strong>，应该使用<code>Object.freeze</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">&#x27;object&#x27;</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="拓展知识"><a href="#拓展知识" class="headerlink" title="拓展知识"></a>拓展知识</h3><h4 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h4><p>ES5 只有两种声明变量的方法：<code>var</code>命令和<code>function</code>命令。ES6 除了添加<code>let</code>和<code>const</code>命令，后面章节还会提到，另外两种声明变量的方法：<code>import</code>命令和<code>class</code>命令。所以，ES6 一共有 6 种声明变量的方法。    </p>
<h4 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h4><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在 Node 指的是<code>global</code>对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，<code>window</code>对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，全局变量<code>a</code>由<code>var</code>命令声明，所以它是顶层对象的属性；全局变量<code>b</code>由<code>let</code>命令声明，所以它不是顶层对象的属性，返回<code>undefined</code>。</p>
<h4 id="globalThis-对象"><a href="#globalThis-对象" class="headerlink" title="globalThis 对象"></a>globalThis 对象</h4><p>JavaScript 语言存在一个顶层对象，它提供全局环境（即全局作用域），所有代码都是在这个环境中运行。但是，顶层对象在各种实现里面是不统一的。</p>
<ul>
<li>浏览器里面，顶层对象是<code>window</code>，但 Node 和 Web Worker 没有<code>window</code>。</li>
<li>浏览器和 Web Worker 里面，<code>self</code>也指向顶层对象，但是 Node 没有<code>self</code>。</li>
<li>Node 里面，顶层对象是<code>global</code>，但其他环境都不支持。</li>
</ul>
<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用<code>this</code>变量，但是有局限性。</p>
<ul>
<li>全局环境中，<code>this</code>会返回顶层对象。但是，Node.js 模块中<code>this</code>返回的是当前模块，ES6 模块中<code>this</code>返回的是<code>undefined</code>。</li>
<li>函数里面的<code>this</code>，如果函数不是作为对象的方法运行，而是单纯作为函数运行，<code>this</code>会指向顶层对象。但是，严格模式下，这时<code>this</code>会返回<code>undefined</code>。</li>
<li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全策略），那么<code>eval</code>、<code>new Function</code>这些方法都可能无法使用。</li>
</ul>
<p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">&#x27;function&#x27;</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">global</span> === <span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">     ? <span class="built_in">global</span></span><br><span class="line">     : <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">global</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123; <span class="keyword">return</span> <span class="built_in">global</span>; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;unable to locate global object&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/tc39/proposal-global">ES2020</a> 在语言标准的层面，引入<code>globalThis</code>作为顶层对象。也就是说，任何环境下，<code>globalThis</code>都是存在的，都可以从它拿到顶层对象，指向全局环境下的<code>this</code>。</p>
<p>垫片库<a href="https://github.com/ungap/global-this"><code>global-this</code></a>模拟了这个提案，可以在所有环境拿到<code>globalThis</code>。</p>
<h2 id="二、解构赋值"><a href="#二、解构赋值" class="headerlink" title="二、解构赋值"></a>二、解构赋值</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为<strong>解构（Destructuring）</strong>。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>ES6 允许写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<p>如果解构不成功，变量的值就等于<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo] = [];</span><br><span class="line"><span class="keyword">let</span> [bar, foo] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<p>以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code>。</p>
<p><strong>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。</strong>这种情况下，解构依然可以成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h3><p><strong>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">foo <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line">bar <span class="comment">// &quot;bbb&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> &#123; log &#125; = <span class="built_in">console</span>;</span><br><span class="line">log(<span class="string">&#x27;hello&#x27;</span>) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line">baz <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line">f <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line">l <span class="comment">// &#x27;world&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>这实际上说明，对象的解构赋值是下面形式的简写</strong>（参见《对象的扩展》一章）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>与数组一样，解构也可以用于嵌套结构的对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意，这时<code>p</code>是模式，不是变量，因此不会被赋值。如果<code>p</code>也要作为变量赋值，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br><span class="line">p <span class="comment">// [&quot;Hello&quot;, &#123;y: &quot;World&quot;&#125;]</span></span><br></pre></td></tr></table></figure>

<p>下面是另一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> node = &#123;</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; loc, <span class="attr">loc</span>: &#123; start &#125;, <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</span><br><span class="line">line <span class="comment">// 1</span></span><br><span class="line">loc  <span class="comment">// Object &#123;start: Object&#125;</span></span><br><span class="line">start <span class="comment">// Object &#123;line: 1, column: 5&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>上面代码有三次解构赋值，分别是对<code>loc</code>、<code>start</code>、<code>line</code>三个属性的解构赋值。注意，最后一次对<code>line</code>属性的解构赋值之中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不是变量。</strong></p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>对象的解构也可以指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">&#x27;Something went wrong&#x27;</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// &quot;Something went wrong&quot;</span></span><br></pre></td></tr></table></figure>

<p>默认值生效的条件是，对象的属性值严格等于<code>undefined</code>。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>（1）如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure>

<p>上面代码的写法会报错，因为 JavaScript 引擎会将<code>&#123;x&#125;</code>理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p>
<p>（2）解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure>

<p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p>
<p>（3）由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码对数组进行对象解构。数组<code>arr</code>的<code>0</code>键对应的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>键，对应的值是<code>3</code>。</p>
<h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br></pre></td></tr></table></figure>

<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数值和布尔值的包装对象都有<code>toString</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数就是<code>x</code>和<code>y</code>。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure>

<p>函数参数的解构也可以使用默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>

<p>注意，下面的写法会得到不一样的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>

<p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值，所以会得到与前一种写法不同的结果。</p>
<p><code>undefined</code>就会触发函数参数的默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">&#x27;yes&#x27;</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, &#x27;yes&#x27;, 3 ]</span></span><br></pre></td></tr></table></figure>

<h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><p>以下三种解构赋值不得使用圆括号。</p>
<p>（1）变量声明语句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>上面 6 个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。</p>
<p>（2）函数参数</p>
<p>函数参数也属于变量声明，因此不能带有圆括号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z)]</span>) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[z,(x)]</span>) </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure>

<p>（3）赋值语句的模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>上面代码将整个模式放在圆括号之中，导致报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure>

<p>上面代码将一部分模式放在圆括号之中，导致报错。</p>
<h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p>可以使用圆括号的情况只有一种：<strong>赋值语句的非模式部分，可以使用圆括号</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是<code>p</code>，而不是<code>d</code>；第三行语句与第一行语句的性质一致。</p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>（1）交换变量的值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>

<p><strong>（2）从函数返回多个值</strong></p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>

<p><strong>（3）函数参数的定义</strong></p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>（4）提取 JSON 数据</strong></p>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, &quot;OK&quot;, [867, 5309]</span></span><br></pre></td></tr></table></figure>

<p><strong>（5）函数参数的默认值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  async = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  beforeSend = function () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  cache = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  complete = function () &#123;&#125;,</span></span></span><br><span class="line"><span class="function"><span class="params">  crossDomain = false,</span></span></span><br><span class="line"><span class="function"><span class="params">  global = true,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="regexp">//</span> ... more config</span></span></span><br><span class="line"><span class="function"><span class="params">&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>指定参数的默认值，就避免了在函数体内部再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。</p>
<p><strong>（6）遍历 Map 结构</strong></p>
<p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">&quot; is &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>

<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（7）输入模块的指定方法</strong></p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>更具体的内容见<a href="https://es6.ruanyifeng.com/#docs/destructuring">阮一峰原著</a></p>
<hr>

<blockquote>
<p>由于原著中的内容已经很详实，不需要进行照搬，下面我只进行简要概括</p>
</blockquote>
<h2 id="三、字符串的扩展和新增方法"><a href="#三、字符串的扩展和新增方法" class="headerlink" title="三、字符串的扩展和新增方法"></a>三、字符串的扩展和新增方法</h2><h3 id="1、字符的unicode表示法"><a href="#1、字符的unicode表示法" class="headerlink" title="1、字符的unicode表示法"></a>1、字符的unicode表示法</h3><h3 id="2、字符的遍历器接口"><a href="#2、字符的遍历器接口" class="headerlink" title="2、字符的遍历器接口"></a>2、字符的遍历器接口</h3><h3 id="3、模板字符串"><a href="#3、模板字符串" class="headerlink" title="3、模板字符串"></a>3、模板字符串</h3><h3 id="4、标签模板"><a href="#4、标签模板" class="headerlink" title="4、标签模板"></a>4、标签模板</h3><h3 id="5、新增方法"><a href="#5、新增方法" class="headerlink" title="5、新增方法"></a>5、<span style="color:red;">新增方法</span></h3><p><strong>String.fromCodePoint()</strong></p>
<p>用于从 Unicode 码点返回对应字符</p>
<p><strong>String.raw()</strong></p>
<p>该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法</p>
<p><strong>实例方法：codePointAt()</strong></p>
<p>ES6中的该方法能够正确处理 4 个字节储存的字符，返回一个字符的码点</p>
<p><strong>实例方法：normalize()</strong></p>
<p>用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p>
<p><strong>实例方法：includes(), startsWith(), endsWith()</strong></p>
<p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<ul>
<li><p>**includes()**：返回布尔值，表示是否找到了参数字符串。</p>
</li>
<li><p>**startsWith()**：返回布尔值，表示参数字符串是否在原字符串的头部。</p>
</li>
<li><p>**endsWith()**：返回布尔值，表示参数字符串是否在原字符串的尾部。</p>
</li>
</ul>
<p><strong>实例方法：repeat()</strong></p>
<p>返回一个新字符串，表示将原字符串重复<code>n</code>次</p>
<p><strong>实例方法：padStart()，padEnd()</strong></p>
<p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。<code>padStart()</code>用于头部补全，<code>padEnd()</code>用于尾部补全。</p>
<p><strong>实例方法：trimStart()，trimEnd()</strong></p>
<p><a href="https://github.com/tc39/proposal-string-left-right-trim">ES2019</a> 对字符串实例新增了<code>trimStart()</code>和<code>trimEnd()</code>这两个方法。它们的行为与<code>trim()</code>一致，<code>trimStart()</code>消除字符串头部的空格，<code>trimEnd()</code>消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。</p>
<p><strong>实例方法：matchAll()</strong></p>
<p><code>matchAll()</code>方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p>
<h2 id="四、正则的扩展"><a href="#四、正则的扩展" class="headerlink" title="四、正则的扩展"></a>四、正则的扩展</h2><p>字符串对象共有 4 个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。</p>
<p>待复习<code>RegExp</code>之后补充</p>
<h2 id="五、数值的扩展"><a href="#五、数值的扩展" class="headerlink" title="五、数值的扩展"></a>五、数值的扩展</h2><h3 id="二进制和八进制表示法"><a href="#二进制和八进制表示法" class="headerlink" title="二进制和八进制表示法"></a>二进制和八进制表示法</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="新增函数"><a href="#新增函数" class="headerlink" title="新增函数"></a><span style="color:red;">新增函数</span></h3><p><strong>Number.isFinite(), Number.isNaN()</strong></p>
<p><code>isFinite</code>用来检查一个数值是否为有限的（finite），即不是<code>Infinity</code></p>
<p><code>isNaN</code>用来检查一个值是否为<code>NaN</code></p>
<p><strong>Number.parseInt(), Number.parseFloat()</strong></p>
<p>ES6 将全局方法<code>parseInt()</code>和<code>parseFloat()</code>，移植到<code>Number</code>对象上面，行为完全保持不变。</p>
<p><strong>Number.isInteger()</strong></p>
<p>用来判断一个数值是否为整数</p>
<p><strong>Number.EPSILON</strong></p>
<p>ES6 在<code>Number</code>对象上面，新增一个极小的常量<code>Number.EPSILON</code>。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p>
<p>因此，<code>Number.EPSILON</code>的实质是一个可以接受的最小误差范围。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withinErrorMargin</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(left - right) &lt; <span class="built_in">Number</span>.EPSILON * <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> + <span class="number">1.3</span> === <span class="number">2.4</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">1.1</span> + <span class="number">1.3</span>, <span class="number">2.4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面的代码为浮点数运算，部署了一个误差检查函数。</p>
<p><strong>安全整数和 Number.isSafeInteger()</strong> </p>
<p>JavaScript 能够准确表示的整数范围在<code>-2^53</code>到<code>2^53</code>之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<p>ES6 引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。</p>
<p><code>Number.isSafeInteger()</code>则是用来判断一个整数是否落在这个范围之内。</p>
<h3 id="Math对象扩展"><a href="#Math对象扩展" class="headerlink" title="Math对象扩展"></a><span style="color:red;">Math对象扩展</span></h3><p><strong>Math.trunc()</strong></p>
<p><code>Math.trunc</code>方法用于去除一个数的小数部分，返回整数部分。</p>
<p><strong>Math.sign()</strong></p>
<p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回<code>+1</code>；</li>
<li>参数为负数，返回<code>-1</code>；</li>
<li>参数为 0，返回<code>0</code>；</li>
<li>参数为-0，返回<code>-0</code>;</li>
<li>其他值，返回<code>NaN</code>。</li>
</ul>
<p><strong>Math.cbrt()</strong></p>
<p><code>Math.cbrt()</code>方法用于计算一个数的立方根。</p>
<p><strong>Math.clz32()</strong></p>
<p><code>Math.clz32()</code>方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。</p>
<p>左移运算符（<code>&lt;&lt;</code>）与<code>Math.clz32</code>方法直接相关。</p>
<p><strong>Math.imul()</strong></p>
<p><code>Math.imul</code>方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>
<p><strong>Math.fround()</strong></p>
<p><code>Math.fround</code>方法返回一个数的32位单精度浮点数形式。</p>
<p><strong>Math.hypot()</strong></p>
<p><code>Math.hypot</code>方法返回所有参数的平方和的平方根。</p>
<p><strong>新增对数方法</strong></p>
<ul>
<li><strong>Math.expm1()</strong></li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>expm1(x)`返回 ex - <span class="number">1</span>，即`<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>exp(x) - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Math.log1p()</strong></li>
</ul>
<p><code>Math.log1p(x)</code>方法返回<code>1 + x</code>的自然对数，即<code>Math.log(1 + x)</code>。如果<code>x</code>小于-1，返回<code>NaN</code>。</p>
<ul>
<li><strong>Math.log10()</strong></li>
</ul>
<p><code>Math.log10(x)</code>返回以 10 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 NaN</p>
<ul>
<li><strong>Math.log2()</strong></li>
</ul>
<p><code>Math.log2(x)</code>返回以 2 为底的<code>x</code>的对数。如果<code>x</code>小于 0，则返回 NaN</p>
<p><strong>双曲函数方法</strong></p>
<p>ES6 新增了 6 个双曲函数方法。</p>
<ul>
<li><code>Math.sinh(x)</code> 返回<code>x</code>的双曲正弦（hyperbolic sine）</li>
<li><code>Math.cosh(x)</code> 返回<code>x</code>的双曲余弦（hyperbolic cosine）</li>
<li><code>Math.tanh(x)</code> 返回<code>x</code>的双曲正切（hyperbolic tangent）</li>
<li><code>Math.asinh(x)</code> 返回<code>x</code>的反双曲正弦（inverse hyperbolic sine）</li>
<li><code>Math.acosh(x)</code> 返回<code>x</code>的反双曲余弦（inverse hyperbolic cosine）</li>
<li><code>Math.atanh(x)</code> 返回<code>x</code>的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
<h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><p>ES2016 新增了一个指数运算符（<code>**</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></span><br><span class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h3 id="BigInt数据类型"><a href="#BigInt数据类型" class="headerlink" title="BigInt数据类型"></a>BigInt数据类型</h3><p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回<code>Infinity</code>。</p>
<p><a href="https://github.com/tc39/proposal-bigint">ES2020</a> 引入了一种新的数据类型 BigInt（大整数），来解决这个问题，这是 ECMAScript 的第八种数据类型。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">2172141653n</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">15346349309n</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 可以保持精度</span></span><br><span class="line">a * b <span class="comment">// 33334444555566667777n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通整数无法保持精度</span></span><br><span class="line"><span class="built_in">Number</span>(a) * <span class="built_in">Number</span>(b) <span class="comment">// 33334444555566670000</span></span><br></pre></td></tr></table></figure>

<p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀<code>n</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1234</span> <span class="comment">// 普通整数</span></span><br><span class="line"><span class="number">1234n</span> <span class="comment">// BigInt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1n</span> + <span class="number">2n</span> <span class="comment">// 3n</span></span><br></pre></td></tr></table></figure>

<p>BigInt 同样可以使用各种进制表示，都要加上后缀<code>n</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0b1101n</span> <span class="comment">// 二进制</span></span><br><span class="line"><span class="number">0o777n</span> <span class="comment">// 八进制</span></span><br><span class="line"><span class="number">0xFFn</span> <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure>

<p>BigInt 与普通整数是两种值，它们之间并不相等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">42n</span> === <span class="number">42</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h4 id="BigInt-对象"><a href="#BigInt-对象" class="headerlink" title="BigInt 对象"></a>BigInt 对象</h4><p>JavaScript 原生提供<code>BigInt</code>对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与<code>Number()</code>一致，将其他类型的值转为 BigInt。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">BigInt(<span class="number">123</span>) <span class="comment">// 123n</span></span><br><span class="line">BigInt(<span class="string">&#x27;123&#x27;</span>) <span class="comment">// 123n</span></span><br><span class="line">BigInt(<span class="literal">false</span>) <span class="comment">// 0n</span></span><br><span class="line">BigInt(<span class="literal">true</span>) <span class="comment">// 1n</span></span><br></pre></td></tr></table></figure>

<h2 id="六、函数的扩展"><a href="#六、函数的扩展" class="headerlink" title="六、函数的扩展"></a>六、函数的扩展</h2><h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  y = y || <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>

<p>上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值，如果没有，则指定默认值为<code>World</code>。这种写法的缺点在于，如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。就像上面代码的最后一行，参数<code>y</code>等于空字符，结果被改为默认值。</p>
<p>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  y = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x = <span class="number">0</span>, y = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point();</span><br><span class="line">p <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure>

<p>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<h4 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h4><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数<code>foo</code>的参数是一个对象时，变量<code>x</code>和<code>y</code>才会通过解构赋值生成。如果函数<code>foo</code>调用时没提供参数，变量<code>x</code>和<code>y</code>就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure>

<h4 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h4><p>如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span>, y = <span class="number">6</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">undefined</span>, <span class="literal">null</span>)</span><br><span class="line"><span class="comment">// 5 null</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>x</code>参数对应<code>undefined</code>，结果触发了默认值，<code>y</code>参数等于<code>null</code>，就没有触发默认值。</p>
<h4 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h4><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Missing parameter&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>foo</code>函数，如果调用的时候没有参数，就会调用默认值<code>throwIfMissing</code>函数，从而抛出一个错误。</p>
<p>从上面代码还可以看到，参数<code>mustBeProvided</code>的默认值等于<code>throwIfMissing</code>函数的运行结果（注意函数名<code>throwIfMissing</code>之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p>
<p>另外，可以将参数默认值设为<code>undefined</code>，表明这个参数是可以省略的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">optional = undefined</span>) </span>&#123; ··· &#125;</span><br></pre></td></tr></table></figure>

<h3 id="rest-参数"><a href="#rest-参数" class="headerlink" title="rest 参数"></a>rest 参数</h3><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面代码的<code>add</code>函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>
<p>下面是一个 rest 参数代替<code>arguments</code>变量的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure>

<p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p>
<p><code>arguments</code>对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用<code>Array.prototype.slice.call</code>先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组<code>push</code>方法的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><strong>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</strong></p>
<p><strong>函数的<code>length</code>属性，不包括 rest 参数。</strong></p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h3><p>函数的<code>name</code>属性，返回该函数的函数名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo.name <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。<strong>如果将一个匿名函数赋值给一个变量，ES5 的<code>name</code>属性，会返回空字符串，而 ES6 的<code>name</code>属性会返回实际的函数名。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.name <span class="comment">// &quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.name <span class="comment">// &quot;f&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>f</code>等于一个匿名函数，ES5 和 ES6 的<code>name</code>属性返回的值不一样。</p>
<p><strong>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的<code>name</code>属性都返回这个具名函数原本的名字。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">bar.name <span class="comment">// &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">bar.name <span class="comment">// &quot;baz&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>Function</code>构造函数返回的函数实例，<code>name</code>属性的值为<code>anonymous</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>).name <span class="comment">// &quot;anonymous&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong><code>bind</code>返回的函数，<code>name</code>属性值会加上<code>bound</code>前缀。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">foo.bind(&#123;&#125;).name <span class="comment">// &quot;bound foo&quot;</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).bind(&#123;&#125;).name <span class="comment">// &quot;bound &quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p>
<p><strong>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function">() =&gt;</span> <span class="keyword">void</span> doesNotReturn();</span><br></pre></td></tr></table></figure>

<p><em>箭头函数可以与变量解构结合使用。</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">&#x27; &#x27;</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">&#x27; &#x27;</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>箭头函数使得表达更加简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">n</span> =&gt;</span> n * n;</span><br></pre></td></tr></table></figure>

<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure>

<p>下面是 rest 参数与箭头函数结合的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = <span class="function">(<span class="params">...nums</span>) =&gt;</span> nums;</span><br><span class="line"></span><br><span class="line">numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> headAndTail = <span class="function">(<span class="params">head, ...tail</span>) =&gt;</span> [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure>

<h4 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h4><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>
<p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p>
<p>上面四点中，第一点尤其值得注意。<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setTimeout()</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>&#123;id: 42&#125;</code>），所以打印出来的是<code>42</code>。</p>
<p>箭头函数可以让<code>setTimeout</code>里面的<code>this</code>，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.s1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">this</span>.s2 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 箭头函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="built_in">this</span>.s1++, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 普通函数</span></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.s2++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;s1: &#x27;</span>, timer.s1), <span class="number">3100</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;s2: &#x27;</span>, timer.s2), <span class="number">3100</span>);</span><br><span class="line"><span class="comment">// s1: 3</span></span><br><span class="line"><span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Timer</code>函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的<code>this</code>绑定定义时所在的作用域（即<code>Timer</code>函数），后者的<code>this</code>指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，<code>timer.s1</code>被更新了 3 次，而<code>timer.s2</code>一次都没更新。</p>
<p><strong>箭头函数可以让<code>this</code>指向固定化，这种特性很有利于封装回调函数。</strong>下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">      event =&gt; <span class="built_in">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Handling &#x27;</span> + type  + <span class="string">&#x27; for &#x27;</span> + <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>init</code>方法中，使用了箭头函数，这导致这个箭头函数里面的<code>this</code>，总是指向<code>handler</code>对象。否则，回调函数运行时，<code>this.doSomething</code>这一行会报错，因为此时<code>this</code>指向<code>document</code>对象。</p>
<p><strong><code>this</code>指向的固定化，并不是因为箭头函数内部有绑定<code>this</code>的机制，实际原因是箭头函数根本没有自己的<code>this</code>，导致内部的<code>this</code>就是外层代码块的<code>this</code>。正是因为它没有<code>this</code>，所以也就不能用作构造函数。</strong></p>
<p>所以，箭头函数转成 ES5 的代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, _this.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的<code>this</code>，而是引用外层的<code>this</code>。</p>
<p>请问下面的代码之中有几个<code>this</code>？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = foo.call(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = f.call(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;)()(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t2 = f().call(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;)(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t3 = f()().call(&#123;<span class="attr">id</span>: <span class="number">4</span>&#125;); <span class="comment">// id: 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码之中，只有一个<code>this</code>，就是函数<code>foo</code>的<code>this</code>，所以<code>t1</code>、<code>t2</code>、<code>t3</code>都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的<code>this</code>，它们的<code>this</code>其实都是最外层<code>foo</code>函数的<code>this</code>。</p>
<p><strong>除了<code>this</code>，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：<code>arguments</code>、<code>super</code>、<code>new.target</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;args:&#x27;</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment">// args: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，箭头函数内部的变量<code>arguments</code>，其实是函数<code>foo</code>的<code>arguments</code>变量。</p>
<p>另外，<strong>由于箭头函数没有自己的<code>this</code>，所以当然也就不能用<code>call()</code>、<code>apply()</code>、<code>bind()</code>这些方法去改变<code>this</code>的指向。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    (<span class="function">() =&gt;</span> <span class="built_in">this</span>.x).bind(&#123; <span class="attr">x</span>: <span class="string">&#x27;inner&#x27;</span> &#125;)()</span><br><span class="line">  ];</span><br><span class="line">&#125;).call(&#123; <span class="attr">x</span>: <span class="string">&#x27;outer&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [&#x27;outer&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，箭头函数没有自己的<code>this</code>，所以<code>bind</code>方法无效，内部的<code>this</code>指向外部的<code>this</code>。</p>
<p>长期以来，JavaScript 语言的<code>this</code>对象一直是一个令人头痛的问题，在对象方法中使用<code>this</code>，必须非常小心。箭头函数”绑定”<code>this</code>，很大程度上解决了这个困扰。</p>
<h4 id="不适用场合"><a href="#不适用场合" class="headerlink" title="不适用场合"></a>不适用场合</h4><p>由于箭头函数使得<code>this</code>从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p>
<p>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;</span><br><span class="line">  lives: <span class="number">9</span>,</span><br><span class="line">  jumps: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.lives--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>cat.jumps()</code>方法是一个箭头函数，这是错误的。调用<code>cat.jumps()</code>时，如果是普通函数，该方法内部的<code>this</code>指向<code>cat</code>；如果写成上面那样的箭头函数，使得<code>this</code>指向全局对象，因此不会得到预期结果。这是因为对象不构成单独的作用域，导致<code>jumps</code>箭头函数定义时的作用域就是全局作用域。</p>
<p>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;press&#x27;</span>);</span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.classList.toggle(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码运行时，点击按钮会报错，因为<code>button</code>的监听函数是一个箭头函数，导致里面的<code>this</code>就是全局对象。如果改成普通函数，<code>this</code>就会动态指向被点击的按钮对象。</p>
<p>另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。</p>
<h4 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h4><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pipeline = <span class="function">(<span class="params">...funcs</span>) =&gt;</span></span><br><span class="line">  val =&gt; funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b(a), val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> addThenMult = pipeline(plus1, mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">mult2(plus1(<span class="number">5</span>))</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>箭头函数还有一个功能，就是可以很方便地改写 λ 演算。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// λ演算的写法</span></span><br><span class="line">fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">var</span> fix = <span class="function"><span class="params">f</span> =&gt;</span> (<span class="function"><span class="params">x</span> =&gt;</span> f(<span class="function"><span class="params">v</span> =&gt;</span> x(x)(v)))</span><br><span class="line">               (<span class="function"><span class="params">x</span> =&gt;</span> f(<span class="function"><span class="params">v</span> =&gt;</span> x(x)(v)));</span><br></pre></td></tr></table></figure>

<h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，<strong>函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数<code>A</code>的内部调用函数<code>B</code>，那么在<code>A</code>的调用帧上方，还会形成一个<code>B</code>的调用帧。等到<code>B</code>运行结束，将结果返回到<code>A</code>，<code>B</code>的调用帧才会消失。如果函数<code>B</code>内部还调用函数<code>C</code>，那就还有一个<code>C</code>的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</strong></p>
<p><strong>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果函数<code>g</code>不是尾调用，函数<code>f</code>就需要保存内部变量<code>m</code>和<code>n</code>的值、<code>g</code>的调用位置等信息。但由于调用<code>g</code>之后，函数<code>f</code>就结束了，所以执行到最后一步，完全可以删除<code>f(x)</code>的调用帧，只保留<code>g(3)</code>的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数不会进行尾调用优化，因为内层函数<code>inner</code>用到了外层函数<code>addOne</code>的内部变量<code>one</code>。</p>
<p>注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。</p>
<h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>上面代码是一个阶乘函数，计算<code>n</code>的阶乘，最多需要保存<code>n</code>个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p>
<p>非尾递归的 Fibonacci 数列实现如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Fibonacci(n - <span class="number">1</span>) + Fibonacci(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci(<span class="number">10</span>) <span class="comment">// 89</span></span><br><span class="line">Fibonacci(<span class="number">100</span>) <span class="comment">// 超时</span></span><br><span class="line">Fibonacci(<span class="number">500</span>) <span class="comment">// 超时</span></span><br></pre></td></tr></table></figure>

<p>尾递归优化过的 Fibonacci 数列实现如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fibonacci2</span> (<span class="params">n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( n &lt;= <span class="number">1</span> ) &#123;<span class="keyword">return</span> ac2&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Fibonacci2 (n - <span class="number">1</span>, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci2(<span class="number">100</span>) <span class="comment">// 573147844013817200000</span></span><br><span class="line">Fibonacci2(<span class="number">1000</span>) <span class="comment">// 7.0330367711422765e+208</span></span><br><span class="line">Fibonacci2(<span class="number">10000</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。</p>
<h4 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h4><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量<code>total</code>，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算<code>5</code>的阶乘，需要传入两个参数<code>5</code>和<code>1</code>？</p>
<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="built_in">this</span>, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>上面代码通过柯里化，将尾递归函数<code>tailFactorial</code>变为只接受一个参数的<code>factorial</code>。</p>
<p>第二种方法就简单多了，就是采用 ES6 的函数默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，参数<code>total</code>有默认值<code>1</code>，所以调用时不用提供这个值。</p>
<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
<h4 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h4><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<ul>
<li><code>func.arguments</code>：返回调用时函数的参数。</li>
<li><code>func.caller</code>：返回调用当前函数的那个函数。</li>
</ul>
<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restricted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  restricted.caller;    <span class="comment">// 报错</span></span><br><span class="line">  restricted.arguments; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line">restricted();</span><br></pre></td></tr></table></figure>

<h4 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h4><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// Uncaught RangeError: Maximum call stack size exceeded(…)</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>sum</code>是一个递归函数，参数<code>x</code>是需要累加的值，参数<code>y</code>控制递归次数。一旦指定<code>sum</code>递归 100000 次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (f &amp;&amp; f <span class="keyword">instanceof</span> <span class="built_in">Function</span>) &#123;</span><br><span class="line">    f = f();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是蹦床函数的一个实现，它接受一个函数<code>f</code>作为参数。只要<code>f</code>执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum.bind(<span class="literal">null</span>, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>sum</code>函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行<code>sum</code>，就不会发生调用栈溢出。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">trampoline(sum(<span class="number">1</span>, <span class="number">100000</span>))</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure>

<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tco</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> accumulated = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">accumulator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    accumulated.push(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">      active = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (accumulated.length) &#123;</span><br><span class="line">        value = f.apply(<span class="built_in">this</span>, accumulated.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      active = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = tco(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>tco</code>函数是尾递归优化的实现，它的奥妙就在于状态变量<code>active</code>。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归<code>sum</code>返回的都是<code>undefined</code>，所以就避免了递归执行；而<code>accumulated</code>数组存放每一轮<code>sum</code>执行的参数，总是有值的，这就保证了<code>accumulator</code>函数内部的<code>while</code>循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h3 id="函数参数的尾逗号"><a href="#函数参数的尾逗号" class="headerlink" title="函数参数的尾逗号"></a>函数参数的尾逗号</h3><p>ES2017 <a href="https://github.com/jeffmo/es-trailing-function-commas">允许</a>函数的最后一个参数有尾逗号（trailing comma）。</p>
<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clownsEverywhere</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  param1,</span></span></span><br><span class="line"><span class="function"><span class="params">  param2</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">  <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果在<code>param2</code>或<code>bar</code>后面加一个逗号，就会报错。</p>
<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数<code>clownsEverywhere</code>添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clownsEverywhere</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  param1,</span></span></span><br><span class="line"><span class="function"><span class="params">  param2,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">  <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>
<h3 id="Function-prototype-toString"><a href="#Function-prototype-toString" class="headerlink" title="Function.prototype.toString()"></a>Function.prototype.toString()</h3><p><a href="https://github.com/tc39/Function-prototype-toString-revision">ES2019</a> 对函数实例的<code>toString()</code>方法做出了修改。</p>
<p><code>toString()</code>方法返回函数代码本身，以前会省略注释和空格。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">foo</span> <span class="title">comment</span> */ <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo.toString()</span><br><span class="line"><span class="comment">// function foo() &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>foo</code>的原始代码包含注释，函数名<code>foo</code>和圆括号之间有空格，但是<code>toString()</code>方法都把它们省略了。</p>
<p>修改后的<code>toString()</code>方法，明确要求返回一模一样的原始代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> /* <span class="title">foo</span> <span class="title">comment</span> */ <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">foo.toString()</span><br><span class="line"><span class="comment">// &quot;function /* foo comment */ foo () &#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="catch-命令的参数省略"><a href="#catch-命令的参数省略" class="headerlink" title="catch 命令的参数省略"></a>catch 命令的参数省略</h3><p>JavaScript 语言的<code>try...catch</code>结构，以前明确要求<code>catch</code>命令后面必须跟参数，接受<code>try</code>代码块抛出的错误对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// 处理错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>catch</code>命令后面带有参数<code>err</code>。</p>
<p>很多时候，<code>catch</code>代码块可能用不到这个参数。但是，为了保证语法正确，还是必须写。<a href="https://github.com/tc39/proposal-optional-catch-binding">ES2019</a> 做出了改变，允许<code>catch</code>语句省略参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、数组的扩展"><a href="#七、数组的扩展" class="headerlink" title="七、数组的扩展"></a>七、数组的扩展</h2><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>

<p>该运算符主要用于函数调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a>替代函数的 apply 方法</h4><p>由于扩展运算符可以展开数组，所以不再需要<code>apply</code>方法，将数组转为函数的参数了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure>

<h4 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h4><p><strong>（1）复制数组</strong></p>
<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure>

<p>ES5 只能用变通方法来复制数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<p><strong>（2）合并数组</strong></p>
<p>扩展运算符提供了数组合并的新写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 的合并数组</span></span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的合并数组</span></span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></span><br></pre></td></tr></table></figure>

<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>
<p><strong>（3）与解构赋值结合</strong></p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">a = list[<span class="number">0</span>], rest = list.slice(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[a, ...rest] = list</span><br></pre></td></tr></table></figure>

<p><strong>（4）字符串</strong></p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure>

<p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>.length <span class="comment">// 4</span></span><br><span class="line">[...<span class="string">&#x27;x\uD83D\uDE80y&#x27;</span>].length <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><strong>（5）实现了 Iterator 接口的对象</strong></p>
<p>任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>
<p><strong>（6）Map 和 Set 结构，Generator 函数</strong></p>
<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [...map.keys()]; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h3><h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="1、Array-of"><a href="#1、Array-of" class="headerlink" title="1、Array.of()"></a>1、Array.of()</h4><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<h4 id="2、数组实例的-copyWithin"><a href="#2、数组实例的-copyWithin" class="headerlink" title="2、数组实例的 copyWithin()"></a>2、数组实例的 copyWithin()</h4><p>数组实例的<code>copyWithin()</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="built_in">this</span>.length)</span><br></pre></td></tr></table></figure>

<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。</li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h4 id="3、组实例的-find-和-findIndex"><a href="#3、组实例的-find-和-findIndex" class="headerlink" title="3、组实例的 find() 和 findIndex()"></a>3、组实例的 find() 和 findIndex()</h4><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为<code>true</code>的成员，然后返回该成员。如果没有符合条件的成员，则返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>

<p>上面代码找出数组中第一个小于 0 的成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回<code>-1</code>。</p>
<h4 id="4、组实例的-fill"><a href="#4、组实例的-fill" class="headerlink" title="4、组实例的 fill()"></a>4、组实例的 fill()</h4><p><code>fill</code>方法使用给定值，填充一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p><code>fill</code>方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, 7, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>fill</code>方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p>
<p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p>
<h4 id="5、数组实例的-entries-，keys-和-values"><a href="#5、数组实例的-entries-，keys-和-values" class="headerlink" title="5、数组实例的 entries()，keys() 和 values()"></a>5、数组实例的 entries()，keys() 和 values()</h4><p>ES6 提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="6、数组实例的-includes"><a href="#6、数组实例的-includes" class="headerlink" title="6、数组实例的 includes()"></a>6、数组实例的 includes()</h4><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。ES2016 引入了该方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>该方法的第二个参数表示搜索的起始位置，默认为<code>0</code>。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为<code>-4</code>，但数组长度为<code>3</code>），则会重置为从<code>0</code>开始。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>没有该方法之前，我们通常使用数组的<code>indexOf</code>方法，检查是否包含某个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>indexOf</code>方法有<strong>两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于<code>-1</code>，表达起来不够直观。二是，它内部使用严格相等运算符（<code>===</code>）进行判断，这会导致对<code>NaN</code>的误判。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure>

<p><code>includes</code>使用的是不一样的判断算法，就没有这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>另外，Map 和 Set 数据结构有一个<code>has</code>方法，需要注意与<code>includes</code>区分。</p>
<ul>
<li>Map 结构的<code>has</code>方法，是用来查找键名的，比如<code>Map.prototype.has(key)</code>、<code>WeakMap.prototype.has(key)</code>、<code>Reflect.has(target, propertyKey)</code>。</li>
<li>Set 结构的<code>has</code>方法，是用来查找值的，比如<code>Set.prototype.has(value)</code>、<code>WeakSet.prototype.has(value)</code>。</li>
</ul>
</blockquote>
<h4 id="7、数组实例的-flat-，flatMap"><a href="#7、数组实例的-flat-，flatMap" class="headerlink" title="7、数组实例的 flat()，flatMap()"></a>7、数组实例的 flat()，flatMap()</h4><p>数组的成员有时还是数组，<code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>

<p><strong><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat()</span><br><span class="line"><span class="comment">// [1, 2, 3, [4, 5]]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>]]].flat(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>如果不管有多少层嵌套，都要转成一维数组，<strong>可以用<code>Infinity</code>关键字作为参数</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]].flat(<span class="literal">Infinity</span>)</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>如果原数组有空位，**<code>flat()</code>方法会跳过空位。**</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, , <span class="number">4</span>, <span class="number">5</span>].flat()</span><br><span class="line"><span class="comment">// [1, 2, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong><code>flatMap()</code>方法对原数组的每个成员执行一个函数（相当于执行<code>Array.prototype.map()</code>），然后对返回值组成的数组执行<code>flat()</code>方法。该方法返回一个新数组，不改    变原数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[2, 4], [3, 6], [4, 8]].flat()</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function">(<span class="params">x</span>) =&gt;</span> [x, x * <span class="number">2</span>])</span><br><span class="line"><span class="comment">// [2, 4, 3, 6, 4, 8]</span></span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code>只能展开一层数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [[x * <span class="number">2</span>]])</span><br><span class="line"><span class="comment">// [[2], [4], [6], [8]]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，遍历函数返回的是一个双层的数组，但是默认只能展开一层，因此<code>flatMap()</code>返回的还是一个嵌套数组。</p>
<p><code>flatMap()</code>方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.flatMap(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;[, thisArg])</span><br></pre></td></tr></table></figure>

<p><code>flatMap()</code>方法还可以有第二个参数，用来绑定遍历函数里面的<code>this</code>。</p>
<h4 id="8、数组的空位"><a href="#8、数组的空位" class="headerlink" title="8、数组的空位"></a>8、数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Array(3)</code>返回一个具有 3 个空位的数组。</p>
<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p>
<p><strong>ES6 则是明确将空位转为<code>undefined</code>。</strong></p>
<h2 id="八、对象新增方法及扩展"><a href="#八、对象新增方法及扩展" class="headerlink" title="八、对象新增方法及扩展"></a>八、对象新增方法及扩展</h2><h3 id="新增方法-1"><a href="#新增方法-1" class="headerlink" title="新增方法"></a>新增方法</h3><h4 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h4><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>ES5 可以通过下面的代码，部署<code>Object.is</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>, <span class="string">&#x27;is&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">      <span class="comment">// 针对+0 不等于 -0的情况</span></span><br><span class="line">      <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对NaN的情况</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h4><h5 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="基本用法"></a>基本用法</h5><p><code>Object.assign()</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.assign()</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<h5 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h5><p><strong>（1）浅拷贝</strong></p>
<p><code>Object.assign()</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign()</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<p><strong>（2）同名属性的替换</strong></p>
<p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign()</code>的处理方法是替换，而不是添加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>一些函数库提供<code>Object.assign()</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep()</code>方法），可以得到深拷贝的合并。</p>
<p><strong>（3）数组的处理</strong></p>
<p><code>Object.assign()</code>可以用来处理数组，但是会把数组视为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.assign()</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p>
<p><strong>（4）取值函数的处理</strong></p>
<p><code>Object.assign()</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>() &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> target = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign()</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>
<h5 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h5><p><code>Object.assign()</code>方法有很多用处。</p>
<p><strong>（1）为对象添加属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="built_in">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法通过<code>Object.assign()</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p>
<p><strong>（2）为对象添加方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class="line">  someMethod(arg1, arg2) &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  anotherMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign()</code>方法添加到<code>SomeClass.prototype</code>之中。</p>
<p><strong>（3）克隆对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）合并多个对象</strong></p>
<p>将多个对象合并到某个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  (target, ...sources) =&gt; <span class="built_in">Object</span>.assign(target, ...sources);</span><br></pre></td></tr></table></figure>

<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  (...sources) =&gt; <span class="built_in">Object</span>.assign(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure>

<p><strong>（5）为属性指定默认值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  logLevel: <span class="number">0</span>,</span><br><span class="line">  outputFormat: <span class="string">&#x27;html&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">  <span class="built_in">console</span>.log(options);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign()</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>options</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p>
<p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  url: &#123;</span><br><span class="line">    host: <span class="string">&#x27;example.com&#x27;</span>,</span><br><span class="line">    port: <span class="number">7070</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">processContent(&#123; <span class="attr">url</span>: &#123;<span class="attr">port</span>: <span class="number">8000</span>&#125; &#125;)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   url: &#123;port: 8000&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p>
<h4 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h4><p>ES5 的<code>Object.getOwnPropertyDescriptor()</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors()</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: get bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.getOwnPropertyDescriptors()</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>
<p>该方法的实现非常容易。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOwnPropertyDescriptors</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123;</span><br><span class="line">    result[key] = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</strong></p>
<p><strong><code>Object.getOwnPropertyDescriptors()</code>方法的另一个用处，是配合<code>Object.create()</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</strong></p>
<p><strong>另外，<code>Object.getOwnPropertyDescriptors()</code>方法可以实现一个对象继承另一个对象。</strong></p>
<p><strong><code>Object.getOwnPropertyDescriptors()</code>也可以用来实现 Mixin（混入）模式。</strong></p>
<h4 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h4><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的原型对象（prototype），返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/ 格式</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>该方法等同于下面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setPrototypeOf</span>(<span class="params">obj, proto</span>) </span>&#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="number">1</span>, &#123;&#125;) === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="string">&#x27;foo&#x27;</span>, &#123;&#125;) === <span class="string">&#x27;foo&#x27;</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">true</span>, &#123;&#125;) === <span class="literal">true</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">undefined</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line"><span class="comment">// TypeError: Object.setPrototypeOf called on null or undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h4><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rec = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(rec, <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>如果参数不是对象，会被自动转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Number(1))</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Number &#123;[[PrimitiveValue]]: 0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(String(&#x27;foo&#x27;))</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// String &#123;length: 0, [[PrimitiveValue]]: &quot;&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于 Object.getPrototypeOf(Boolean(true))</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">true</span>)</span><br><span class="line"><span class="comment">// Boolean &#123;[[PrimitiveValue]]: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>) === <span class="built_in">Number</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="string">&#x27;foo&#x27;</span>) === <span class="built_in">String</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">true</span>) === <span class="built_in">Boolean</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">null</span>)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// TypeError: Cannot convert undefined or null to object</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h4><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure>

<p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries">引入</a>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h4><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure>

<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p>
<p><code>Object.values</code>只返回对象自身的可遍历属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;<span class="attr">p</span>: &#123;<span class="attr">value</span>: <span class="number">42</span>&#125;&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;<span class="attr">p</span>:</span><br><span class="line">  &#123;</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// [42]</span></span><br></pre></td></tr></table></figure>

<p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [&#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p>
<p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="number">42</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.values(<span class="literal">true</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h4 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h4><p><code>Object.entries()</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj)</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure>

<p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p>
<p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [ [ &#x27;foo&#x27;, &#x27;abc&#x27; ] ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非 Symbol 值的属性。</p>
<h4 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries()"></a>Object.fromEntries()</h4><p><code>Object.fromEntries()</code>方法是<code>Object.entries()</code>的逆操作，用于将一个键值对数组转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">])</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

<p>该方法的主要目的，是将键值对的数据结构还原为对象，因此特别适合将 Map 结构转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="keyword">const</span> entries = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>],</span><br><span class="line">  [<span class="string">&#x27;baz&#x27;</span>, <span class="number">42</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.fromEntries(entries)</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">&#x27;foo&#x27;</span>, <span class="literal">true</span>).set(<span class="string">&#x27;bar&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">Object</span>.fromEntries(map)</span><br><span class="line"><span class="comment">// &#123; foo: true, bar: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>该方法的一个用处是配合<code>URLSearchParams</code>对象，将查询字符串转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.fromEntries(<span class="keyword">new</span> URLSearchParams(<span class="string">&#x27;foo=bar&amp;baz=qux&#x27;</span>))</span><br><span class="line"><span class="comment">// &#123; foo: &quot;bar&quot;, baz: &quot;qux&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h4><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 属性简写</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法简写</span></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> cart = &#123;</span><br><span class="line">  _wheels: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  get wheels () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._wheels;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set wheels (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>._wheels) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;数值太小了！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._wheels = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p>JavaScript 定义对象的属性，有两种方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">obj.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">obj[<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p><strong>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</strong></p>
<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="literal">true</span>,</span><br><span class="line">  abc: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lastWord = <span class="string">&#x27;last word&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="string">&#x27;first word&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  [lastWord]: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;first word&#x27;</span>] <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">a[lastWord] <span class="comment">// &quot;world&quot;</span></span><br><span class="line">a[<span class="string">&#x27;last word&#x27;</span>] <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>表达式还可以用于定义方法名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span> + <span class="string">&#x27;ello&#x27;</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<h3 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h3><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.sayName.name   <span class="comment">// &quot;sayName&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，方法的<code>name</code>属性返回函数名（即方法名）。</p>
<p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">foo</span>() &#123;&#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">x</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo.name</span><br><span class="line"><span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">descriptor.get.name <span class="comment">// &quot;get foo&quot;</span></span><br><span class="line">descriptor.set.name <span class="comment">// &quot;set foo&quot;</span></span><br></pre></td></tr></table></figure>

<p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>()).name <span class="comment">// &quot;anonymous&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">doSomething.bind().name <span class="comment">// &quot;bound doSomething&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> key1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;description&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> key2 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [key1]() &#123;&#125;,</span><br><span class="line">  [key2]() &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj[key1].name <span class="comment">// &quot;[description]&quot;</span></span><br><span class="line">obj[key2].name <span class="comment">// &quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>key1</code>对应的 Symbol 值有描述，<code>key2</code>没有。</p>
<h3 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h3><h4 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h4><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure>

<p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">&#x27;toString&#x27;</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor([], <span class="string">&#x27;length&#x27;</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>
<p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="class"><span class="keyword">class</span> </span>&#123;foo() &#123;&#125;&#125;.prototype, <span class="string">&#x27;foo&#x27;</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p>
<h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<p><strong>（1）for…in</strong></p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（2）Object.keys(obj)</strong></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Reflect</span>.ownKeys(&#123; [<span class="built_in">Symbol</span>()]:<span class="number">0</span>, <span class="attr">b</span>:<span class="number">0</span>, <span class="number">10</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="attr">a</span>:<span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// [&#x27;2&#x27;, &#x27;10&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, Symbol()]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 Symbol 属性。</p>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><p>我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;world&#x27;</span>,</span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line">obj.find() <span class="comment">// &quot;hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj.find()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p>
<p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>
<h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h3><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><p>对象的解构赋值（<code>...</code>）用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p>
<p><strong>由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象。</strong></p>
<p><strong>解构赋值必须是最后一个参数，否则会报错。</strong></p>
<p><strong>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</strong></p>
<p><strong>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line"><span class="keyword">let</span> &#123; ...o3 &#125; = o2;</span><br><span class="line">o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line">o3.a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 x 和 y 参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> baseFunction(restConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩展运算符-1"><a href="#扩展运算符-1" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<p>由于数组是特殊的对象，所以对象的扩展运算符也可以用于数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = &#123; ...[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>] &#125;;</span><br><span class="line">foo</span><br><span class="line"><span class="comment">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果扩展运算符后面是一个空对象，则没有任何效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;...&#123;&#125;, <span class="attr">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果扩展运算符后面不是对象，则会自动将其转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等同于 &#123;...Object(1)&#125;</span></span><br><span class="line">&#123;..<span class="number">.1</span>&#125; <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，扩展运算符后面是整数<code>1</code>，会自动转为数值的包装对象<code>Number&#123;1&#125;</code>。由于该对象没有自身属性，所以返回一个空对象。</p>
<p>对象的扩展运算符等同于使用<code>Object.assign()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aClone = &#123; ...a &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aClone = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure>

<p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> clone1 = &#123;</span><br><span class="line">  __proto__: <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  ...obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> clone2 = <span class="built_in">Object</span>.assign(</span><br><span class="line">  <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj)),</span><br><span class="line">  obj</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">const</span> clone3 = <span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面代码中，写法一的<code>__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>
<p>扩展运算符可以用于合并两个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure>

<h3 id="链判断运算符"><a href="#链判断运算符" class="headerlink" title="链判断运算符"></a>链判断运算符</h3><p>编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取<code>message.body.user.firstName</code>，安全的写法是写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">const</span>  firstName = message.body.user.firstName;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">const</span> firstName = (message</span><br><span class="line">  &amp;&amp; message.body</span><br><span class="line">  &amp;&amp; message.body.user</span><br><span class="line">  &amp;&amp; message.body.user.firstName) || <span class="string">&#x27;default&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面例子中，<code>firstName</code>属性在对象的第四层，所以需要判断四次，每一层是否有值。</p>
<p>三元运算符<code>?:</code>也常用于判断对象是否存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fooInput = myForm.querySelector(<span class="string">&#x27;input[name=foo]&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> fooValue = fooInput ? fooInput.value : <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p>上面例子中，必须先判断<code>fooInput</code>是否存在，才能读取<code>fooInput.value</code>。</p>
<p>这样的层层判断非常麻烦，因此 <a href="https://github.com/tc39/proposal-optional-chaining">ES2020</a> 引入了“链判断运算符”（optional chaining operator）<code>?.</code>，简化上面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = message?.body?.user?.firstName || <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> fooValue = myForm.querySelector(<span class="string">&#x27;input[name=foo]&#x27;</span>)?.value</span><br></pre></td></tr></table></figure>

<p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p>
<p>下面是判断对象方法是否存在，如果存在就立即执行的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">iterator.return?.()</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>iterator.return</code>如果有定义，就会调用该方法，否则<code>iterator.return</code>直接返回<code>undefined</code>，不再执行<code>?.</code>后面的部分。</p>
<p>对于那些可能没有实现的方法，这个运算符尤其有用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (myForm.checkValidity?.() === <span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="comment">// 表单校验失败</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链判断运算符有三种用法。</p>
<ul>
<li><code>obj?.prop</code> // 对象属性</li>
<li><code>obj?.[expr]</code> // 同上</li>
<li><code>func?.(...args)</code> // 函数或对象方法的调用</li>
</ul>
<h3 id="Null-判断运算符"><a href="#Null-判断运算符" class="headerlink" title="Null 判断运算符"></a>Null 判断运算符</h3><p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> headerText = response.settings.headerText || <span class="string">&#x27;Hello, world!&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> animationDuration = response.settings.animationDuration || <span class="number">300</span>;</span><br><span class="line"><span class="keyword">const</span> showSplashScreen = response.settings.showSplashScreen || <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。</p>
<p>为了避免这种情况，<a href="https://github.com/tc39/proposal-nullish-coalescing">ES2020</a> 引入了一个新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</p>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-config-js-注解</title>
    <url>/2020/11/23/vue-config-js/</url>
    <content><![CDATA[<h2 id="CONTENT-OUTLINE"><a href="#CONTENT-OUTLINE" class="headerlink" title="CONTENT OUTLINE"></a>CONTENT OUTLINE</h2><blockquote>
<p>概述关于 <code>Vue-CLI3</code> 的 <code>vue.config.js</code> 配置参数</p>
<p><code>Vue</code> 官方 <code>CLI</code> <a href="https://cli.vuejs.org/zh/config/#%E5%85%A8%E5%B1%80-cli-%E9%85%8D%E7%BD%AE">配置参考</a>：官方给出的文档很全面</p>
<p>–  配置选项示例</p>
<p>–  配置项解读</p>
</blockquote>
<a id="more"></a>

<h3 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h3><blockquote>
<p>vue-cli3 脚手架搭建完成后，项目目录中没有 vue.config.js 文件，需要手动创建</p>
</blockquote>
<p><code>vue.config.js</code> 是一个可选的配置文件，如果项目的 (和 <code>package.json</code> 同级的) 根目录中存在这个文件，那么它会被 <code>@vue/cli-service</code> 自动加载。你也可以使用 <code>package.json</code> 中的 <code>vue</code> 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。</p>
<p>这个文件应该导出一个包含了选项的对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 选项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一、配置选项示例"><a href="#一、配置选项示例" class="headerlink" title="一、配置选项示例"></a>一、配置选项示例</h2><h3 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Vue.config.js 配置选项</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 选项</span></span><br><span class="line">    <span class="comment">//  基本路径</span></span><br><span class="line">    publicPath: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="comment">//  构建时的输出目录</span></span><br><span class="line">    outputDir: <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">    <span class="comment">//  放置静态资源的目录</span></span><br><span class="line">    assetsDir: <span class="string">&quot;static&quot;</span>,</span><br><span class="line">    <span class="comment">//  html 的输出路径</span></span><br><span class="line">    indexPath: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">    <span class="comment">//文件名哈希</span></span><br><span class="line">    filenameHashing: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//用于多页配置，默认是 undefined</span></span><br><span class="line">    pages: &#123;</span><br><span class="line">        index: &#123;</span><br><span class="line">            <span class="comment">// page 的入口文件</span></span><br><span class="line">            entry: <span class="string">&#x27;src/index/main.js&#x27;</span>,</span><br><span class="line">            <span class="comment">// 模板文件</span></span><br><span class="line">            template: <span class="string">&#x27;public/index.html&#x27;</span>,</span><br><span class="line">            <span class="comment">// 在 dist/index.html 的输出文件</span></span><br><span class="line">            filename: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">            <span class="comment">// 当使用页面 title 选项时，</span></span><br><span class="line">            <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">            title: <span class="string">&#x27;Index Page&#x27;</span>,</span><br><span class="line">            <span class="comment">// 在这个页面中包含的块，默认情况下会包含</span></span><br><span class="line">            <span class="comment">// 提取出来的通用 chunk 和 vendor chunk。</span></span><br><span class="line">            chunks: [<span class="string">&#x27;chunk-vendors&#x27;</span>, <span class="string">&#x27;chunk-common&#x27;</span>, <span class="string">&#x27;index&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 当使用只有入口的字符串格式时，</span></span><br><span class="line">        <span class="comment">// 模板文件默认是 `public/subpage.html`</span></span><br><span class="line">        <span class="comment">// 如果不存在，就回退到 `public/index.html`。</span></span><br><span class="line">        <span class="comment">// 输出文件默认是 `subpage.html`。</span></span><br><span class="line">        subpage: <span class="string">&#x27;src/subpage/main.js&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//  是否在保存的时候使用 `eslint-loader` 进行检查。</span></span><br><span class="line">    lintOnSave: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//  是否使用带有浏览器内编译器的完整构建版本</span></span><br><span class="line">    runtimeCompiler: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//  babel-loader 默认会跳过 node_modules 依赖。</span></span><br><span class="line">    transpileDependencies: [ <span class="comment">/* string or regex */</span> ],</span><br><span class="line">    <span class="comment">//  是否为生产环境构建生成 source map？</span></span><br><span class="line">    productionSourceMap: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//  设置生成的 HTML 中 &lt;link rel=&quot;stylesheet&quot;&gt; 和 &lt;script&gt; 标签的 crossorigin 属性。</span></span><br><span class="line">    crossorigin: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="comment">//  在生成的 HTML 中的 &lt;link rel=&quot;stylesheet&quot;&gt; 和 &lt;script&gt; 标签上启用 Subresource Integrity (SRI)。</span></span><br><span class="line">    integrity: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">//  调整内部的 webpack 配置</span></span><br><span class="line">    configureWebpack: <span class="function">() =&gt;</span> &#123;&#125;, <span class="comment">//(Object | Function)</span></span><br><span class="line">    chainWebpack: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">    <span class="comment">// 配置 webpack-dev-server 行为。</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: process.platform === <span class="string">&#x27;darwin&#x27;</span>,</span><br><span class="line">        host: <span class="string">&#x27;0.0.0.0&#x27;</span>,</span><br><span class="line">        port: <span class="number">8080</span>,</span><br><span class="line">        https: <span class="literal">false</span>,</span><br><span class="line">        hotOnly: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 查阅 https://github.com/vuejs/vue-docs-zh-cn/blob/master/vue-cli/cli-service.md#配置代理</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                target: <span class="string">&quot;http://app.rmsdmedia.com&quot;</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                secure: <span class="literal">false</span>,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&#x27;/foo&#x27;</span>: &#123;</span><br><span class="line">                target: <span class="string">&#x27;&lt;other_url&gt;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="comment">// string | Object</span></span><br><span class="line">        before: <span class="function"><span class="params">app</span> =&gt;</span> &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// CSS 相关选项</span></span><br><span class="line">    css: &#123;</span><br><span class="line">        <span class="comment">// 将组件内的 CSS 提取到一个单独的 CSS 文件 (只用在生产环境中)</span></span><br><span class="line">        <span class="comment">// 也可以是一个传递给 `extract-text-webpack-plugin` 的选项对象</span></span><br><span class="line">        extract: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 是否开启 CSS source map？</span></span><br><span class="line">        sourceMap: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 为预处理器的 loader 传递自定义选项。比如传递给</span></span><br><span class="line">        <span class="comment">// Css-loader 时，使用 `&#123; Css: &#123; ... &#125; &#125;`。</span></span><br><span class="line">        loaderOptions: &#123;</span><br><span class="line">            css: &#123;</span><br><span class="line">                <span class="comment">// 这里的选项会传递给 css-loader</span></span><br><span class="line">            &#125;,</span><br><span class="line">            postcss: &#123;</span><br><span class="line">                <span class="comment">// 这里的选项会传递给 postcss-loader</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 为所有的 CSS 及其预处理文件开启 CSS Modules。</span></span><br><span class="line">        <span class="comment">// 这个选项不会影响 `*.vue` 文件。</span></span><br><span class="line">        modules: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 在生产环境下为 Babel 和 TypeScript 使用 `thread-loader`</span></span><br><span class="line">    <span class="comment">// 在多核机器下会默认开启。</span></span><br><span class="line">    parallel: <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>).cpus().length &gt; <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// PWA 插件的选项。</span></span><br><span class="line">    <span class="comment">// 查阅 https://github.com/vuejs/vue-docs-zh-cn/blob/master/vue-cli-plugin-pwa/README.md</span></span><br><span class="line">    pwa: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 三方插件的选项</span></span><br><span class="line">    pluginOptions: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="示例二-简化"><a href="#示例二-简化" class="headerlink" title="示例二(简化)"></a>示例二(简化)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// publicPath:process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;/vue_workspac/aihuhuproject/&#x27; : &#x27;/&#x27;,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本路径</span></span><br><span class="line">    publicPath: <span class="string">&#x27;./&#x27;</span>,<span class="comment">//默认的&#x27;/&#x27;是绝对路径，如果不确定在根路径，改成相对路径&#x27;./&#x27;</span></span><br><span class="line">    <span class="comment">// 输出文件目录</span></span><br><span class="line">    outputDir: <span class="string">&#x27;dist&#x27;</span>,</span><br><span class="line">    assetsDir:<span class="string">&#x27;static&#x27;</span>,</span><br><span class="line">    indexPath:<span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">    <span class="comment">// eslint-loader 是否在保存的时候检查</span></span><br><span class="line">    lintOnSave: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 生产环境是否生成 sourceMap 文件</span></span><br><span class="line">    productionSourceMap: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// css相关配置</span></span><br><span class="line">    css: &#123;</span><br><span class="line">        <span class="comment">// 是否使用css分离插件 ExtractTextPlugin</span></span><br><span class="line">        extract: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 开启 CSS source maps?</span></span><br><span class="line">        sourceMap: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// webpack-dev-server 相关配置</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        open: <span class="literal">false</span>,<span class="comment">//open 在devServer启动且第一次构建完成时，自动用我们的系统的默认浏览器去打开要开发的网页</span></span><br><span class="line">        host: <span class="string">&#x27;0.0.0.0&#x27;</span>,<span class="comment">//默认是 localhost。如果你希望服务器外部可访问，指定如下 host: &#x27;0.0.0.0&#x27;，设置之后之后可以访问ip地址</span></span><br><span class="line">        port: <span class="number">8080</span>,</span><br><span class="line">        hot:<span class="literal">true</span>,<span class="comment">//hot配置是否启用模块的热替换功能，devServer的默认行为是在发现源代码被变更后，通过自动刷新整个页面来做到事实预览，开启hot后，将在不刷新整个页面的情况下通过新模块替换老模块来做到实时预览。</span></span><br><span class="line">        https: <span class="literal">false</span>,</span><br><span class="line">        hotOnly: <span class="literal">false</span>,<span class="comment">// hot 和 hotOnly 的区别是在某些模块不支持热更新的情况下，前者会自动刷新页面，后者不会刷新页面，而是在控制台输出热更新失败</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">&#x27;/&#x27;</span>: &#123;</span><br><span class="line">                target: <span class="string">&#x27;http://xxxx:8080&#x27;</span>, <span class="comment">//目标接口域名</span></span><br><span class="line">                secure: <span class="literal">false</span>, <span class="comment">//false为http访问，true为https访问</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>, <span class="comment">//是否跨域</span></span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">&#x27;^/&#x27;</span>: <span class="string">&#x27;/&#x27;</span> <span class="comment">//重写接口</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="comment">// 设置代理</span></span><br><span class="line">        before: <span class="function"><span class="params">app</span> =&gt;</span> &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 第三方插件配置</span></span><br><span class="line">    pluginOptions: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> path.join(__dirname, dir);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    publicPath: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    outputDir: <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">    assetsDir: <span class="string">&quot;static&quot;</span>,</span><br><span class="line">    lintOnSave: <span class="literal">false</span>, <span class="comment">// 是否开启eslint保存检测</span></span><br><span class="line">    productionSourceMap: <span class="literal">false</span>, <span class="comment">// 是否在构建生产包时生成sourcdeMap</span></span><br><span class="line">    chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">        config.resolve.alias</span><br><span class="line">            .set(<span class="string">&quot;@&quot;</span>, resolve(<span class="string">&quot;src&quot;</span>))</span><br><span class="line">            .set(<span class="string">&quot;@&quot;</span>, resolve(<span class="string">&quot;src/views&quot;</span>))</span><br><span class="line">            .set(<span class="string">&quot;@&quot;</span>, resolve(<span class="string">&quot;src/components&quot;</span>))</span><br><span class="line">            .set(<span class="string">&quot;@&quot;</span>, resolve(<span class="string">&quot;src/common&quot;</span>))</span><br><span class="line">            .set(<span class="string">&quot;@&quot;</span>, resolve(<span class="string">&quot;src/utils&quot;</span>))</span><br><span class="line">            .set(<span class="string">&quot;@&quot;</span>, resolve(<span class="string">&quot;src/service&quot;</span>)); <span class="comment">/* 别名配置 */</span></span><br><span class="line">        config.optimization.runtimeChunk(<span class="string">&quot;single&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        <span class="comment">// host: &quot;localhost&quot;,</span></span><br><span class="line">        <span class="comment">/* 本地ip地址 */</span></span><br><span class="line">        host: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">        port: <span class="string">&quot;10000&quot;</span>,</span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">/* 自动打开浏览器 */</span></span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        overlay: &#123;</span><br><span class="line">            warning: <span class="literal">false</span>,</span><br><span class="line">            error: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">/* 跨域代理 */</span></span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">&quot;/item&quot;</span>: &#123;</span><br><span class="line">                <span class="comment">/* 目标代理服务器地址 */</span></span><br><span class="line">                target: <span class="string">&quot;http://localhost:80&quot;</span>, <span class="comment">//localhost:80/api/item/category/list</span></span><br><span class="line">                <span class="comment">// target: &quot;http://192.168.1.102:8888&quot;, //</span></span><br><span class="line">                <span class="comment">/* 允许跨域 */</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                ws: <span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">&quot;^/item&quot;</span>: <span class="string">&quot;/api/item&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;/upfile&quot;</span>: &#123;</span><br><span class="line">                <span class="comment">/* 目标代理服务器地址 */</span></span><br><span class="line">                target: <span class="string">&quot;http://localhost:80&quot;</span>, <span class="comment">//localhost:80/api/item/category/list</span></span><br><span class="line">                <span class="comment">// target: &quot;http://192.168.1.102:8888&quot;, //</span></span><br><span class="line">                <span class="comment">/* 允许跨域 */</span></span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                ws: <span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">&quot;^/upfile&quot;</span>: <span class="string">&quot;/api/upfile&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">/*&quot;/upload&quot;: &#123;</span></span><br><span class="line"><span class="comment">                /!* 目标代理服务器地址 *!/</span></span><br><span class="line"><span class="comment">                target: &quot;http://localhost:8082&quot;, //localhost:80/api/item/category/list</span></span><br><span class="line"><span class="comment">                // target: &quot;http://192.168.1.102:8888&quot;, //</span></span><br><span class="line"><span class="comment">                /!* 允许跨域 *!/</span></span><br><span class="line"><span class="comment">                changeOrigin: true,</span></span><br><span class="line"><span class="comment">                ws: true,</span></span><br><span class="line"><span class="comment">                pathRewrite: &#123;</span></span><br><span class="line"><span class="comment">                    &quot;^/upload&quot;: &quot;/upload&quot;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;,*/</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<br>

<h2 id="二、配置项解读"><a href="#二、配置项解读" class="headerlink" title="二、配置项解读"></a>二、配置项解读</h2><h3 id="1、publicPath"><a href="#1、publicPath" class="headerlink" title="1、publicPath"></a>1、publicPath</h3><ul>
<li><p>Type: <code>string</code></p>
</li>
<li><p>Default: <code>&#39;/&#39;</code></p>
<p>部署应用包时的基本 URL。用法和 webpack 本身的 <code>output.publicPath</code> 一致，但是 Vue CLI 在一些其他地方也需要用到这个值，所以**请始终使用 <code>publicPath</code> 而不要直接修改 webpack 的 <code>output.publicPath</code>**。</p>
<p>默认情况下，Vue CLI 会假设你的应用是被部署在一个域名的根路径上，例如 <code>https://www.my-app.com/</code>。如果应用被部署在一个子路径上，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 <code>https://www.my-app.com/my-app/</code>，则设置 <code>publicPath</code> 为 <code>/my-app/</code>。</p>
<p>这个值也可以被设置为空字符串 (<code>&#39;&#39;</code>) 或是相对路径 (<code>&#39;./&#39;</code>)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径，也可以用在类似 Cordova hybrid 应用的文件系统中。</p>
<p>相对 publicPath 的限制</p>
<p>相对路径的 <code>publicPath</code> 有一些使用上的限制。在以下情况下，应当避免使用相对 <code>publicPath</code>:</p>
<ul>
<li>当使用基于 HTML5 <code>history.pushState</code> 的路由时；</li>
<li>当使用 <code>pages</code> 选项构建多页面应用时。</li>
</ul>
<p>这个值在开发环境下同样生效。如果你想把开发服务器架设在根路径，你可以使用一个条件式的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  publicPath: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span></span><br><span class="line">    ? <span class="string">&#x27;/production-sub-path/&#x27;</span></span><br><span class="line">    : <span class="string">&#x27;/&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2、outputDir"><a href="#2、outputDir" class="headerlink" title="2、outputDir"></a>2、outputDir</h3><ul>
<li><p>Type: <code>string</code></p>
</li>
<li><p>Default: <code>&#39;dist&#39;</code></p>
<p>当运行 <code>vue-cli-service build</code> 时生成的生产环境构建文件的目录。注意目标目录在构建之前会被清除 (构建时传入 <code>--no-clean</code> 可关闭该行为)。</p>
<p>提示</p>
<p>请始终使用 <code>outputDir</code> 而不要修改 webpack 的 <code>output.path</code>。</p>
</li>
</ul>
<h3 id="3、assetsDir"><a href="#3、assetsDir" class="headerlink" title="3、assetsDir"></a>3、assetsDir</h3><ul>
<li><p>Type: <code>string</code></p>
</li>
<li><p>Default: <code>&#39;&#39;</code></p>
<p>放置生成的静态资源 (js、css、img、fonts) 的 (相对于 <code>outputDir</code> 的) 目录。</p>
<p>提示</p>
<p>从生成的资源覆写 filename 或 chunkFilename 时，<code>assetsDir</code> 会被忽略。</p>
</li>
</ul>
<h3 id="4、indexPath"><a href="#4、indexPath" class="headerlink" title="4、indexPath"></a>4、indexPath</h3><ul>
<li><p>Type: <code>string</code></p>
</li>
<li><p>Default: <code>&#39;index.html&#39;</code></p>
<p>指定生成的 <code>index.html</code> 的输出路径 (相对于 <code>outputDir</code>)。也可以是一个绝对路径。</p>
</li>
</ul>
<h3 id="5、filenameHashing"><a href="#5、filenameHashing" class="headerlink" title="5、filenameHashing"></a>5、filenameHashing</h3><ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>true</code></p>
<p>默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存。然而，这也要求 index 的 HTML 是被 Vue CLI 自动生成的。如果你无法使用 Vue CLI 生成的 index HTML，你可以通过将这个选项设为 <code>false</code> 来关闭文件名哈希。</p>
</li>
</ul>
<h3 id="6、pages"><a href="#6、pages" class="headerlink" title="6、pages"></a>6、pages</h3><ul>
<li><p>Type: <code>Object</code></p>
</li>
<li><p>Default: <code>undefined</code></p>
<p>在 multi-page 模式下构建应用。每个“page”应该有一个对应的 JavaScript 入口文件。其值应该是一个对象，对象的 key 是入口的名字，value 是：</p>
<ul>
<li>一个指定了 <code>entry</code>, <code>template</code>, <code>filename</code>, <code>title</code> 和 <code>chunks</code> 的对象 (除了 <code>entry</code> 之外都是可选的)；</li>
<li>或一个指定其 <code>entry</code> 的字符串。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      <span class="comment">// page 的入口</span></span><br><span class="line">      entry: <span class="string">&#x27;src/index/main.js&#x27;</span>,</span><br><span class="line">      <span class="comment">// 模板来源</span></span><br><span class="line">      template: <span class="string">&#x27;public/index.html&#x27;</span>,</span><br><span class="line">      <span class="comment">// 在 dist/index.html 的输出</span></span><br><span class="line">      filename: <span class="string">&#x27;index.html&#x27;</span>,</span><br><span class="line">      <span class="comment">// 当使用 title 选项时，</span></span><br><span class="line">      <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">      title: <span class="string">&#x27;Index Page&#x27;</span>,</span><br><span class="line">      <span class="comment">// 在这个页面中包含的块，默认情况下会包含</span></span><br><span class="line">      <span class="comment">// 提取出来的通用 chunk 和 vendor chunk。</span></span><br><span class="line">      chunks: [<span class="string">&#x27;chunk-vendors&#x27;</span>, <span class="string">&#x27;chunk-common&#x27;</span>, <span class="string">&#x27;index&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 当使用只有入口的字符串格式时，</span></span><br><span class="line">    <span class="comment">// 模板会被推导为 `public/subpage.html`</span></span><br><span class="line">    <span class="comment">// 并且如果找不到的话，就回退到 `public/index.html`。</span></span><br><span class="line">    <span class="comment">// 输出文件名会被推导为 `subpage.html`。</span></span><br><span class="line">    subpage: <span class="string">&#x27;src/subpage/main.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示</p>
<p>当在 multi-page 模式下构建时，webpack 配置会包含不一样的插件 (这时会存在多个 <code>html-webpack-plugin</code> 和 <code>preload-webpack-plugin</code> 的实例)。如果你试图修改这些插件的选项，请确认运行 <code>vue inspect</code>。</p>
</li>
</ul>
<h3 id="7、lintOnSave"><a href="#7、lintOnSave" class="headerlink" title="7、lintOnSave"></a>7、lintOnSave</h3><ul>
<li><p>Type: <code>boolean</code> | <code>&#39;warning&#39;</code> | <code>&#39;default&#39;</code> | <code>&#39;error&#39;</code></p>
</li>
<li><p>Default: <code>&#39;default&#39;</code></p>
<p>是否在开发环境下通过 <a href="https://github.com/webpack-contrib/eslint-loader">eslint-loader</a> 在每次保存时 lint 代码。这个值会在 <a href="https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-eslint"><code>@vue/cli-plugin-eslint</code></a> 被安装之后生效。</p>
<p>设置为 <code>true</code> 或 <code>&#39;warning&#39;</code> 时，<code>eslint-loader</code> 会将 lint 错误输出为编译警告。默认情况下，警告仅仅会被输出到命令行，且不会使得编译失败。</p>
<p>如果你希望让 lint 错误在开发时直接显示在浏览器中，你可以使用 <code>lintOnSave: &#39;default&#39;</code>。这会强制 <code>eslint-loader</code> 将 lint 错误输出为编译错误，同时也意味着 lint 错误将会导致编译失败。</p>
<p>设置为 <code>error</code> 将会使得 <code>eslint-loader</code> 把 lint 警告也输出为编译错误，这意味着 lint 警告将会导致编译失败。</p>
<p>或者，你也可以通过设置让浏览器 overlay 同时显示警告和错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    overlay: &#123;</span><br><span class="line">      warnings: <span class="literal">true</span>,</span><br><span class="line">      errors: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>lintOnSave</code> 是一个 truthy 的值时，<code>eslint-loader</code> 在开发和生产构建下都会被启用。如果你想要在生产构建时禁用 <code>eslint-loader</code>，你可以用如下配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  lintOnSave: process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="8、runtimeCompiler"><a href="#8、runtimeCompiler" class="headerlink" title="8、runtimeCompiler"></a>8、runtimeCompiler</h3><ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>false</code></p>
<p>是否使用包含运行时编译器的 Vue 构建版本。设置为 <code>true</code> 后你就可以在 Vue 组件中使用 <code>template</code>选项了，但是这会让你的应用额外增加 10kb 左右。</p>
<p>更多细节可查阅：<a href="https://cn.vuejs.org/v2/guide/installation.html#%E8%BF%90%E8%A1%8C%E6%97%B6-%E7%BC%96%E8%AF%91%E5%99%A8-vs-%E5%8F%AA%E5%8C%85%E5%90%AB%E8%BF%90%E8%A1%8C%E6%97%B6">Runtime + Compiler vs. Runtime only</a>。</p>
</li>
</ul>
<h3 id="9、transpileDependencies"><a href="#9、transpileDependencies" class="headerlink" title="9、transpileDependencies"></a>9、transpileDependencies</h3><ul>
<li><p>Type: <code>Array&lt;string | RegExp&gt;</code></p>
</li>
<li><p>Default: <code>[]</code></p>
<p>默认情况下 <code>babel-loader</code> 会忽略所有 <code>node_modules</code> 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来。</p>
</li>
</ul>
<h3 id="10、productionSourceMap"><a href="#10、productionSourceMap" class="headerlink" title="10、productionSourceMap"></a>10、productionSourceMap</h3><ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>true</code></p>
<p>如果你不需要生产环境的 source map，可以将其设置为 <code>false</code> 以加速生产环境构建。</p>
</li>
</ul>
<h3 id="11、crossorigin"><a href="#11、crossorigin" class="headerlink" title="11、crossorigin"></a>11、crossorigin</h3><ul>
<li><p>Type: <code>string</code></p>
</li>
<li><p>Default: <code>undefined</code></p>
<p>设置生成的 HTML 中 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 和 <code>&lt;script&gt;</code> 标签的 <code>crossorigin</code> 属性。</p>
<p>需要注意的是该选项仅影响由 <code>html-webpack-plugin</code> 在构建时注入的标签 - 直接写在模版 (<code>public/index.html</code>) 中的标签不受影响。</p>
<p>更多细节可查阅: <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_settings_attributes">CORS settings attributes</a></p>
</li>
</ul>
<h3 id="12、integrity"><a href="#12、integrity" class="headerlink" title="12、integrity"></a>12、integrity</h3><ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>false</code></p>
<p>在生成的 HTML 中的 <code>&lt;link rel=&quot;stylesheet&quot;&gt;</code> 和 <code>&lt;script&gt;</code> 标签上启用 <a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity">Subresource Integrity</a>(SRI)。如果你构建后的文件是部署在 CDN 上的，启用该选项可以提供额外的安全性。</p>
<p>需要注意的是该选项仅影响由 <code>html-webpack-plugin</code> 在构建时注入的标签 - 直接写在模版 (<code>public/index.html</code>) 中的标签不受影响。</p>
<p>另外，当启用 SRI 时，preload resource hints 会被禁用，因为 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=677022">Chrome 的一个 bug</a> 会导致文件被下载两次。</p>
</li>
</ul>
<br>

<h2 id="三、配置项解读（webpack相关）"><a href="#三、配置项解读（webpack相关）" class="headerlink" title="三、配置项解读（webpack相关）"></a>三、配置项解读（webpack相关）</h2><h3 id="1、configureWebpack"><a href="#1、configureWebpack" class="headerlink" title="1、configureWebpack"></a>1、configureWebpack</h3><ul>
<li><p>Type: <code>Object | Function</code></p>
<p>如果这个值是一个对象，则会通过 <a href="https://github.com/survivejs/webpack-merge">webpack-merge</a> 合并到最终的配置中。</p>
<p>如果这个值是一个函数，则会接收被解析的配置作为参数。该函数既可以修改配置并不返回任何东西，也可以返回一个被克隆或合并过的配置版本。</p>
<p>更多细节可查阅：<a href="https://cli.vuejs.org/zh/guide/webpack.html#%E7%AE%80%E5%8D%95%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F">配合 webpack &gt; 简单的配置方式</a></p>
</li>
</ul>
<h3 id="2、chainWebpack"><a href="#2、chainWebpack" class="headerlink" title="2、chainWebpack"></a>2、chainWebpack</h3><ul>
<li><p>Type: <code>Function</code></p>
<p>是一个函数，会接收一个基于 <a href="https://github.com/mozilla-neutrino/webpack-chain">webpack-chain</a> 的 <code>ChainableConfig</code> 实例。允许对内部的 webpack 配置进行更细粒度的修改。</p>
<p>更多细节可查阅：<a href="https://cli.vuejs.org/zh/guide/webpack.html#%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C-%E9%AB%98%E7%BA%A7">配合 webpack &gt; 链式操作</a></p>
</li>
</ul>
<h3 id="3、css-modules"><a href="#3、css-modules" class="headerlink" title="3、css.modules"></a>3、css.modules</h3><p>从 v4 起已弃用，请使用<a href="https://cli.vuejs.org/zh/config/#css-requireModuleExtension"><code>css.requireModuleExtension</code></a>。 在 v3 中，这个选项含义与 <code>css.requireModuleExtension</code> 相反。</p>
<h3 id="4、css-requireModuleExtension"><a href="#4、css-requireModuleExtension" class="headerlink" title="4、css.requireModuleExtension"></a>4、css.requireModuleExtension</h3><ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>true</code></p>
<p>默认情况下，只有 <code>*.module.[ext]</code> 结尾的文件才会被视作 CSS Modules 模块。设置为 <code>false</code> 后你就可以去掉文件名中的 <code>.module</code> 并将所有的 <code>*.(css|scss|sass|less|styl(us)?)</code> 文件视为 CSS Modules 模块。</p>
<p>提示</p>
<p>如果你在 <code>css.loaderOptions.css</code> 里配置了自定义的 CSS Module 选项，则 <code>css.requireModuleExtension</code> 必须被显式地指定为 <code>true</code> 或者 <code>false</code>，否则我们无法确定你是否希望将这些自定义配置应用到所有 CSS 文件中。</p>
<p>更多细节可查阅：<a href="https://cli.vuejs.org/zh/guide/css.html#css-modules">配合 CSS &gt; CSS Modules</a></p>
</li>
</ul>
<h3 id="5、css-extract"><a href="#5、css-extract" class="headerlink" title="5、css.extract"></a>5、css.extract</h3><ul>
<li><p>Type: <code>boolean | Object</code></p>
</li>
<li><p>Default: 生产环境下是 <code>true</code>，开发环境下是 <code>false</code></p>
<p>是否将组件中的 CSS 提取至一个独立的 CSS 文件中 (而不是动态注入到 JavaScript 中的 inline 代码)。</p>
<p>同样当构建 Web Components 组件时它总是会被禁用 (样式是 inline 的并注入到了 shadowRoot 中)。</p>
<p>当作为一个库构建时，你也可以将其设置为 <code>false</code> 免得用户自己导入 CSS。</p>
<p>提取 CSS 在开发环境模式下是默认不开启的，因为它和 CSS 热重载不兼容。然而，你仍然可以将这个值显性地设置为 <code>true</code> 在所有情况下都强制提取。</p>
</li>
</ul>
<h3 id="6、css-sourceMap"><a href="#6、css-sourceMap" class="headerlink" title="6、css.sourceMap"></a>6、css.sourceMap</h3><ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>false</code></p>
<p>是否为 CSS 开启 source map。设置为 <code>true</code> 之后可能会影响构建的性能。</p>
</li>
</ul>
<h3 id="7、css-loaderOptions"><a href="#7、css-loaderOptions" class="headerlink" title="7、css.loaderOptions"></a>7、css.loaderOptions</h3><ul>
<li><p>Type: <code>Object</code></p>
</li>
<li><p>Default: <code>&#123;&#125;</code></p>
<p>向 CSS 相关的 loader 传递选项。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  css: &#123;</span><br><span class="line">    loaderOptions: &#123;</span><br><span class="line">      css: &#123;</span><br><span class="line">        <span class="comment">// 这里的选项会传递给 css-loader</span></span><br><span class="line">      &#125;,</span><br><span class="line">      postcss: &#123;</span><br><span class="line">        <span class="comment">// 这里的选项会传递给 postcss-loader</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支持的 loader 有：</p>
<ul>
<li><a href="https://github.com/webpack-contrib/css-loader">css-loader</a></li>
<li><a href="https://github.com/postcss/postcss-loader">postcss-loader</a></li>
<li><a href="https://github.com/webpack-contrib/sass-loader">sass-loader</a></li>
<li><a href="https://github.com/webpack-contrib/less-loader">less-loader</a></li>
<li><a href="https://github.com/shama/stylus-loader">stylus-loader</a></li>
</ul>
<p>另外，也可以使用 <code>scss</code> 选项，针对 <code>scss</code> 语法进行单独配置（区别于 <code>sass</code> 语法）。</p>
<p>更多细节可查阅：<a href="https://cli.vuejs.org/zh/guide/css.html#%E5%90%91%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-loader-%E4%BC%A0%E9%80%92%E9%80%89%E9%A1%B9">向预处理器 Loader 传递选项</a></p>
<p>提示</p>
<p>相比于使用 <code>chainWebpack</code> 手动指定 loader 更推荐上面这样做，因为这些选项需要应用在使用了相应 loader 的多个地方。</p>
</li>
</ul>
<h3 id="8、devServer"><a href="#8、devServer" class="headerlink" title="8、devServer"></a>8、devServer</h3><ul>
<li><p>Type: <code>Object</code></p>
<p><a href="https://webpack.js.org/configuration/dev-server/">所有 <code>webpack-dev-server</code> 的选项</a>都支持。注意：</p>
<ul>
<li>有些值像 <code>host</code>、<code>port</code> 和 <code>https</code> 可能会被命令行参数覆写。</li>
<li>有些值像 <code>publicPath</code> 和 <code>historyApiFallback</code> 不应该被修改，因为它们需要和开发服务器的 <a href="https://cli.vuejs.org/zh/config/#publicpath">publicPath</a> 同步以保障正常的工作。</li>
</ul>
</li>
</ul>
<h3 id="9、devServer-proxy"><a href="#9、devServer-proxy" class="headerlink" title="9、devServer.proxy"></a>9、devServer.proxy</h3><ul>
<li><p>Type: <code>string | Object</code></p>
<p>如果你的前端应用和后端 API 服务器没有运行在同一个主机上，你需要在开发环境下将 API 请求代理到 API 服务器。这个问题可以通过 <code>vue.config.js</code> 中的 <code>devServer.proxy</code> 选项来配置。</p>
<p><code>devServer.proxy</code> 可以是一个指向开发环境 API 服务器的字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: <span class="string">&#x27;http://localhost:4000&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会告诉开发服务器将任何未知请求 (没有匹配到静态文件的请求) 代理到<code>http://localhost:4000</code>。</p>
<p>如果你想要更多的代理控制行为，也可以使用一个 <code>path: options</code> 成对的对象。完整的选项可以查阅 <a href="https://github.com/chimurai/http-proxy-middleware#proxycontext-config">http-proxy-middleware</a> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        target: <span class="string">&#x27;&lt;url&gt;&#x27;</span>,</span><br><span class="line">        ws: <span class="literal">true</span>,</span><br><span class="line">        changeOrigin: <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/foo&#x27;</span>: &#123;</span><br><span class="line">        target: <span class="string">&#x27;&lt;other_url&gt;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="10、parallel"><a href="#10、parallel" class="headerlink" title="10、parallel"></a>10、parallel</h3><ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>require(&#39;os&#39;).cpus().length &gt; 1</code></p>
<p>是否为 Babel 或 TypeScript 使用 <code>thread-loader</code>。该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。</p>
</li>
</ul>
<h3 id="11、pwa"><a href="#11、pwa" class="headerlink" title="11、pwa"></a>11、pwa</h3><ul>
<li><p>Type: <code>Object</code></p>
<p>向 <a href="https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa">PWA 插件</a>传递选项。</p>
</li>
</ul>
<h3 id="12、pluginOptions"><a href="#12、pluginOptions" class="headerlink" title="12、pluginOptions"></a>12、pluginOptions</h3><ul>
<li><p>Type: <code>Object</code></p>
<p>这是一个不进行任何 schema 验证的对象，因此它可以用来传递任何第三方插件选项。例如：</p>
</li>
</ul>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Front End</category>
      </categories>
      <tags>
        <tag>框架与工具</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
