<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.0.2"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/mustache_32px.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/mustache_16px.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.0/css/brands.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.0/css/solid.min.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script></script><script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"hammerzer.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"default"},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!0,pangu:!1,comments:{style:"tabs",active:"valine",storage:!0,lazyload:!0,nav:null,activeClass:"valine"},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="一、HTML渲染过程1. HTML解析过程 构建DOM树：将HTML构建成一个DOM树，也就是构建节点，把所有的节点都构建出来  构建CSSOM树：解析css去构建CSSOM树  根据DOM树和CSSOM树构建render树：DOM树和CSSOM树已经构建完毕，浏览器会根据这两个来构造render树，浏览器就知道了有哪些节点、各个节点的CSS定义以及他们的从属关系  布局：有了render树就开始"><meta property="og:type" content="article"><meta property="og:title" content="HTML渲染"><meta property="og:url" content="https://hammerzer.github.io/2020/08/29/HTML-render/index.html"><meta property="og:site_name" content="Moustache&#39;s Blog"><meta property="og:description" content="一、HTML渲染过程1. HTML解析过程 构建DOM树：将HTML构建成一个DOM树，也就是构建节点，把所有的节点都构建出来  构建CSSOM树：解析css去构建CSSOM树  根据DOM树和CSSOM树构建render树：DOM树和CSSOM树已经构建完毕，浏览器会根据这两个来构造render树，浏览器就知道了有哪些节点、各个节点的CSS定义以及他们的从属关系  布局：有了render树就开始"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://hammerzer.github.io/2020/08/29/HTML-render/pic1.png"><meta property="og:image" content="https://hammerzer.github.io/2020/08/29/HTML-render/pic2.png"><meta property="og:image" content="https://hammerzer.github.io/2020/08/29/HTML-render/pic3.png"><meta property="og:image" content="https://hammerzer.github.io/2020/08/29/HTML-render/pic4.png"><meta property="og:image" content="https://hammerzer.github.io/2020/08/29/HTML-render/pic5.png"><meta property="og:image" content="https://hammerzer.github.io/2020/08/29/HTML-render/pic6.png"><meta property="og:image" content="https://hammerzer.github.io/2020/08/29/HTML-render/pic7.png"><meta property="og:image" content="https://hammerzer.github.io/2020/08/29/HTML-render/pic8.png"><meta property="og:image" content="https://hammerzer.github.io/2020/08/29/HTML-render/pic9.png"><meta property="article:published_time" content="2020-08-29T09:26:56.000Z"><meta property="article:modified_time" content="2020-08-31T09:19:41.104Z"><meta property="article:author" content="Moustache"><meta property="article:tag" content="Html"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://hammerzer.github.io/2020/08/29/HTML-render/pic1.png"><link rel="canonical" href="https://hammerzer.github.io/2020/08/29/HTML-render/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>HTML渲染 | Moustache's Blog</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Moustache's Blog</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">小胡子的私人空间</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">10</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">2</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">13</span></a></li><li class="menu-item menu-item-sitemap"><a href="/baidusitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="reading-progress-bar"></div><a href="https://github.com/Hammerzer" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://hammerzer.github.io/2020/08/29/HTML-render/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/p1.png"><meta itemprop="name" content="Moustache"><meta itemprop="description" content="我是小胡子"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Moustache's Blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">HTML渲染</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-08-29 17:26:56" itemprop="dateCreated datePublished" datetime="2020-08-29T17:26:56+08:00">2020-08-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-08-31 17:19:41" itemprop="dateModified" datetime="2020-08-31T17:19:41+08:00">2020-08-31</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Front-End/" itemprop="url" rel="index"><span itemprop="name">Front End</span></a> </span></span><span id="/2020/08/29/HTML-render/" class="post-meta-item leancloud_visitors" data-flag-title="HTML渲染" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2020/08/29/HTML-render/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/08/29/HTML-render/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.9k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="一、HTML渲染过程"><a href="#一、HTML渲染过程" class="headerlink" title="一、HTML渲染过程"></a>一、HTML渲染过程</h2><h3 id="1-HTML解析过程"><a href="#1-HTML解析过程" class="headerlink" title="1. HTML解析过程"></a>1. HTML解析过程</h3><ol><li><p><strong>构建DOM树</strong>：将HTML构建成一个DOM树，也就是构建节点，把所有的节点都构建出来</p></li><li><p><strong>构建CSSOM树</strong>：解析css去构建CSSOM树</p></li><li><p><strong>根据DOM树和CSSOM树构建render树</strong>：DOM树和CSSOM树已经构建完毕，浏览器会根据这两个来构造render树，浏览器就知道了有哪些节点、各个节点的CSS定义以及他们的从属关系</p></li><li><p><strong>布局</strong>：有了render树就开始布局Layout，开始计算各个节点的位置和样式</p></li><li><p><strong>绘制</strong>：遍历render树，在页面上绘制每个节点</p></li><li><p><strong><em>重排reflow</em></strong>：当render树绘制完成之后，比如JavaScript改变样式或添加节点，这时候render树就需要重新计算</p></li><li><p><strong><em>重绘repaint</em></strong>：既然重排了，最后当然得重新绘制页面。</p></li></ol><a id="more"></a><h3 id="2-浏览器渲染页面详解"><a href="#2-浏览器渲染页面详解" class="headerlink" title="2. 浏览器渲染页面详解"></a>2. 浏览器渲染页面详解</h3><blockquote><p>找了一篇已经很全的文章，所以不继续造轮子了，接下来分享一下<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010298038">这篇文章</a>，同时感谢原作者</p></blockquote><p>由一道面试题引发的思考：</p><p><strong>从用户输入浏览器输入url到页面最后呈现 有哪些过程？</strong><br><em>一道很常规的题目，考的是基本网络原理，和浏览器加载css，js过程。</em></p><p><strong><em>答案大致如下：</em></strong></p><blockquote><ol><li><p>用户输入URL地址</p></li><li><p>浏览器解析URL解析出主机名</p></li><li><p>浏览器将主机名转换成服务器ip地址（浏览器先查找本地DNS缓存列表 没有的话 再向浏览器默认的DNS服务器发送查询请求 同时缓存）</p></li><li><p>浏览器将端口号从URL中解析出来</p></li><li><p>浏览器建立一条与目标Web服务器的TCP连接（三次握手）</p></li><li><p>浏览器向服务器发送一条HTTP请求报文</p></li><li><p>服务器向浏览器返回一条HTTP响应报文</p></li><li><p>关闭连接 浏览器解析文档</p></li><li><p>如果文档中有资源 重复6 7 8 动作 直至资源全部加载完毕</p></li></ol></blockquote><p><strong>通过研究，了解一些基本常识的原理：</strong></p><ol><li>为什么要将js放到页脚部分</li><li>引入样式的几种方式的权重</li><li>css属性书写顺序建议</li><li>何种类型的DOM操作是耗费性能的</li></ol><h4 id="2-1-浏览器渲染主要流程"><a href="#2-1-浏览器渲染主要流程" class="headerlink" title="2.1 浏览器渲染主要流程"></a>2.1 浏览器渲染主要流程</h4><p>不同的浏览器内核不同，所以渲染过程不太一样。</p><p><code>WebKit 主流程</code></p><p><img data-src="pic1.png"></p><p><code>Mozilla</code> 的 <code>Gecko</code> 呈现引擎主流程</p><p><img data-src="pic2.png"></p><p>由上面两张图可以看出，虽然主流浏览器渲染过程叫法有区别，但是主要流程还是相同的。</p><p><code>Gecko</code> 将视觉格式化元素组成的树称为“框架树”。每个元素都是一个框架。<br>WebKit 使用的术语是“呈现树”，它由“呈现对象”组成。</p><p>对于元素的放置，<code>WebKit</code> 使用的术语是“布局”，而 <code>Gecko</code> 称之为“重排”。</p><p>对于连接 DOM 节点和可视化信息从而创 建呈现树的过程，<code>WebKit</code> 使用的术语是“附加”。</p><p><strong>所以可以分析出基本过程：</strong></p><ol><li>HTML解析出DOM Tree</li><li>CSS解析出Style Rules</li><li>将二者关联生成Render Tree</li><li>Layout 根据Render Tree计算每个节点的信息</li><li>Painting 根据计算好的信息绘制整个页面</li></ol><h4 id="2-2-HTML-解析"><a href="#2-2-HTML-解析" class="headerlink" title="2.2 HTML 解析"></a>2.2 HTML 解析</h4><p><code>HTML Parser</code>的任务是将HTML标记解析成<code>DOM Tree</code><br>这个解析可以参考React解析DOM的过程，但是这里面有很多别的规则和操作，比如容错机制，识别<code>&lt;/br&gt;</code>和<code>&lt;br&gt;</code>等等。<br>感兴趣的可以参考 <a target="_blank" rel="noopener" href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">《How Browser Work》</a>，<a target="_blank" rel="noopener" href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">中文翻译</a><br>举个例子：一段HTML</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Web page parsing<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>This is an example Web page.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>经过解析之后的DOM Tree差不多就是</p><p><img data-src="pic3.png"></p><p>将文本的HTML文档，提炼出关键信息，嵌套层级的树形结构，便于计算拓展。这就是HTML Parser的作用。</p><h4 id="2-3-CSS解析"><a href="#2-3-CSS解析" class="headerlink" title="2.3 CSS解析"></a>2.3 CSS解析</h4><p><code>CSS Parser</code>将CSS解析成<code>Style Rules</code>，<code>Style Rules</code>也叫<code>CSSOM（CSS Object Model）</code>。<br><code>StyleRules</code>也是一个树形结构，根据CSS文件整理出来的类似<code>DOM Tree</code>的树形结构：</p><p><img data-src="pic4.png"></p><p>与<code>HTML Parser</code>相似，<code>CSS Parser</code>作用就是将很多个CSS文件中的样式合并解析出具有树形结构Style Rules。</p><h4 id="2-4-脚本处理"><a href="#2-4-脚本处理" class="headerlink" title="2.4 脚本处理"></a>2.4 脚本处理</h4><p>浏览器解析文档，当遇到<code>&lt;script&gt;</code>标签的时候，会立即解析脚本，停止解析文档（因为JS可能会改动DOM和CSS，所以继续解析会造成浪费）。<br>如果脚本是外部的，会等待脚本下载完毕，再继续解析文档。现在可以在script标签上增加属性 <code>defer</code>或者<code>async</code>。<br>脚本解析会将脚本中改变DOM和CSS的地方分别解析出来，追加到<code>DOM Tree</code>和<code>Style Rules</code>上。</p><h4 id="2-5-呈现树（Render-Tree）"><a href="#2-5-呈现树（Render-Tree）" class="headerlink" title="2.5 呈现树（Render Tree）"></a>2.5 呈现树（Render Tree）</h4><p><code>Render Tree</code>的构建其实就是<code>DOM Tree</code>和<code>CSSOM</code> <strong>Attach</strong>的过程。</p><p>呈现树是和 DOM 元素相对应的，但并非一一对应。Render Tree实际上就是一个计算好样式，与HTML对应的（包括哪些显示，那些不显示）的Tree。</p><blockquote><p>在 WebKit 中，解析样式和创建呈现树的过程称为“附加”。每个 DOM 节点都有一个<code>“attach”</code>方法。附加是同步进行的，将节点插入 DOM 树需要调用新的节点<code>“attach”</code>方法。</p></blockquote><p><img data-src="pic5.png"></p><h4 id="2-6-样式计算"><a href="#2-6-样式计算" class="headerlink" title="2.6 样式计算"></a>2.6 样式计算</h4><p>样式计算是个很复杂的问题。DOM中的一个元素可以对应样式表中的多个元素。样式表包括了所有样式：浏览器默认样式表，自定义样式表，inline样式元素，<strong>HTML可视化属性如：width=100。后者将转化以匹配CSS样式。</strong></p><blockquote><p>WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：</p><ol><li>这些元素必须处于相同的鼠标状态（例如，不允许其中一个是“:hover”状态，而另一个不是）</li><li>任何元素都没有 ID</li><li>标记名称应匹配</li><li>类属性应匹配</li><li>映射属性的集合必须是完全相同的</li><li>链接状态必须匹配</li><li>焦点状态必须匹配</li><li>任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配</li><li>元素中不能有任何 inline 样式属性</li><li>不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 + 选择器以及 :first-child 和 :last-child 等选择器。</li></ol></blockquote><p>为了简化样式计算，Firefox 还采用了另外两种树：规则树和样式上下文树。WebKit 也有样式对象，但它们不是保存在类似样式上下文树这样的树结构中，只是由 DOM 节点指向此类对象的相关样式。</p><p><img data-src="pic6.png"></p><p>样式上下文包含端值。要计算出这些值，应按照正确顺序应用所有的匹配规则，并将其从逻辑值转化为具体的值。<br>例如，<strong>如果逻辑值是屏幕大小的百分比，则需要换算成绝对的单位</strong>。规则树的点子真的很巧妙，它使得节点之间可以共享这些值，以避免重复计算，还可以节约空间。<br>所有匹配的规则都存储在树中。路径中的底层节点拥有较高的优先级。规则树包含了所有已知规则匹配的路径。规则的存储是延迟进行的。规则树不会在开始的时候就为所有的节点进行计算，而是只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径。</p><p>*<strong>举个例子</strong> 一段HTML代码：*</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=&quot;<span class="symbol">err</span>&quot; <span class="symbol">id</span>=&quot;<span class="symbol">div1</span>&quot;&gt;</span><br><span class="line">      &lt;<span class="symbol">p</span>&gt;</span><br><span class="line">        <span class="symbol">this</span> <span class="symbol">is</span> <span class="symbol">a</span> &lt;<span class="symbol">span</span> <span class="symbol">class</span>=&quot;<span class="symbol">big</span>&quot;&gt; <span class="symbol">big</span> <span class="symbol">error</span> &lt;/<span class="symbol">span</span>&gt;</span><br><span class="line">        <span class="symbol">this</span> <span class="symbol">is</span> <span class="symbol">also</span> <span class="symbol">a</span></span><br><span class="line">        &lt;<span class="symbol">span</span> <span class="symbol">class</span>=&quot;<span class="symbol">big</span>&quot;&gt; <span class="symbol">very</span>  <span class="symbol">big</span>  <span class="symbol">error</span>&lt;/<span class="symbol">span</span>&gt; <span class="symbol">error</span></span><br><span class="line">      &lt;/<span class="symbol">p</span>&gt;</span><br><span class="line">    &lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">    &lt;<span class="symbol">div</span> <span class="symbol">class</span>=&quot;<span class="symbol">err</span>&quot; <span class="symbol">id</span>=&quot;<span class="symbol">div2</span>&quot;&gt;<span class="symbol">another</span> <span class="symbol">error</span>&lt;/<span class="symbol">div</span>&gt;</span><br><span class="line">  &lt;/<span class="symbol">body</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">html</span>&gt;</span><br></pre></td></tr></table></figure><p>对应CSS规则如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. <span class="selector-tag">div</span> &#123;<span class="attribute">margin</span>:<span class="number">5px</span>;<span class="attribute">color</span>:black&#125;</span><br><span class="line">2. <span class="selector-class">.err</span> &#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line">3. <span class="selector-class">.big</span> &#123;<span class="attribute">margin-top</span>:<span class="number">3px</span>&#125;</span><br><span class="line">4. <span class="selector-tag">div</span> <span class="selector-tag">span</span> &#123;<span class="attribute">margin-bottom</span>:<span class="number">4px</span>&#125;</span><br><span class="line">5. <span class="selector-id">#div1</span> &#123;<span class="attribute">color</span>:blue&#125;</span><br><span class="line">6. <span class="selector-id">#div2</span> &#123;<span class="attribute">color</span>:green&#125;</span><br></pre></td></tr></table></figure><p>则CSS形成的规则树如下图所示（节点的标记方式为“节点名 : 指向的规则序号”）</p><p><img data-src="pic7.png"></p><blockquote><p>下面的内容有点绕，但是很有逻辑</p></blockquote><p>假设我们解析 HTML 时遇到了第二个 <code>&lt;div&gt;</code> 标记，我们需要为此节点创建样式上下文，并填充其样式结构。<br>经过规则匹配，我们发现该 <code>&lt;div&gt;</code>的匹配规则是第 1、2 和 6 条。这意味着规则树中已有一条路径可供我们的元素使用，我们只需要再为其添加一个节点以匹配第 6 条规则（规则树中的 F 节点）。<br>我们将创建样式上下文并将其放入上下文树中。新的样式上下文将指向规则树中的 F 节点。</p><p>现在我们需要填充样式结构。首先要填充的是 margin 结构。由于最后的规则节点 (F) 并没有添加到 margin 结构，我们需要上溯规则树，直至找到在先前节点插入中计算过的缓存结构，然后使用该结构。我们会在指定 margin 规则的最上层节点（即 B 节点）上找到该结构。</p><p>我们已经有了 color 结构的定义，因此不能使用缓存的结构。由于 color 有一个属性，我们无需上溯规则树以填充其他属性。我们将计算端值（将字符串转化为 <code>RGB</code> 等）并在此节点上缓存经过计算的结构。</p><p>第二个<code>&lt;span&gt;</code>元素处理起来更加简单。我们将匹配规则，最终发现它和之前的 span 一样指向规则 G。由于我们找到了指向同一节点的同级，就可以共享整个样式上下文了，只需指向之前 span 的上下文即可。</p><p>对于包含了继承自父代的规则的结构，缓存是在上下文树中进行的（事实上 color 属性是继承的，但是 Firefox 将其视为 reset 属性，并缓存到规则树上）<br>所以生成的上下文树如下：</p><p><img data-src="pic8.png"></p><h4 id="2-7-以正确的层叠顺序应用规则"><a href="#2-7-以正确的层叠顺序应用规则" class="headerlink" title="2.7 以正确的层叠顺序应用规则"></a>2.7 以正确的层叠顺序应用规则</h4><p>样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。<br>如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。</p><p>一些例子：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">*             &#123;&#125;  /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span></span><br><span class="line"><span class="keyword">li</span>            &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span></span><br><span class="line"><span class="keyword">li</span>:first-<span class="keyword">line</span> &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></span><br><span class="line">ul <span class="keyword">li</span>         &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span></span><br><span class="line">ul ol+<span class="keyword">li</span>      &#123;&#125;  <span class="comment">/* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span></span><br><span class="line">h1 + *[rel=up]&#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span></span><br><span class="line">ul ol <span class="keyword">li</span>.red  &#123;&#125;  <span class="comment">/* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span></span><br><span class="line"><span class="keyword">li</span>.red.level  &#123;&#125;  <span class="comment">/* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span></span><br><span class="line">#x34y         &#123;&#125;  <span class="comment">/* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span></span><br><span class="line">style=<span class="string">&quot;&quot;</span>          <span class="comment">/* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span></span><br></pre></td></tr></table></figure><p>利用上面的方法，基本可以快速确定不同选择器的优先级。</p><h4 id="2-8-布局Layout"><a href="#2-8-布局Layout" class="headerlink" title="2.8 布局Layout"></a>2.8 布局Layout</h4><p>创建渲染树后，下一步就是<code>布局（Layout）</code>,或者叫<code>回流（reflow,relayout）</code>，这个过程就是通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸，将其安置在浏览器窗口的正确位置，而有些时候我们会在文档布局完成后对DOM进行修改，这时候可能需要重新进行布局，也可称其为<code>回流</code>，本质上还是一个布局的过程，每一个渲染对象都有一个布局或者回流方法，实现其布局或回流。</p><p><strong>对渲染树的布局可以分为全局和局部的</strong></p><ul><li>全局即对整个渲染树进行重新布局，如<u>当我们改变了窗口尺寸或方向</u>或者是<u>修改了根元素的尺寸或者字体大小</u>等；</li><li>而局部布局可以是对渲染树的某部分或某一个渲染对象进行重新布局。</li></ul><p>大多数web应用对DOM的操作都是比较频繁，这意味着经常需要对DOM进行布局和回流，而如果仅仅是一些小改变，就触发整个渲染树的回流，这显然是不好的，为了避免这种情况，浏览器使用了<code>脏位系统</code>，只有一个渲染对象改变了或者某渲染对象及其子渲染对象脏位值为”dirty”时，说明需要回流。</p><blockquote><p>表示需要布局的脏位值有两种：</p><ul><li>“dirty”–自身改变，需要回流</li><li>“children are dirty”–子节点改变，需要回流</li></ul></blockquote><p>布局是一个从上到下，从外到内进行的递归过程，从根渲染对象，即对应着HTML文档根元素，然后下一级渲染对象，如对应着元素，如此层层递归，依次计算每一个渲染对象的几何信息（位置和尺寸）。</p><p><strong>每一个渲染对象的布局流程基本如：</strong></p><ol><li><p>计算渲染对象的宽度（width）；</p></li><li><p>遍历此渲染对象的所有子级，依次：</p><p>2.1设置子级渲染对象的坐标</p><p>2.2判断是否需要触发子渲染对象的布局或回流方法，计算子渲染对象的高度（height）</p></li><li><p>设置此渲染对象的高度：根据子渲染对象的累积高，margin和padding的高度设置其高度；</p></li><li><p>设置此渲染对象脏位值为false。</p></li></ol><h4 id="2-9-绘制（Painting）"><a href="#2-9-绘制（Painting）" class="headerlink" title="2.9 绘制（Painting）"></a>2.9 绘制（Painting）</h4><p>在绘制阶段，系统会遍历呈现树，并调用呈现器的<code>“paint”</code>方法，将呈现器的内容显示在屏幕上。绘制工作是使用用户界面基础组件完成的。</p><p>CSS2 规范定义了绘制流程的顺序。绘制的顺序其实就是元素进入堆栈样式上下文的顺序。这些堆栈会从后往前绘制，因此这样的顺序会影响绘制。块呈现器的堆栈顺序如下：</p><ol><li>背景颜色</li><li>背景图片</li><li>边框</li><li>子代</li><li>轮廓</li></ol><p>这里还要说两个概念，一个是<code>Reflow</code>，另一个是<code>Repaint</code>。这两个不是一回事。<br><strong>Repaint</strong> ——屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。<br><strong>Reflow</strong> 元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是Reflow，或是Layout。（HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫reflow）reflow 会从<code>&lt;html&gt;</code>这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。</p><blockquote><p>Reflow的成本比Repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的。</p></blockquote><p>所以，下面这些动作有很大可能会是成本比较高的。</p><ul><li>当你增加、删除、修改DOM结点时，会导致Reflow或Repaint</li><li>当你移动DOM的位置，或是搞个动画的时候。</li><li>当你修改CSS样式的时候。</li><li>当你Resize窗口的时候（移动端没有这个问题），或是滚动的时候。</li><li>当你修改网页的默认字体时。</li><li>注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。</li></ul><p>基本上来说，reflow有如下的几个原因：</p><ul><li>Initial。网页初始化的时候。</li><li>Incremental。一些Javascript在操作DOM Tree时。</li><li>Resize。其些元件的尺寸变了。</li><li>StyleChange。如果CSS的属性发生变化了。</li><li>Dirty。几个Incremental的reflow发生在同一个frame的子树上。</li></ul><p>看几个例子：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>); <span class="regexp">//</span> repaint</span><br><span class="line">$(<span class="string">&#x27;body&#x27;</span>).css(<span class="string">&#x27;margin&#x27;</span>, <span class="string">&#x27;2px&#x27;</span>); <span class="regexp">//</span> reflow, repaint</span><br><span class="line"></span><br><span class="line">var bstyle = document.body.style; <span class="regexp">//</span> cache</span><br><span class="line"></span><br><span class="line">bstyle.padding = <span class="string">&quot;20px&quot;</span>; <span class="regexp">//</span> reflow, repaint</span><br><span class="line">bstyle.border = <span class="string">&quot;10px solid red&quot;</span>; <span class="regexp">//</span>  再一次的 reflow 和 repaint</span><br><span class="line"></span><br><span class="line">bstyle.color = <span class="string">&quot;blue&quot;</span>; <span class="regexp">//</span> repaint</span><br><span class="line">bstyle.backgroundColor = <span class="string">&quot;#fad&quot;</span>; <span class="regexp">//</span> repaint</span><br><span class="line"></span><br><span class="line">bstyle.fontSize = <span class="string">&quot;2em&quot;</span>; <span class="regexp">//</span> reflow, repaint</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> new DOM element - reflow, repaint</span><br><span class="line">document.body.appendChild(document.createTextNode(<span class="string">&#x27;dude!&#x27;</span>));</span><br></pre></td></tr></table></figure><p>当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就reflow或repaint一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次reflow，这又叫异步reflow或增量异步reflow。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行reflow。</p><p>但是有些时候，我们的脚本会阻止浏览器这么干，比如：如果我们请求下面的一些DOM值：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offsetTop, offsetLeft, offsetWidth, offsetHeight</span><br><span class="line">scrollTop<span class="regexp">/Left/</span>Width/Height</span><br><span class="line">clientTop<span class="regexp">/Left/</span>Width/Height</span><br><span class="line">IE中的 getComputedStyle(), 或 currentStyle</span><br></pre></td></tr></table></figure><p>因为，如果我们的程序需要这些值，那么浏览器需要返回最新的值，而这样一样会flush出去一些样式的改变，从而造成频繁的reflow/repaint。</p><h4 id="2-10-Chrome调试工具查看页面渲染顺序"><a href="#2-10-Chrome调试工具查看页面渲染顺序" class="headerlink" title="2.10 Chrome调试工具查看页面渲染顺序"></a>2.10 Chrome调试工具查看页面渲染顺序</h4><p>页面的渲染详细过程可以通过chrome开发者工具中的timeline查看</p><p><img data-src="pic9.png"></p><ol><li>发起请求；</li><li>解析HTML；</li><li>解析样式；</li><li>执行JavaScript；</li><li>布局；</li><li>绘制</li></ol><h2 id="二、页面渲染优化"><a href="#二、页面渲染优化" class="headerlink" title="二、页面渲染优化"></a>二、页面渲染优化</h2><p>浏览器对上文介绍的关键渲染路径进行了很多优化，针对每一次变化产生尽量少的操作，还有优化判断重新绘制或布局的方式等等。<br>在改变文档根元素的字体颜色等视觉性信息时，会触发整个文档的重绘，而改变某元素的字体颜色则只触发特定元素的重绘；改变元素的位置信息会同时触发此元素（可能还包括其兄弟元素或子级元素）的布局和重绘。某些重大改变，如更改文档根元素的字体尺寸，则会触发整个文档的重新布局和重绘，据此及上文所述，推荐以下优化和实践：</p><ol><li>HTML文档结构层次尽量少，最好不深于六层；</li><li>脚本尽量后放，放最后即可；</li><li>少量首屏样式内联放在标签内；</li><li>样式结构层次尽量简单；</li><li>在脚本中尽量减少DOM操作，尽量缓存访问DOM的样式信息，避免过度触发<code>回流</code>；</li><li>减少通过JavaScript代码修改元素样式，尽量使用修改class名方式操作样式或动画；</li><li>动画尽量使用在绝对定位或固定定位的元素上；</li><li>隐藏在屏幕外，或在页面滚动时，尽量停止动画；</li><li>尽量缓存DOM查找，查找器尽量简洁；</li><li>涉及多域名的网站，可以开启域名预解析</li></ol><p><strong>补充</strong></p><p>HTML整个解析过程看起来很简单，但是我们要知道解析过程中css、Js和DOM的加载顺序。我们都知道HTML是自上往下解析的，在解析过程中：</p><p>1、如果遇到link和style，那就就会去下载这些外部的css资源，但是css跟DOM的构建是并行的，就是说不会阻塞DOM树的构建。</p><p>2、如果遇到script，那么页面就会把控制权交给JavaScript，直到脚本加载完毕或者是执行完毕。</p><p>3、页面的渲染是依靠render树，也就是说如果css没有加载完成，页面也不会渲染显示。</p><p>4、JavaScript执行过程中有可能需要改变样式，所以css加载也会阻塞JavaScript的加载。</p><p>5、JavaScript执行过程中如果操作DOM，但是DOM树又是在JavaScript之后才能构建，就会报错，找不到节点。</p><p>这就是HTML的渲染过程，因为DOM和css并行构建，我们会把css用外部引入，可以更快的构建DOM，因为JavaScript会阻塞DOM和css构建，且操作DOM一定要在DOM构建完成，我们选择把script放在最下面。如果我们过多的在render渲染完成后改变render，那么重排和重绘就会一直被动重发执行，这也会造成渲染速度变慢。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>浏览器渲染问题每一步都涉及到很多底层知识，每一步都有对应的算法。<br>文章中间很多语句都是直接复制的原文，自己的语言概况还是不及原文精彩。</p><p><strong>可参考原文链接</strong></p><p><a target="_blank" rel="noopener" href="https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">《How Browser Work》</a></p><p><a target="_blank" rel="noopener" href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/">浏览器的工作原理：新式网络浏览器幕后揭秘</a></p><p><a target="_blank" rel="noopener" href="http://imweb.io/topic/56841c864c44bcc56092e3fa">浏览器渲染原理</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25279069">浏览器 渲染,绘制流程及性能优化</a></p><p><a target="_blank" rel="noopener" href="http://caibaojian.com/css-reflow-repaint.html">优化CSS重排重绘与浏览器性能</a></p><p><a target="_blank" rel="noopener" href="http://web.jobbole.com/90961/">浅析前端页面渲染机制</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div><div>﻿<div><div style="text-align:center;color:#ccc;font-size:14px;display:flex;justify-content:center"><span style="display:inline-block">------ 今天只会更爱哈尼小宝贝&nbsp;</span> <span style="color:#f17c67;margin:0 5px;display:inline-block;animation:iconAnimate 1.33s ease-in-out infinite"><i class="fa fa-heart" aria-hidden="true"></i></span> <span style="display:inline-block">&nbsp;&nbsp;The End of This Article------</span></div></div></div><div class="reward-container"><div></div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.jpg" alt="Moustache 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.jpg" alt="Moustache 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Moustache</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://hammerzer.github.io/2020/08/29/HTML-render/" title="HTML渲染">https://hammerzer.github.io/2020/08/29/HTML-render/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Html/" rel="tag"><i class="fa fa-tag"></i> Html</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/08/28/HTML-Bacics/" rel="prev" title="HTML基本问题"><i class="fa fa-chevron-left"></i> HTML基本问题</a></div><div class="post-nav-item"><a href="/2020/08/31/HTML-tags/" rel="next" title="HTML标签">HTML标签 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81HTML%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="nav-text">一、HTML渲染过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HTML%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="nav-text">1. HTML解析过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E8%AF%A6%E8%A7%A3"><span class="nav-text">2. 浏览器渲染页面详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B"><span class="nav-text">2.1 浏览器渲染主要流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-HTML-%E8%A7%A3%E6%9E%90"><span class="nav-text">2.2 HTML 解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-CSS%E8%A7%A3%E6%9E%90"><span class="nav-text">2.3 CSS解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E8%84%9A%E6%9C%AC%E5%A4%84%E7%90%86"><span class="nav-text">2.4 脚本处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E5%91%88%E7%8E%B0%E6%A0%91%EF%BC%88Render-Tree%EF%BC%89"><span class="nav-text">2.5 呈现树（Render Tree）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-%E6%A0%B7%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="nav-text">2.6 样式计算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-%E4%BB%A5%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%B1%82%E5%8F%A0%E9%A1%BA%E5%BA%8F%E5%BA%94%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-text">2.7 以正确的层叠顺序应用规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-%E5%B8%83%E5%B1%80Layout"><span class="nav-text">2.8 布局Layout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-%E7%BB%98%E5%88%B6%EF%BC%88Painting%EF%BC%89"><span class="nav-text">2.9 绘制（Painting）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-10-Chrome%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7%E6%9F%A5%E7%9C%8B%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E9%A1%BA%E5%BA%8F"><span class="nav-text">2.10 Chrome调试工具查看页面渲染顺序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96"><span class="nav-text">二、页面渲染优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Moustache" src="/images/p1.png"><p class="site-author-name" itemprop="name">Moustache</p><div class="site-description" itemprop="description">我是小胡子</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Hammerzer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Hammerzer" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:stellar_lzu@163.com" title="E-Mail → mailto:stellar_lzu@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://hammerzer.github.io/" title="Moustache → https:&#x2F;&#x2F;hammerzer.github.io"><i class="codepen fa-fw"></i>Moustache</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Moustache</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">123k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">1:51</span></div><div class="busuanzi-count"><script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script size="300" alpha="0.4" zindex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script><script src="/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script>var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});</script><script src="/js/local-search.js"></script><script data-pjax>if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}</script><div id="pjax"><script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script><script>window.addEventListener('load', () => {
      quicklink({
        timeout : 10000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'https://hammerzer.github.io/2020/08/29/HTML-render/',]
      });
      });</script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'JRehDoQ6pHXV1zKg09AMNLFt-gzGzoHsz',
      appKey     : 'cRAt4W15KiQdrIuHlQrRrtIl',
      placeholder: "Just Comment",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : ''
    });
  }, window.Valine);
});</script></div></body></html><script type="text/javascript" src="/js/clicklove.js"></script><script type="text/javascript">for(var href=document.getElementsByTagName("a"),i=0;i<href.length;i++)href[i].ontouchend=function(){window.location.href=this.getAttribute("href")}</script>